<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C内嵌ARM汇编]]></title>
    <url>%2F2019%2F08%2F24%2F2019-08-24-C-Assembly%2F</url>
    <content type="text"><![CDATA[汇编语言经常会用在启动引导文件中，设置好相应的堆栈和必要的功能外设，才会跳转到C入口，但是我们只是知道汇编指令的功能，看不到每一步的具体实现。下面通过C语言内嵌汇编，做一些简单的例子。 C语言内嵌汇编基本格式C语言内嵌汇编有两种基本格式，volatile表明编译其不要优化代码， 12345678910111213141516__asm__ __volatile__( "xxxxxxxxxxxx\n" ；指令1 用“\n”换行 "xxxxxxxxxxxx\n" ；指令2 用“\n”换行 "xxxxxxxxxxxx\n" ；指令3 用“\n”换行 ：声明输出或输入变量；“=&amp;r” 输出变量；“+r”输入输出变量 ：声明输入变量 ； “r” 输入变量 ：声明保护寄存器；“r0” 。。。。);asm volatile( "xxxxxxxxxxxx\n" ；指令1 用“\n”换行 "xxxxxxxxxxxx\n" ；指令2 用“\n”换行 "xxxxxxxxxxxx\n" ；指令3 用“\n”换行 ：声明输出或输入变量；“=&amp;r” 输出变量；“+r”输入输出变量 ：声明输入变量 ； “r” 输入变量 ：声明保护寄存器；“r0” 。。。。); 例11234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; int main()&#123; unsigned int register a asm(&quot;r5&quot;); printf(&quot;a = %d\r\n&quot;,a); __asm__ __volatile__( &quot;mov r5,#100\n&quot; : : :&quot;r5&quot; ); printf(&quot;a = %d\r\n&quot;,a); return 0; &#125; 上面简单例子是将a变量和r5通用寄存器进行绑定，在内嵌汇编里面对r5寄存器操作a的值也会相应改变 例2123456789101112131415161718192021222324#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main()&#123; unsigned int a=1, b=2,c=3; int d,e,f; __asm__ __volatile__( &quot;mov r0, %[a]\n&quot; &quot;mov r1, %[b]\n&quot; &quot;mov r2, %[c]\n&quot; &quot;mov %[d], r0\n&quot; &quot;mov %[e], r1\n&quot; &quot;mov %[f], r2\n&quot; :[d]&quot;=&amp;r&quot;(d),[e]&quot;=&amp;r&quot;(e),[f]&quot;=&amp;r&quot;(f) :[a]&quot;r&quot;(a),[b]&quot;r&quot;(b),[c]&quot;r&quot;(c) :&quot;r0&quot;,&quot;r1&quot;,&quot;r2&quot; ); printf(&quot;d = %d\r\n&quot;,d); printf(&quot;e = %d\r\n&quot;,e); printf(&quot;f = %d\r\n&quot;,f); return 0; &#125; 上面内嵌汇编的功能就是将变量a,b,c的值赋值给变量d，e，f。第一个冒号后面将C函数的变量声明为输出变量名且别名位%[d] %[e]%[f]。也可以使用默认的%0 %1 依次对C函数的变量进行操作 例3123456789101112131415161718192021222324252627 #include &lt;stdio.h&gt; int mysum(int num1,int num2)&#123; int sum1,sum2; __asm__ __volatile__( "ldr r0 ,=0xfffffff8\n" "ldr r1 ,=0xa\n" "adds %[sum1] ,r0,r1\n" "ldr r0, =1\n" "ldr r1, =1\n" "adc %[sum2],r0,r1\n" :[sum1]"=&amp;r"(sum1),[sum2]"=&amp;r"(sum2) :[num1]"r"(num1),[num2]"r"(num2) :"r0","r1" ); printf("sum1 = %ld\n",sum1); printf("sum2 = %ld\n",sum2); return sum2; &#125; int main(void) &#123; int a=0xfffffff4 ,b =0x11; printf("sum =a+b= %ld\r\n",mysum(a,b)); return 0;&#125; 上面例子是add指令的使用，add是基础的加指令，CSPR_C不会产生进位结合借位。adds会产生CSPR_C不会产生进位结合借位。adc在相加的时候会将CSPR_C的位相加。 这里ldr是一个伪指令：ldr可以将任意值赋值给寄存器。在这里mov指令需要满足三个条件中的一个才能使用： 立即数小于255 ； eg：mov r0 ，254 立即数右移偶数次小于255 ； eg： mov r0 ，0xf100 ； 0xff00右移8位，0xf1小于0xff， 立即数是特殊值；0xfffffff 总结这里举的例子都是比较简单的，虽然汇编使用不多，但是在能看懂汇编语言我们才可以在其基础上修改，例如堆栈的大小和基地址。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QEMU</tag>
        <tag>ARM汇编</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QEMU模拟AMRM-A9（tftp挂载kenel，nfs挂载rotfs）]]></title>
    <url>%2F2019%2F07%2F30%2F2019-07-30-QEMU-ARM-A9-TFTP-NFS%2F</url>
    <content type="text"><![CDATA[初次接触linux系统是使用的2440的板子，跟着韦东山老师学习了uboot kernel 和文件系统，也算是入门了，后面又使用4412板子做了一些应用层的项目。但是底层的uboot和内核和文件系统都是在厂商的支持下，做的较为简单二次开发。已经毕业一个月了，业余时间太多，想好好学学驱动层的东西，但是苦于刚毕业，所以准备采用qemu模拟出arm的开发环境，这样我们只用关注软件层面。 开发环境 Ubuntu：Ubuntu 19.04 qemu： QEMU emulator version 3.1.0 arm交叉编译器：gcc version 4.8.3 20140320 QEMU简介Ubuntu安装qemu-system-arm这里有两种方法： 系统提供的源安装：在ubuntu的Terminal下输入以下命令： 123sudo apt-get install qemusudo apt-get install qemu-system-arm安装完之后：qemu-system-arm -version 查看qemu版本 使用ubuntn16版本的时候，使用第一个命令安装就可以，但是使用Ubuntu19.04时，使用第一个命令安装完，搜索不到qemu-system-arm这个命令，还需要使用第二个命令安装。使用系统的源安装可以解决库依赖的问题。 源文件编译安装：使用源文件安装我们需要使用git 将工程clone到本地（如果没有git的话，需要先去官网注册，然后在Ubuntu安装，配置等），安装之前还需要解决QEMU编译依赖的包，也可以在安装的过程中根据缺少的库依次安装。 1234下载源码：sudo git clone git://git.qemu.org/qemu.git可以使用git命令切换到稳定版本：git checkout xxxx编译配置 ./configure (可以使用 ./configure -help 查看支持的参数)安装: make &amp;&amp; make install (不出意外的话可以成功安装) 比较这个两种方法可以知道，第二种虽然比较复杂，但是灵活度更高，可以配置参数。第一种安装简单。 在启动uboot之前，我们还需要安装arm的交叉编译器，这里推荐不要用太老，也不要用太新的编译器（个人建议，以为有时候uboot kernel和文件系统会因为交叉编译器太老启动失败），可以直接去CodeSourcery Linaro 或者别的官网下载源码。 qemu-system-arm启动uboot下载uboot源码： 121.在浏览器下载：https://ftp.denx.de/pub/u-boot/2.wget命令下载：wget https://ftp.denx.de/pub/u-boot/u-boot-xxxxx.tar.bz2（版本自己选择） 检测arm交叉编译器是否安装成功： 1arm-none-linux-gnueabi-gcc -v 这里我自己编译一个简单的脚本 配置生成uboot 123456#!/bin/bash export ARCH=arm #指定编译生成架构 ，也可以在uboot根目录的Makefile修改export CROSS_COMPILE=arm-none-linux-gnueabi- #指定编译生成的交叉编译链，也可以在uboot根目录的Makefile修改make vexpress_ca9x4_defconfig #编译我们要生成平台u-boot.bin的配置文件，在uboot根目录下会生成.config文件（主要有点，ls -al 才能看到）。另外make menuconfig图形化配置也会最终修改.config文件里面的内容。也可以直接修改.configsource /etc/profile #我将交叉编译链的环境变量添加到profile文件里面。以防万一，让其生效make #生成 执行成功之后会看到生成u-boot u-boot.bin等文件，使用以下命令可以核对生成文件的架f构： 1file u-boot qemu启动uboot脚本（注意给脚本权限） 123456 #!/bin/shqemu-system-arm \ -M vexpress-a9 \ #指定开发板 -m 512M \ #内存 -nographic \ #不使用LCD屏，即使用当前Terminal -kernel /home/linux/armuboot/u-boot-2017.05/u-boot \ uboot有一个循环的命令解释器，在启动3秒内（时间可设置），按任意键即可进入。 可以在3秒内进入uboot的终端解释器，使用print打印当前的环境变量 123print #打印当前变量serenv #设置环境变量saveenv #保存环境变量到flash 这里uboot已经启动成功，下面我们使用uboot加载kernel，如果有板子的话一般都是通过下载到板子里面然后再启动，但是这样子比较浪费时间，这里我们采用tftp网口下载直接运行的方式运行kernel。 uboot引导kernel+rootfs在uboot初始化完成之后会将需要传给内核的参数放到一段内存空间，然后运行内核 文件系统，内核会从这段空间取相应的信息MachineID bootargs console等等信息(个人理解，如果不正确Email联系) tftp加载kerneluboot通过以太网从ftp服务器获得kernel的uImage，所以我们在使用虚拟机Ubuntu系统要和qemu位于同一个网段，这里将Ubuntu设置位NAT模式。创建一个网桥，将ubuntu和qemu的网卡都连接到网桥。uImage和zImage的区别是uImage压缩过，解压之后uImage和zImage几乎相同。之前分析uboot的uboot代码的时候只支持uImage启动，但是可以通过修改uboot代码支持启动zImage，也不难。tftp加载kernel的原理就是在Ubuntu安装tftp服务器，uboot会从tftp下载内核。下面分步进行操作： 创建网桥和qemu的虚拟网卡tap0 1234567891011121314151617安装工具包：apt-get install uml-utilities bridge-utils修改/etc/network/interfaces文件：auto loiface lo inet loopbackauto tap0auto ens33auto tap0auto br0iface br0 inet dhcp bridge_ports all tap0重启，使用nmcli可以看到添加到的br0桥添加tap0网卡，并将网卡连接到br0： tunctl -t tap0 -u root brctl addif br0 tap0 ifconfig tap0 0.0.0.0 promisc up配置之后重启网络： service networking restart 安装tftp服务器 123456 apt-get install tftp-hpa tftpd-hpa xinetd 修改配置文件:/etc/default/tftpd-hpa : TFTP_USERNAME="tftp"TFTP_DIRECTORY="/home/linux/tftpboot" #这个是我们创建的tftp服务器存放文件路径，权限：0777TFTP_ADDRESS="0.0.0.0:69"TFTP_OPTIONS="-l -c -s" 编译内核： 12345678下载linux源码：https://mirrors.edge.kernel.org/pub/linux/kernel/进入源码根目录的Makefile：修改ARCH和CROSS_COMPILEARCH ？=armCROSS_COMPILE？=arm-none-linux-gnueabi-执行配置文件：make vexpress_defconfig （linux-5.2/arch/arm/configs 里面放的各种板子支持的配置文件）使用图形配置kernel支持nfs和tftp： make menuconfig安装生成： make LOADADDR=0x60003000 uImage -j6 # (-j6是多线程执行) qemu的启动脚本 1234567 qemu-system-arm \-M vexpress-a9 \-kernel /home/linux/armuboot/u-boot-2017.05/u-boot \-nographic \-m 512M \-net nic \-net tap,ifname=tap0 加载内核 手动加载 123456在手动加载之前需要重启系统，并且确保tap0连接到br0网桥，使用nmcli命令查看br0的IP执行4步骤的脚本，在3秒内，任意键进入终端执行如下命令：setenv IPADDR 192.168.5.126setenv SERVERIP 192.168.5.128 #这里的IP是br0的IPtftp 0x60003000 uImage #将tftp的路径下的uImage下载到0x60003000地址bootm 0x60003000 #手动启动内核 自动加载 12345678进入uboot根目录 打开vim include/configs/vexpress_common.h修改如下：#define CONFIG_BOOTCOMMAND "tftp 0x60003000 uImage;tftp 0x60500000 vexpress-v2p-ca9.dtb; setenv bootargs 'root=/dev/mmcblk0 console=ttyAMA0';bootm 0x60003000 - 0x60500000;"#define CONFIG_IPADDR 192.168.5.126 #define CONFIG_NETMASK 255.255.255.0#define CONFIG_SERVERIP 192.168.5.139执行4步骤的脚本，会相继看到下面两个过程 nfs加载rootfs上面已经成功启动内核，但是还需要文件系统的支持才能进入命令行终端，可以使用busybox工具创建，可以参考网上教程。这里可以使用两种方式挂载rootfs，但是为了使用方便，我们通过nfs挂载，便于后续的开发调试。 1234567891011121314151617安装：sudo apt-get install nfs-kernel-server配置：在/etc/exports文件中添加：/home/linux/armsystem/rootfs *(rw,sync,no_root_squash,no_subtree_check)保存重启服务：service rpcbind restartservice nfs-kernel-server restart进入uboot的根目录修改文件：vim include/configs/vexpress_common.h #define CONFIG_BOOTCOMMAND "tftp 0x60003000 uImage;tftp 0x60500000 vexpress -v2p-ca9.dtb; setenv bootargs 'root=/dev/nfs rw nfsroot=192.168.5.140:/home/ linux/armsystem/rootfs ip=192.168.5.126:192.168.5.140:255.255.255.0:eh0:off init=/linuxrc console=ttyAMA0';bootm 0x60003000 - 0x60500000;" #define CONFIG_IPADDR 192.168.5.126 #define CONFIG_NETMASK 255.255.255.0 #define CONFIG_SERVERIP 192.168.5.140重新编译uboot执行上一节4步骤脚本 到此整个环境就搭建完成了。期间会遇见很多不可知的错误，慢慢研究就肯定能搞明白。 #nfs挂载一直失败 使用nfs挂在文件系统的时候，前面搭建一切顺利，但就是挂载不上去的原因就是较新版本的Ubuntu系统，只支持nfs协议3和协议4，但是uboot只支持nfs协议2，所以需要修改Ubuntu的配置文件如下： 123vim /etc/default/nfs-kernel-server尾行添加：RPCNFSDOPTS=&quot;--nfs-version 2,3,4 --debug --syslog&quot; 保存，重启nfs即可 总结使用qemu模拟arm有利也有弊，我们不能真正的点亮LED灯，但是对于学习内核驱动，不用关注硬件，将会有更多的时间学习驱动。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Video for Linux two]]></title>
    <url>%2F2019%2F05%2F25%2F2019-05-25-V4L2%2F</url>
    <content type="text"><![CDATA[Linux操作系统内核的采用的是V4L2视频设备内核驱动。该框架是在V4L的基础上进行扩展升级。视频的采集使用流水线的方式传输，通过使用V4L2的视频采集框架流程，在内核空间申请出缓存，在主线程下，图像的每一帧都向缓存空间传输。 V4L2（Video for Linux two ）流程在将QT+opencv 移植到Arm上面的时候发现不能直接用QT或者是Opencv提供的库函数进行视频采集，从网上查得发现，还需要将GTK的库也移植到板子上去，好像实施的可能性不大，（网上说的非常复杂，并且得不偿失），这里可以使用V4l2 ，他给linux下的视频设备提供了一套接口规范。从Linux2.5之后都默认有这个开发接口。（可以看下/usr/include/linux/下面是否有videodev2.h） 可以在V4L2官网下载英文版的手册 CSDN 有中文版的 下面的我们需要常用的结构体和宏在进行了总结，都可以在 1/usr/include/linux/videodev.h 查找的到 V4L2的常用结构体介绍() 1234567struct v4l2_requestbuffers //申请帧缓冲，对应命令VIDIOC_REQBUFS struct v4l2_capability //视频设备的功能，对应命令VIDIOC_QUERYCAP struct v4l2_input //视频输入信息，对应命令VIDIOC_ENUMINPUTstruct v4l2_standard //视频的制式，比如PAL，NTSC，对应命令 VIDIOC_ENUMSTD struct v4l2format //帧的格式，对应命令VIDIOC_GFMT、VIDIOC_S_FMT等struct v4l2_buffer //驱动中的一帧图像缓存，对应命令VIDIOC_QUERYBUF struct v4l2_crop //视频信号矩形边框v4l2_std_id //视频制式 V4L2常用的宏 123456789101112131415VIDIOC_REQBUFS //分配内存 VIDIOC_QUERYBUF //把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址 VIDIOC_QUERYCAP //查询驱动功能 VIDIOC_ENUM_FMT //获取当前驱动支持的视频格式 VIDIOC_S_FMT //设置当前驱动的频捕获格式 VIDIOC_G_FMT //读取当前驱动的频捕获格式 VIDIOC_TRY_FMT //验证当前驱动的显示格式 VIDIOC_CROPCAP //查询驱动的修剪能力 VIDIOC_S_CROP //设置视频信号的矩形边框 VIDIOC_G_CROP //读取视频信号的矩形边框VIDIOC_QBUF //把数据从缓存中读取出来 VIDIOC_DQBUF //把数据放回缓存队列 VIDIOC_STREAMON //开始视频显示函数 VIDIOC_STREAMOFF //结束视频显示函数 VIDIOC_QUERYSTD //检查当前视频设备支持的标准，例如PAL或NTSC。 看了网上好多博主写的对V4L2的流程分析，总结了下，先理清楚流程，然后再进行代码的更改和搬移（这个流程是基于视频的采集） 打开设备文件/dev/video* ，linux下一切皆文件。open函数提供了阻塞/非阻塞的方式进行打开， 打开这个文件之后，我们就要看看，这个文件有什么功能 ，视频输入，采集，音频输入输出等。 视频信号帧的裁剪，这里涉及到两个结构体 1struct v4l2_crop //视频信号矩形边框 1struct v4l2_cropcap //可裁剪区域描述 v4l2_cropcap 这个结构体就是限定了，我们可以裁剪的区域范围大小 我们通过对结构体v4l2_crop，赋值，来进行裁剪 重新设置帧的格式包括，宽度和高度等 接下来就是我们需要对帧缓冲区和内存进行分配，因为在驱动模块用户空间和内核空间是分开的，我们如果需要读取内核空间的内容的话，可以通过内存映射，或者是通过特定的函数(read )进行访问，也可以使用用户指针的方式，这里我们使用mmap函数将内核空间的内存映射到用户空间 接下来，初始化完成之后，我们就要开启数据流，这里我们在上面一步会设定缓存数量，不能超过5帧，启动数据流就是说，我们用户取出一帧，设备采集到一帧放入队列 然后将所取到的数据，进行格式转换。，这里数据转换的时候可以将RGB/YUV 转换成MJPEG，MJPEG是运动静止图像压缩技术，可以单独的压缩每一帧图像。生成序列化的运动图像。它就是一种数字压缩格式，只对帧内的空间冗余进行压缩，不对帧间的时间冗余进行压缩，压缩效率低 具体流程图如图： 移植Qt的具体代码 V4L2_QT.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339#include "v4l2_qt.h"#include "ui_v4l2_qt.h"#include "v4l2_heade.h"V4L2_QT::V4L2_QT(QWidget *parent) : QMainWindow(parent), ui(new Ui::V4L2_QT)&#123; ui-&gt;setupUi(this); Camera_fd = -1; buffers = NULL; n_buffers = 0; device = "/dev/video0";//linux device_2 = "/dev/video4";// pixel_format = V4L2_PIX_FMT_YUYV; //视频格式为MJPEG pre_w = WIDTH; //预览窗口w pre_h = HEIGHT; //预览窗口h timer=new QTimer(this); frame=new QImage(rgb,WIDTH,HEIGHT,QImage::Format_RGB888); this-&gt;setMaximumSize(640,480); this-&gt;setMinimumSize(640,480); ui-&gt;label-&gt;setMaximumSize(640,480); ui-&gt;label-&gt;setMinimumSize(640,480); readCamera(); //camera 初始化，开启视频流 connect(timer,SIGNAL(timeout()),this,SLOT(post_preview())); //将视频流post到preview窗口中，实现预览 timer-&gt;start(100);&#125;V4L2_QT::~V4L2_QT()&#123; delete ui; releaseCamera();&#125;int V4L2_QT::xioctl(int fd, int request, void *arg)&#123; int r; do r = ioctl(fd, request, arg); while (-1 == r &amp;&amp; EINTR == errno); return r;&#125;void V4L2_QT::errno_exit(const char *s)&#123; fprintf(stderr, "%s error %d, %s\n", s, errno, strerror(errno)); exit(EXIT_FAILURE);&#125;int V4L2_QT::opendevice(char*device) &#123; Camera_fd=open(device,O_RDWR); if(Camera_fd&lt;0) &#123; fprintf(stderr,"Cann't Open %s,%d,%s/n",device,errno ,strerror(errno)); return errno; &#125; else &#123; PRINTK("OPen video Success\n"); return 1; &#125; &#125; //Memory Requset void V4L2_QT::init_mmap() &#123; struct v4l2_requestbuffers reqbufs;//向驱动申请帧缓冲的请求，里面包含申请的个数 CLEAR(reqbufs);//clear reqbufs.count=4;//缓存数量，也就是说在缓存队列里保持4张照片 reqbufs.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;//数据流格式 reqbufs.memory = V4L2_MEMORY_MMAP; if(-1==xioctl(Camera_fd,VIDIOC_REQBUFS,&amp;reqbufs)) &#123; if (EINVAL == errno)&#123; fprintf(stderr, "%s does not support memory mapping\n", device); exit(EXIT_FAILURE); &#125; else&#123; errno_exit("VIDIOC_REQBUFS"); &#125; &#125; if (reqbufs.count &lt; 2) &#123; fprintf(stderr, "Insufficient buffer memory on %s\n", device); exit(EXIT_FAILURE); &#125; buffers = (struct buffer *)calloc(reqbufs.count, sizeof(*buffers)); if (!buffers) &#123; fprintf(stderr, "Out of memory\n"); exit(EXIT_FAILURE); &#125; for (n_buffers = 0; n_buffers &lt; reqbufs.count; ++n_buffers) &#123; struct v4l2_buffer buf; CLEAR(buf); buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; buf.index = n_buffers; if (-1 == xioctl(Camera_fd, VIDIOC_QUERYBUF, &amp;buf)) errno_exit("VIDIOC_QUERYBUF"); buffers[n_buffers].length=buf.length; buffers[n_buffers].start = (unsigned char *)mmap(NULL,buf.length,PROT_READ | PROT_WRITE ,MAP_SHARED ,Camera_fd, buf.m.offset); if (MAP_FAILED == buffers[n_buffers].start) errno_exit("mmap"); &#125; PRINTK("init_mmap Success\n"); &#125; int V4L2_QT::init_device(unsigned int w, unsigned int h) &#123; struct v4l2_capability cap;//这个设备的功能，比如是否是视频输入设备 struct v4l2_format fmt;//帧的格式，比如宽度，高度等 struct v4l2_cropcap cropcap; //输入设备裁剪 struct v4l2_crop crop; //输入设备裁剪 if(xioctl(Camera_fd,VIDIOC_QUERYCAP,&amp;cap))//Check vedio input &#123; if(EINVAL==errno) &#123; fprintf(stderr,"%s is no V4l2 device \n",device); return(EXIT_FAILURE); &#125; else &#123; errno_exit("VIDIOC_QUERYCAP"); &#125; &#125; if(!(cap.capabilities&amp;V4L2_CAP_VIDEO_CAPTURE)) &#123; fprintf(stderr, "no video capture device\n"); exit(EXIT_FAILURE); &#125; cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if(-1==xioctl(Camera_fd,VIDIOC_CROPCAP,&amp;cropcap)) errno_exit("VIDIOC_CROPCA"); crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; crop.c = cropcap.defrect; if (-1 == xioctl(Camera_fd, VIDIOC_S_CROP, &amp;crop)) &#123; switch (errno) &#123; case EINVAL: break; default: break; &#125; &#125; CLEAR(fmt);//清除帧的格式 //重新设置帧的格式 fmt.type=V4L2_BUF_TYPE_VIDEO_CAPTURE;// 数据流类型，必须永远是//V4L2_BUF_TYPE_VIDEO_CAPTURE fmt.fmt.pix.width=w; fmt.fmt.pix.pixelformat = pixel_format; fmt.fmt.pix.field = V4L2_FIELD_ANY; if (-1 == xioctl(Camera_fd, VIDIOC_S_FMT, &amp;fmt))//把刚才的帧格式写入 errno_exit("VIDIOC_S_FMT"); if ((fmt.fmt.pix.width != w) || (fmt.fmt.pix.height != h))//判断是否写入 &#123; qWarning(" Frame size: %ux%u (requested size %ux%u is not supported by device)\n", fmt.fmt.pix.width, fmt.fmt.pix.height, w, h); w = fmt.fmt.pix.width; h = fmt.fmt.pix.height; &#125; else &#123; qWarning(" Frame size: %dx%d\n", w, h); &#125; PRINTK("init_device Success\n"); //配置完成之后，接下来进行内存分配init_mmap(); &#125; void V4L2_QT::readCamera() &#123;if(opendevice(device))&#123; init_device(pre_w,pre_h); stream_on(); &#125; else&#123; opendevice(device_2); init_device(pre_w,pre_h); stream_on(); &#125;PRINTK("readCamera Success\n"); &#125; void V4L2_QT::process_image(unsigned char *buf, int size) &#123; qDebug()&lt;&lt;size&lt;&lt;endl; PRINTK("process_image get in"); //showPicData(buf, size); convertMJPEG2Mat(buf); PRINTK("yuv--&gt;rgb Success out \n"); //convertMJPEG2Mat(buf); &#125; void V4L2_QT::stream_on() &#123; unsigned int i; enum v4l2_buf_type type; struct v4l2_buffer buf;//代表驱动中的一帧 for(i=0;i&lt;n_buffers;++i) &#123; CLEAR(buf); buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; buf.index=i; if (-1 == xioctl(Camera_fd, VIDIOC_QBUF, &amp;buf)) errno_exit("VIDIOC_QBUF"); &#125; type = V4L2_BUF_TYPE_VIDEO_CAPTURE; if (-1 == xioctl(Camera_fd, VIDIOC_STREAMON, &amp;type)) errno_exit("VIDIOC_STREAMON"); PRINTK("stream_on Success\n"); &#125; void V4L2_QT::post_preview() &#123; struct v4l2_buffer buf; CLEAR(buf); buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; buf.memory = V4L2_MEMORY_MMAP; if (-1 == xioctl(Camera_fd, VIDIOC_DQBUF, &amp;buf)) errno_exit("VIDIOC_DQBUF"); assert(buf.index &lt; n_buffers); PRINTK("post_preview---&gt;process_images\n"); process_image(buffers[buf.index].start, buf.bytesused); PRINTK("process_image Sucess\n"); v4l2_buffer queue_buf; CLEAR(queue_buf); queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE; queue_buf.memory = V4L2_MEMORY_MMAP; queue_buf.index =buf.index; if (-1 == xioctl(Camera_fd, VIDIOC_QBUF, &amp;queue_buf)) errno_exit("VIDIOC_QBUF"); PRINTK("number=%d\n",number++); &#125; void V4L2_QT::releaseCamera() &#123; unsigned int i; for (i = 0; i &lt; n_buffers; ++i) &#123; munmap(buffers[i].start, buffers[i].length); &#125; free(buffers); if (-1 == ::close(Camera_fd)) errno_exit("close"); Camera_fd = -1; timer-&gt;stop(); &#125; int V4L2_QT::convert_yuv_to_rgb_pixel(int y, int u, int v) // &#123; unsigned int pixel32 = 0; unsigned char *pixel = (unsigned char *)&amp;pixel32; int r, g, b; r = y + (1.370705 * (v-128)); g = y - (0.698001 * (v-128)) - (0.337633 * (u-128)); b = y + (1.732446 * (u-128)); if(r &gt; 255) r = 255; if(g &gt; 255) g = 255; if(b &gt; 255) b = 255; if(r &lt; 0) r = 0; if(g &lt; 0) g = 0; if(b &lt; 0) b = 0; pixel[0] = r * 220 / 256; pixel[1] = g * 220 / 256; pixel[2] = b * 220 / 256; return pixel32; &#125; //yuv422×ªRGB24 int V4L2_QT::convert_yuv_to_rgb_buffer(unsigned char *yuv, unsigned char *rgb, unsigned int width, unsigned int height) //Êý×é ÏñËØÑÕÉ«×ª»»yuv ×ª»»rgb &#123;unsigned int in; unsigned int out = 0; unsigned int pixel_16=0; unsigned char pixel_24[3]; unsigned int pixel32; int y0, u, y1, v; for(in = 0; in &lt; width * height * 2; in += 4) &#123; pixel_16 = yuv[in + 3] &lt;&lt; 24 | yuv[in + 2] &lt;&lt; 16 | yuv[in + 1] &lt;&lt; 8 | yuv[in + 0]; y0 = (pixel_16 &amp; 0x000000ff); u = (pixel_16 &amp; 0x0000ff00) &gt;&gt; 8; y1 = (pixel_16 &amp; 0x00ff0000) &gt;&gt; 16; v = (pixel_16 &amp; 0xff000000) &gt;&gt; 24; pixel32 = convert_yuv_to_rgb_pixel(y0, u, v);//YUV UV·ÖÁ¿×÷ÓÃ²»Ã÷ÏÔ ŒõÐ¡UV·ÖÁ¿ ÔÚŒÆËãRGBµÄÊ±ºòÓÃÁÙœüµÄŽúÌæ pixel_24[0] = (pixel32 &amp; 0x000000ff); pixel_24[1] = (pixel32 &amp; 0x0000ff00) &gt;&gt; 8; pixel_24[2] = (pixel32 &amp; 0x00ff0000) &gt;&gt; 16; rgb[out++] = pixel_24[0]; rgb[out++] = pixel_24[1]; rgb[out++] = pixel_24[2]; pixel32 = convert_yuv_to_rgb_pixel(y1, u, v);//YUV UV·ÖÁ¿×÷ÓÃ²»Ã÷ÏÔ ŒõÐ¡UV·ÖÁ¿ ÔÚŒÆËãRGBµÄÊ±ºòÓÃÁÙœüµÄŽúÌæ pixel_24[0] = (pixel32 &amp; 0x000000ff); pixel_24[1] = (pixel32 &amp; 0x0000ff00) &gt;&gt; 8; pixel_24[2] = (pixel32 &amp; 0x00ff0000) &gt;&gt; 16; rgb[out++] = pixel_24[0]; rgb[out++] = pixel_24[1]; rgb[out++] = pixel_24[2]; &#125; return 0; &#125; void V4L2_QT::convertMJPEG2Mat(unsigned char*mjpeg) &#123; convert_yuv_to_rgb_buffer(mjpeg,rgb,WIDTH,HEIGHT); pixmap = QPixmap::fromImage(*frame); ui-&gt;label-&gt;setPixmap(pixmap);PRINTK("yuv--&gt;rgb Success\n"); //sprintf(ImageName,"ImageName%04ld.jpg",ImageNum++); //imwrite(ImageName,RGBImage); &#125; V4L2_QT.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106ifndef V4L2_QT_Hdefine V4L2_QT_Hinclude &lt;QMainWindow&gt;include &lt;QDebug&gt;include &lt;QLabel&gt;include&lt;QWidget&gt;include&lt;QPixmap&gt;include&lt;QLabel&gt;include&lt;QPainter&gt;include&lt;QTimer&gt;include &lt;QWidget&gt;include &lt;opencv2/highgui/highgui.hpp&gt;include &lt;opencv2/core/core.hpp&gt;include &lt;qtimer.h&gt;include &lt;opencv2/highgui/highgui_c.h&gt; //Kernel Header fileinclude &lt;stdio.h&gt;include &lt;stdlib.h&gt;include &lt;linux/fs.h&gt;include &lt;linux/stat.h&gt;include &lt;linux/types.h&gt;include &lt;linux/videodev2.h&gt;include &lt;fcntl.h&gt;include &lt;errno.h&gt;include &lt;sys/time.h&gt;include &lt;sys/mman.h&gt; //memoryinclude &lt;sys/ioctl.h&gt;include &lt;sys/stat.h&gt;include &lt;sys/types.h&gt;include &lt;assert.h&gt; //invok the assert() function namespace Ui &#123; class V4L2_QT; &#125; class V4L2_QT : public QMainWindow Q_OBJECT public slots: void post_preview(); public: explicit V4L2_QT(QWidget *parent = 0); ~V4L2_QT(); unsigned char rgb[WIDTH*HEIGHT*3]; private: Ui::V4L2_QT *ui; struct buffer &#123; unsigned char *start; size_t length; &#125;; QTimer *timer; QImage *frame; QPixmap pixmap; struct buffer *buffers; unsigned int n_buffers ; int number; char *device; char *device_2; int Camera_fd; int index; unsigned int pre_w;//预览窗口w unsigned int pre_h;//预览窗口h int pixel_format; int xioctl(int fd, int request, void *arg); void errno_exit(const char *s); void init_mmap(); int opendevice(char*device); int init_device(unsigned int w, unsigned int h); void readCamera(); void stream_on(); void releaseCamera(); void process_image(unsigned char *buf,int size); int convert_yuv_to_rgb_pixel(int y, int u, int v); int convert_yuv_to_rgb_buffer(unsigned char *yuv, unsigned char *rgb, unsigned int width, unsigned int height); void convertMJPEG2Mat(unsigned char*mjpeg);]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>V4L2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH基本原理及使用]]></title>
    <url>%2F2019%2F03%2F30%2F2019-3-30_SSH%2F</url>
    <content type="text"><![CDATA[SSH（Secure shell）是一种安全远程登录的协议，ssh与telnet、ftp等的区别就是安全性， SSH采用非对称加密保证数据安全性。ssh有商用的，开源的，这里使用的是OpenSSH，开源软件。 环境 虚拟机：VMware 本地系统：Red Hat Enterprise Linux Server release 7.6 (Maipo) 云服务器：CentOS Linux release 7.2.1511(阿里云) 概念加密方式SSH是一种网络传输协议，在传输之前，需要建立一个安全的传输通道，这个过程就会使用到对称加密算法和非对称加密算法，下面将对这两种算法进行分析。 对称加密算法对称加密顾名思义就是加加密过程和解密过程使用同一个秘钥，任何拥有该秘钥的人可以加密和解密数据，对称加密的加密强度高，几乎很难破解，但是在使用过程中会面临如何保存秘钥的问题，基本上一个服务器会有很多客户端进行登录，如果有一个人泄露，那么数据也会被泄露，非对称加密就出现了。 非对称加密算法非对称加密是需要公钥和私钥配合工作，也就是公钥加密，私钥解密。常见的非对称加密算法有rsa和dsa。非对称加密流程如下： 初次远程Server收到Client的登录请求之后，Server发送公钥到Client。 Client收到公钥之后，验证其公钥是否为Server公钥。 继续，Client会将密码通过公钥加密，然后发送到Server Server使用私钥解密后，验证密码的合法性，然后告知Client是否登录成功。 公钥是公开的，我们可以使用公钥加密私钥解密，也可以公钥解密私钥加密，会发现这两个过程很相似。你私钥加密后发出数据，所有知道公钥的人都可以解密，并且公钥是公开的，所以这个过程是有风险的，这也就出现数字签名。 RSA数字签名数字签名主要是为了证明传输数据的真实性和完整性，通过这个数字签名的验证，可以保障数据真是完整。其实就是对一份数据打个标记，证明发送方本人发送出去的数据，而且数据完整真实。非对称加密算法中，如果私钥加密，公钥解密，就不能保证数据真实完整，这就需要用到数字签名，具体过程如下： 假设A拥有私钥，B有公钥，A要给B发送信息。 A发送信息使用到数字签名，A把要发送的数据使用Hash函数生成摘要，然后使用私钥将这个摘要生成数字签名。 A将数据和数字签名一起发送给B。 B收到数据之后，将数字签名取下，通过公钥解密得到摘要。B将数据通过Hash函数得到摘要，B对比这两个摘要就可以知道数据是否完整真实。 参考网址阮一峰 配置文件ssh分为客户端和服务器端，Redhat操作系统默认安装客户端和服务器端。具体的配置文件在/etc/ssh下面，ssh_config是对客户端功能配置，sshd_config是服务器端功能配置 。在这两个配置文件里面加#表示默认配置。 客户端配置文件1234567891011121314151617181920212223242526272829303132333435# Host * #表示对能匹配字符串的计算机有效，*代表所有计算机。# ForwardAgent no #连接是否经过验证代理# ForwardX11 no #设置X11连接是否被自动重定向到安全的通道和显示集# RhostsRSAAuthentication no #设置是否使用RSA算法的rhosts的安全验证# RSAAuthentication yes # 设置是否使用RSA算法安全验证# PasswordAuthentication yes #设置是否使用口令验证# HostbasedAuthentication no ## GSSAPIAuthentication no# GSSAPIDelegateCredentials no# GSSAPIKeyExchange no# GSSAPITrustDNS no# BatchMode no #批处理模式 ，交互时输入口令提示将被禁止# CheckHostIP yes #设置ssh是否查看连接到服务器的主机的IP地址，防止DNS欺骗# AddressFamily any# ConnectTimeout 0 # StrictHostKeyChecking ask #询问计算机是否将服务器# IdentityFile ~/.ssh/identity# IdentityFile ~/.ssh/id_rsa# IdentityFile ~/.ssh/id_dsa# IdentityFile ~/.ssh/id_ecdsa# IdentityFile ~/.ssh/id_ed25519# Port 22 #连接服务器的端口号，# Protocol 2# Cipher 3des #设置加密密码# Ciphers aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,3des-cbc# MACs hmac-md5,hmac-sha1,umac-64@openssh.com,hmac-ripemd160# EscapeChar ~ #设置escape字符# Tunnel no # TunnelDevice any:any# PermitLocalCommand no# VisualHostKey no# ProxyCommand ssh -q -W %h:%p gateway.example.com# RekeyLimit 1G 1h# 服务器配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#Port 22 #服务器监听端口号，默认22#AddressFamily any#ListenAddress 0.0.0.0 #服务器监听的IP，默认为所有IP#ListenAddress ::#Protocol 2 #SSH使用的是SSH2协议HostKey /etc/ssh/ssh_host_rsa_key #设置服务器秘钥路径#HostKey /etc/ssh/ssh_host_dsa_keyHostKey /etc/ssh/ssh_host_ecdsa_keyHostKey /etc/ssh/ssh_host_ed25519_key#RekeyLimit default none#SyslogFacility AUTHSyslogFacility AUTHPRIV #LogLevel INFO #SSHD日志消息级别# Authentication: #限制用户必须在指定的时限内认证成功，0 表示无限制。默认值是 120 秒。#LoginGraceTime 2m #用来设定如果用户登录失败，在切断连接前服务器需要等待的时间，单位为妙#PermitRootLogin no #是否允许root远程登录，默认不允许，#StrictModes yes #StrictModes用来设置ssh在接收登录请求之前是否检查用户根目录和rhosts文件的权限和所有权#MaxAuthTries 6 #设置最大失败尝试登录次数#MaxSessions 10 #设置ssh最大联机个数，就是登录ssh，没有输入密码时。已经登录的不计算在内。#PubkeyAuthentication yes #用来设置是否开启公钥验证，如果使用公钥验证的方式登录时，则设置为yesAuthorizedKeysFile .ssh/authorized_keys #设置公钥验证文件地址#AuthorizedPrincipalsFile none#AuthorizedKeysCommand none#AuthorizedKeysCommandUser nobody#HostbasedAuthentication no #IgnoreUserKnownHosts no# Don&apos;t read the user&apos;s ~/.rhosts and ~/.shosts files#IgnoreRhosts yes #验证的时候是否使用这两个文件# To disable tunneled clear text passwords, change to no here!#PasswordAuthentication yes #用来设置是否开启密码验证机制，如果用密码登录系统，则设置yes#PermitEmptyPasswords no #是否密码为空的用户可以登录# Change to no to disable s/key passwordsChallengeResponseAuthentication no #是否允许质疑-应答(challenge-response)认证# Kerberos options#KerberosAuthentication no#KerberosOrLocalPasswd yes#KerberosTicketCleanup yes#KerberosGetAFSToken no#KerberosUseKuserok yes# GSSAPI optionsGSSAPIAuthentication yesGSSAPICleanupCredentials no#GSSAPIStrictAcceptorCheck yes#GSSAPIKeyExchange no#GSSAPIEnablek5users noUsePAM yes #设置是否通过PAM验证#AllowAgentForwarding yes#AllowTcpForwarding yes #置是否允许允许tcp端口转发，保护其他的tcp连接#GatewayPorts no #设置是否允许远程客户端使用本地主机的端口转发功能，出于安全考虑，建议禁止X11Forwarding yes #用来设置是否允许X11转发#X11DisplayOffset 10 #指定X11 转发的第一个可用的显示区(display)数字。默认值是 10#X11UseLocalhost yes#PermitTTY yes#PrintMotd yes #用来设置sshd是否在用户登录时显示“/etc/motd”中的信息，可以选在在“/etc/motd”中加入警告的信息#PrintLastLog yes #是否显示上次登录信息#TCPKeepAlive yes #是否持续连接，设置yes可以防止死连接#UseLogin no #设置是否在交互式会话的登录过程中使用。默认值是&quot;no&quot;#UsePrivilegeSeparation sandbox #设置使用者的权限#PermitUserEnvironment no#Compression delayed#ClientAliveInterval 0#ClientAliveCountMax 3#ShowPatchLevel no#UseDNS yes #是否使用dns反向解析，验证IP#PidFile /var/run/sshd.pid#MaxStartups 10:30:100#PermitTunnel no#ChrootDirectory none#VersionAddendum none# no default banner path#Banner none# Accept locale-related environment variablesAcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGESAcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENTAcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGEAcceptEnv XMODIFIERS# override default of no subsystemsSubsystem sftp /usr/libexec/openssh/sftp-server 客户端登录服务器ssh的安装时，如果需要连接远程服务器，那需要安装Client，如果我们需要本机作为服务器，那么需要安装Server。安装完成之后使用如下命令就可以登录远程服务器： 1ssh user@IP -p 22 (默认情况下，客户端的ssh_config中端口号，要和我们远程服务器监听的端口号一致，也就是ssh_config里面监听的端口号一致) 口令验证初次登录，客户端发送请求之后，服务器端会将公钥发送到客户端，为了防止中间人攻击，可以将接受到的公钥和服务器的公钥对比，一致则是安全的，继续下一步，输入密码，认证成功就可以。这是客户端接受到的公钥会将其通过MD5之后放在~/.ssh/hnown_hosts文件里面，下次登录不用进行公钥验证。 密钥验证上面步骤可知，通过输入密码进行登录安全性较低，容易受到中间人攻击。密钥登录也称为免密登录。上面口令验证时候，客户端已经获得服务器的公钥，现在我们客户端也生成一组密匙，将客户端的公钥放到服务器的~/.ssh/authorized_keys ，这样就可以实现免密登录。具体过程如下： 服务器收到客户端发送的用户名和IP之后，在authorized_keys 需要匹配的公钥，如果匹配就随机生成一个字符串然后通过authorized_keys 里面的公钥加密，发送给客户端。 客户端收到密文之后使用自己的私钥解密，然后将解密的数据使用服务器的公钥加密，发送给服务器。 服务器将接收到的字符串解密然后和之前对比，如果相同，则认证成功。 方式一（手动） 客户端生成密钥对，命令如下： 1ssh-keygen -t rsa 一路默认执行就可以，然后会在该用户的家目录下生成一个.ssh目录，将里面的id_rsa.pub内容，拷贝到服务器用户家目录~/.ssh/authorized_keys 里面，若不存在，手动创建就可以。(一般root是会禁止直接登录ssh，普通用户又没有authorized_keys(authorized_keys所属用户和组为root)权限，需要sudo，借用root权限) 完成 方拾二（使用命令） 执行命令： 1ssh-keygen -t rsa 家目录会有~/.ssh,会有（id_rsa）私钥和（id_rsa.pub）公钥文件， 使用命令将公钥Copy到服务器 1ssh-copy-id 用户名@iP -p 端口号 注意：由于普通用户没有authorized_keys权限，root禁登录SSH，有可能写入不进去，可以使用密码登录上去，更改其权限，写入完成之后再禁用。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>Digital Signature</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[独立冗余磁盘阵列（RAID）]]></title>
    <url>%2F2019%2F03%2F09%2F2019-3-9_RAID_Description%2F</url>
    <content type="text"><![CDATA[独立冗余磁盘阵列，简称RAID，是通过多个磁盘相互组合提高对硬盘设备IO读取速度和数据安全性的一种技术，目前已有的磁盘阵列方案比较多，标准的RAID有：RAID0、RAID1、RAID2、RAID3、RAID4、RAID5、RAID6。本文主要讲解及在VM虚拟机下使用相关命令配置RAID0、RAID1、RAID5、6、10。 环境 系统：RHEL7.6 虚拟机：VM RAID介绍RAID0RAID0是通过硬件或者是软件的方式将其连接在一起，至少需要两块硬盘，数据分段之后依次写入各个物理硬盘上面。RAID的存储速度最快，但是没有备份，空间利用率达到100%，但是硬盘损坏之后，数据无法修复。零容错。 RAID1RAID0是对数据分开存放的，任何一个硬盘发生故障，那么整个数据都将不可用。RAID1则提高数据安全性，将数据同时存入多个硬盘当中，相当于镜像存储，磁盘阵列无论挂载多少个硬盘，都相当于容量最小的硬盘，写入速度相对于RAID0慢，但是数据安全性大大提高，但是这种读取速度是一个硬盘读取速度乘于硬盘个数。 RAID5RAID1虽然安全性大大提高，但是硬盘空间利用率大大降低。RAID5兼顾RAID0和RAID1的优点提出来的一种技术方案。RAID5与RAID3和RAID4不同的是RAID4是使用固定盘来存储奇偶校验位，而RAID5是将数据和数据对应的校验位在分散存储在各个硬盘上面。RAID5的数据和RAID0数据分布相似，都是把数据以块为单位分布到各个评判上面。上面这两个RAID5技术方案特点，使得RAID至少需要3块磁盘。RAID5没有备份数据，只保存数据的校验位，在硬盘损坏之后通过奇偶校验位进行数据恢复。RAID5受到系统故障之后，重建时间比较长。 RAID6RAID5可以知道，如果某一个盘故障之后，可以通过其他盘的校验位和其余的数据记性数据恢复，但是如果同时有两个盘故障的话，则不能完全进行数据恢复（假如上图的Disk1和Disk2同时损坏，A的数据可以通过A1和ParityA恢复，D的数据可以通过D3和ParityD恢复，而B,C的数据由于校验位数据丢失不能恢复）。所以这是出现RAID6，RAID6是在RAID5增加一个安全等级，就是RIAD6在RAID5的基础上，在其他盘又增加XOR校验区，这两个XOR校验使用不同的算法，这个阵列需要至少4块硬盘。这样磁盘阵列允许同时两个硬盘故障，容错功能提高。但是在写入数据的时候需要计算两个XOR区，速度大大降低，空间利用率也降低。 RAID10由于RAID磁盘阵列的读写速度和数据安全性是相互制约，RAID10通过将RAID0和RAID1进行组合，他利用RAID0的快速读写和RAID1的安全性。性能超过RAID6和RAID5.只要同一组的硬盘不全部损坏，那么数据就不会丢失。RAID10至少需要4块硬盘。如图 ： 热备磁盘针对磁盘阵列，不同的方案容错成都也不一样，一般都会有热备磁盘，也就是在磁盘阵列中某个磁盘挂了，热备磁盘可以立刻代替损坏磁盘的位置，这时候，我们的磁盘阵列就会重建，一个磁盘阵列可以包含多个热备磁盘。 mdadm命令mdadm命令是Linux下创建和管理磁盘阵列的命令，具体参数如下： 参数 作用 -a 检测设备名称 -n 指定设备数量 -l 设定RAID级别 -C 创建磁盘阵列名称 -v 显示创建过程 -f 模拟设备损坏 -r 移除设备 -Q 查看摘要信息 -D 查看详细信息 -S 停止磁盘阵列 虚拟磁盘部署磁盘阵列实验RAID0 步骤一（添加磁盘） 在虚拟机系统关机状态下，添加两个SCSI磁盘。（虚拟机-&gt;设置-&gt;添加-&gt;硬盘-&gt;SCSI-&gt;创建新虚拟磁盘-&gt;容量20G，完成），按照这个步骤添加两个硬盘。 步骤二（查看磁盘） 虚拟机下开机（打开系统），进入终端（桌面版），使用lsblk或者“fdisk -l”命令，可以看到我们添加的两个硬盘，如图： 步骤三（分区） 分区，上面步骤已经添加两个磁盘，下面使用fdisk对磁盘进行分区。1. “fdisk /dev/sdb” （关于fdisk分区自行根据提示进行就可以，这里我们只分一个主分区，默认编号是1，大小是上限值就即可，设置完成之后，切记分区表同步到磁盘（w write table to disk and exit））。重复操作对/dev/sdc进行分区 。（不对磁盘分区，应该也可以直接构建磁盘阵列也就是不需要第三步骤也可以） 步骤四（创建磁盘阵列） 使用mdadm命令创建磁盘阵列， 1mdadm -C /dev/md0 -a yes -l0 -n2 /dev/sdb1 /dev/sdc1 参数说明： -C 创建阵列 ； -a yes 自动创建设备文件； -l +数字 是阵列模式-l0就是说RAD0；-n2 是指连个磁盘创建磁盘阵列； 步骤五（格式化） 格式化磁盘阵列 “mkfs.xfs /dev/md0”; 这个mkfs格式工具很强大，mkfs.ext3、mkfs.ext4.都比较方便。 步骤六（查看磁盘阵列信息） 查看我们创建的磁盘阵列：终端命令“cat /proc/mdstat”或者使用“mdadm -D /dev/md0”详细查看RAID0 配置，如图： 步骤七（挂载） 使用mount挂在磁盘阵列只能在本次开机有效，要想开机自动挂载可以将磁盘阵列信息写入到/etc/fstab。这里只使用mount挂载。“sudo mkdir /RAID/raid0” ; “mount /dev/md0 /RAID/raid0”。到此为止我们就可以正常使用磁盘阵列。 步骤八（读取写入速度测试） 写入测试 先给磁盘阵列写入，使用dd和time命令，dd有复制功能，time可以计时,写入1GB。 1time dd if=/dev/zero of=/RAID/raid0/iointest bs=8k count=131072 在直接写入本地: 1sudo time dd if=/dev/zero of=/home/funful/iointest bs=8k count=131072 如图可以看出来，虽然是虚拟磁盘模拟出来的，但是写入速度与时间还是有差距的(忽略数值，电脑配置比较低)。 读取测试 先读取磁盘阵列数据，命令如下： 1sudo time dd if=/RAID/raid0/iointest of=/dev/null bs=8k count=131072 再测试读取本地数据，命令如下： 1sudo time dd if=/home/funful/iointest of=/dev/null bs=8k count=131072 由于各个磁盘阵列的方案实施过程相似，所以就不一一进行实验，下面只对RAID10进行创建 RADI10 步骤一（添加磁盘） 和RAID0的过程相似，在虚拟机系统关机状态下添加5个虚拟磁盘（每个20GB）,4个数据盘，一个热备份盘。如图： 步骤二（创建磁盘阵列+备份盘 ） 使用命令创建磁盘阵列： 1sudo mdadm -C /dev/md0 -n 4 -l 10 -x 1 /dev/sdb /dev/sdc /dev/sdd /dev/sde /dev/sdf 使用命令查看磁盘阵列信息：“mdadm -D /dev/md0” 如图： 从上图可以看出来，总共有5个磁盘，四个活动磁盘，一个备份磁盘。/dev/sdf作为备份盘。 步骤三（格式化磁盘阵列） 1mkfs.xfs /dev/md0 步骤四（主动破坏某个数据盘） 使用mdadm的-f命令主动从磁盘阵列移除一个磁盘，命令 1mdadm /dev/md0 -f /dev/sdb 可以从图中可以看到，/dev/sdb已经挂了，而之前的备份盘正在顶替sdb的位置，而且正在rebuilding，所以此时活动盘只有3个。过一会再使用这个命令可以看到，rebuilding完毕之后，顶替之前位置。 步骤五（添加热备磁盘） 下面我们将模拟损坏的磁盘，作为热备磁盘加进磁盘阵列，命令如下： 1234#移除损坏磁盘sudo mdadm /dev/md0 -r /dev/sdb #添加备份磁盘 sudo mdadm /dev/md0 -a /dev/sdb 从上图可以看到我们刚才模拟损坏的sdb盘，已经作为热备份盘，添加到磁盘阵列当中。 结语由于是使用虚拟磁盘来创建磁盘阵列，所以性能对比差距不是那么明显。但是我们可以通过软件的方式使用命令来管理磁盘阵列。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RAID</tag>
        <tag>独立冗余磁盘阵列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 文件IO]]></title>
    <url>%2F2019%2F01%2F15%2FLinux%E7%9A%84%E6%96%87%E4%BB%B6IO%2F</url>
    <content type="text"><![CDATA[本文介绍了文件IO的操作！ 代码例程： 例程 参考：《UNIX环境高级编程》 介绍 根据UNIX的体系结构，从内到外依次是内核、系统调用、shell、库函数、和应用程序。内核的接口成为系统调用。程序运行内存空间可以分为用户空间和内核空间。应用程序工作在用户空间、如果应用程序想要访问内核空间的话，可以使用系统调用安全的访问内核空间。 Linux提供了一系列系统调用函数，常用的有open、write、read、lseek、和close。本文介绍的文件IO也称为不带缓冲的IO。 文件描述符在Linux中一切皆文件，所以打开的文件都会返回一个文件描述符引用。文件描述符是一个非负整数。在POSIX应用程序中，0 1 2被替换成了符号常数 0 STDERR_FILENO(标准错误输出 1 TDIN_FILENO(标准输入) 2 STDERR_FILENO(标准错误输出) 文件IO基本操作open函数1234头文件#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;int open(const char *path, int oflags, mode_t mode); open函数用来打开或创建文件。 path 是打开文件的名字，oflags 打开文件所要采取的动作，mode 文件访问的格式 12345678oflags:(可位与) O_RDONLY 只读方式打开文件 O_WRONLY 只写方式打开文件 O_RDWR 以读写方式打开文件 O_APPEND 把写入数据追加到文件末尾 O_TRUNC 把文件长度设置为0，丢弃已有内容 O_CREAT 如需要就按参数mode给出的访问模式创建文件 O_EXCL 与O_CREAT一起使用，确保调用者创建出文件。open调用是一个原子操作，它只执行一个函 数调用。使用这个可选模式可以防止两个程序同时创建一同一个文件。如果文件已经存在，open调用失败 mode 是访问权限 返回值的文件描述符取值 0打开或创建成功-1失败 write函数12#include &lt;unistd.h&gt;size_t write(int fd, const void *buf, size_t nbytes); 打开文件成功之后，可以往文件里写数据 fd 文件描述符，buf写入数据在内存空间的起始地址，写入字节数 返回值的文件描述符取值 非负整数写入成功，返回写入字节数-1失败 read函数12#include &lt;unistd.h&gt;size_t read(int fd, void *buf, size_t nbytes); 打开文件成功之后，可以从文件里读数据 fd 文件描述符，buf读数据在内存空间的起始地址，读出最大字节数 返回值的文件描述符取值 非负整数读成功，返回读出字节数-1失败 lseek函数123#include &lt;unistd.h&gt;#include &lt;sys/types.h&gt;off_t lseek(int fd, off_t offset, int whence); 每次打开或新建一个文件，偏移量就从文件开始处，在同一次的打开操作之后，读写就会对其偏移量增加 fd 是文件描述符， offset 是偏移量，whence是模式 1234whence 取值： SEEK_SET 绝对位置 SEEK_CUR 当前位置 SEEK_END 文件尾 stat函数123#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;int stat(const char *file_name, struct stat *buf); 这个函数是通过文件名，得到存储文件信息的结构体buf 成功返回0 ，失败返回-1 123456789101112131415struct stat &#123; dev_t st_dev; //文件的设备编号 ino_t st_ino; //节点 mode_t st_mode; //文件的类型和存取的权限 nlink_t st_nlink; //连到该文件的硬连接数目，刚建立的文件值为1 uid_t st_uid; //用户ID gid_t st_gid; //组ID dev_t st_rdev; //(设备类型)若此文件为设备文件，则为其设备编号 off_t st_size; //文件字节数(文件大小) unsigned long st_blksize; //块大小(文件系统的I/O 缓冲区大小) unsigned long st_blocks; //块数 time_t st_atime; //最后一次访问时间 time_t st_mtime; //最后一次修改时间 time_t st_ctime; //最后一次改变时间(指属性)&#125;; close函数12#include &lt;unistd.h&gt;int close(int fd); 操作完一个函数之后应该，显式的关闭一打开文件 例子 新建文本1，写入一段话 1234567891011121314151617181920212223242526272829303132333435363738394041 Traveling LightI was doubling over the load on my shoulderswas a weight I carried with me everydayCrossing miles of frustrations and rivers of ragingPicking up stones I found along the wayI staggered and I stumbled downpathway of trouble I washauling those souvernirs of miseryAnd with each step taken my back was breakingTill I found the One who took it all from meDown by the riverside(Down by the riverside)I laid my burdens down,Now I&apos;m traveling lightMy spirit lifted high(I found my freedom now)I found my freedom now,And I&apos;m traveling lightThrough the darkest alleys and loneliest valleysI was dragging those heavy chains of doubt and fearThen with the one word spoken the locks were brokenNow He&apos;s leading me to placesWhere there are no tearsDown by the riverside(Down by the riverside)I laid my burdens down,Now I&apos;m traveling lightMy spirit lifted high(I found my freedom now)I found my freedom nowAnd I&apos;m traveling lightDown by the riversideI laid my burdens downNow I&apos;m traveling lightMy spirit lifted highI found my freedom nowAnd I&apos;m traveling lightDown by the riverside(Down by the riverside)I laid my burdens down,Now I&apos;m traveling lightMy spirit lifted high(I found my freedom now)I found my freedom nowAnd I&apos;m traveling light 新建文本2 123歌曲名：Traveling Light歌手名：Joel Hanson专辑名：What If It Is 将文本1和文本2合并，并且生成文本3 代码：​ combine.c 使用了open 、write、 read、lseek、close、和stat 函数，对文件操作 ​]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回调函数及其应用场景分析]]></title>
    <url>%2F2018%2F12%2F02%2F2018-12-02-callback-function%2F</url>
    <content type="text"><![CDATA[日常开发中遇到过使用回调函数的场景，但是对其具体定义和实现方式一直没有清晰的认识，导致平时能不用就不用，这次做一个总结克服它。 一 回调函数的定义1.1 百度百科定义如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 1.2其他定义 回调函数是指使用者自己定义一个函数，实现这个函数的程序内容，然后把这个函数（入口地址）作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。函数是你实现的，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是由别人的函数运行期间通过函数指针来回调你实现的函数。 所谓回调，就是模块A要通过模块B的某个函数b()完成一定的功能，但是函数b()自己无法实现全部功能，需要反过头来调用模块A中的某个函数a()来完成，这个a()就是回调函数。 总结来说，回调函数这一设计允许了底层代码调用在高层定义的子程序。 二 回调函数简单实例2.1无参数的回调实例12345678910111213141516//定义带参回调函数void PrintfText(char* s) &#123; printf(s);&#125;//定义实现带参回调函数的&quot;调用函数&quot;void CallPrintfText(void (*callfuct)(char*),char* s)&#123; callfuct(s);&#125;//在main函数中实现带参的函数回调int main(int argc,char* argv[])&#123; CallPrintfText(PrintfText,&quot;Hello World!\n&quot;); return 0;&#125; 2.2将上述代码修改为带参函数12345678910111213141516//定义带参回调函数void PrintfText(char* s) &#123; printf(s);&#125;//定义实现带参回调函数的&quot;调用函数&quot;void CallPrintfText(void (*callfuct)(char*),char* s)&#123; callfuct(s);&#125;//在main函数中实现带参的函数回调int main(int argc,char* argv[])&#123; CallPrintfText(PrintfText,&quot;Hello World!\n&quot;); return 0;&#125; 以上两个实例对回调函数的定义有了清晰的说明，但是没有指明回调函数的真正用途：回调函数这一设计允许了底层代码调用在高层定义的子程序。这也是前文提到的，回调函数主要是为了让其他人已经实现的函数调用，而不是让自己实现的函数调用。第三章将给出回调函数的实用用途。 三 Qt5中引入的消息重定向机制使用的回调函数3.1使用场景一般在开发Qt程序时，主要由两种调试方式：一种是在debug模式下调试，另一种是在程序中使用qDebug()等函数打印信息帮助调试。一旦程序release投入实际使用，这些打印信息将无法被开发人员看到，qt5使用消息重定向机制使得打印信息可以重定向输出至log文件。这样即使软件在使用过程中发生问题也可以凭借日志文件追溯。 如下是Qt帮助文档对于注册回调函数的描述： 12345Installs a Qt message handler which has been defined previously. Returns a pointer to the previous message handler.The message handler is a function that prints out debug messages, warnings, critical and fatal error messages. The Qt library (debug mode) contains hundreds of warning messages that are printed when internal errors (usually invalid function arguments) occur. Qt built in release mode also contains such warnings unless QT_NO_WARNING_OUTPUT and/or QT_NO_DEBUG_OUTPUT have been set during compilation. If you implement your own message handler, you get total control of these messages.The default message handler prints the message to the standard output under X11 or to the debugger under Windows. If it is a fatal message, the application aborts immediately.Only one message handler can be defined, since this is usually done on an application-wide basis to control debug output.To restore the message handler, call qInstallMessageHandler(0). 3.2Qt回调代码实例如下代码是qt提供的例子： 123456789101112131415161718192021222324252627282930313233#include &lt;qapplication.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void myMessageOutput(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg)&#123; QByteArray localMsg = msg.toLocal8Bit(); switch (type) &#123; case QtDebugMsg: fprintf(stderr, &quot;Debug: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function); break; case QtInfoMsg: fprintf(stderr, &quot;Info: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function); break; case QtWarningMsg: fprintf(stderr, &quot;Warning: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function); break; case QtCriticalMsg: fprintf(stderr, &quot;Critical: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function); break; case QtFatalMsg: fprintf(stderr, &quot;Fatal: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function); abort(); &#125;&#125;int main(int argc, char **argv)&#123; qInstallMessageHandler(myMessageOutput); QApplication app(argc, argv); ... return app.exec();&#125; 如上代码，函数void myMessageOutput(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg)可以看做是我们自己实现的回调函数，qInstallMessageHandler(myMessageOutput)是Qt提供的注册回调函数。之后，一旦Qt提供的几种消息类型发生就会调用我们定义的回调函数。 以上代码稍做修改即可实现重定向消息输出至log文件，代码如下： 12345678910111213141516171819202122232425262728void myMessageOutput(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg)&#123; QByteArray localMsg = msg.toLocal8Bit(); switch (type) &#123; case QtDebugMsg: fprintf(stderr, &quot;Debug: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function); break; case QtInfoMsg: fprintf(stderr, &quot;Info: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function); break; case QtWarningMsg: fprintf(stderr, &quot;Warning: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function); break; case QtCriticalMsg: fprintf(stderr, &quot;Critical: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function); break; case QtFatalMsg: fprintf(stderr, &quot;Fatal: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function); break; &#125;&#125;int main(int argc, char *argv[])&#123; qInstallMessageHandler( myMessageOutput ); QCoreApplication a(argc, argv); ...&#125; 经过修改后的回调函数可以实现将打印信息及其所在的，文件，函数，代码行等输出至log文件。 这个例子可以帮助我们清晰的认识回调函数的具体应用场景。 四 标准回调函数定义方式 回调函数的定义及其实现方式并不复杂，如果不清楚其应用场景只是一味的看概念确实容易对其理解有偏差。本小结将给出关于回调函数及注册回调函数一些标准的定义。 4.1回调函数定义定义时最好符合如下函数原型：typedef void (*SCT_XXX)(LPVOID lp, const CBParamStruct&amp; cbNode); 其中SCT_XXX是回调函数名称，lp是回调上下文，CBParamStruct是回调参数，一般由于要回调的参数不止一个，所以定义一个结构体比较方便。 4.2注册回调函数注册回调函数原型：void RCF_XXX(SCT_XXX pfn, LPVOID lp); 其中，RCF_XXX是注册函数名，pfn是回调函数名称（是指针），lp是回调上下文。 后记CSDN论坛一个关于为什么要使用回调函数的帖子可能对深入理解回调函数有帮助，毕竟争论出真知。 参考： ioleon13的博客 百度百科回调函数词条 修订记录：2018.12.02 22:46 完成初稿]]></content>
      <categories>
        <category>C++</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++相关</tag>
        <tag>回调函数</tag>
        <tag>Qt输出日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指针小结]]></title>
    <url>%2F2018%2F11%2F30%2F2018-11-29-this-pointer%2F</url>
    <content type="text"><![CDATA[关于c++中this指针的小结 前言：在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象。 一 定义this是一个指向自身对象的特殊指针，它并不是对象本身的一部分，不会影响sizeof（对象）的结果。 二 应用场景 this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。 在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this； 当参数与成员变量名相同时使用this指针指向成员变量，例如this-&gt;n = n （不能写成n = n）。三 注意事项 友元函数没有this指针，因为友元不是类的成员。只有成员函数才有 this 指针。 this指针只能在一个类的成员函数中调用，它表示当前对象的地址。(全局函数，静态函数都不能使用this。) this在成员函数的开始前构造的，在成员的结束后清除。这个生命周期同任一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。 参考：百度百科C++this指针词条]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++相关</tag>
        <tag>this指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[return不同类型变量的区别]]></title>
    <url>%2F2018%2F11%2F30%2F2018-11-30-keyword-return%2F</url>
    <content type="text"><![CDATA[关于c/c++中return的总结（返回值类型），由return *this引起的思考。 近段时间突然想到return this这个东西，一时间糊涂了，总是在纠结return this返回的是对象的引用还是对象本身。后来悟过来这应该和返回值类型有关。从这个也查到了c/c++return不同类型是如何实现的，做一个小结以便回顾。 一 结论 直接抛结论，方便回顾。 主要讨论返回内部变量类型(包含指针)，返回内部变量类型的引用，返回结构体(类)，返回结构体(类)的引用这四种情况。 主要讨论返回局部变量的情况，也就是在栈内存的变量。 返回内部变量类型时，直接返回变量本身。但是中间有一个拷贝的过程，会将局部变量拷贝至一个寄存器，再将寄存器的值返回给赋值的变量。也就是常说的会有一个复制的过程。值得注意的是，返回一个指针变量也是一样的，但是请注意指向栈内存的指针在函数调用结束后是无效的，因为栈空间已经释放，可能被其他操作覆盖。 返回值类型是局部变量的引用时，返回的是局部变量的地址，根据这个地址读出变量的值。此处有一个问题，局部变量所在的栈内存在调用结束时被销毁，按理说不应该能够根据地址读出正确的变量值。但是实际测试发现，返回局部变量的引用依然可以得到正确的变量值。 返回一个类对象时和情况1是一样的，返回的是对象的一个拷贝（通常是一个被叫做匿名对象的东西）。这也是为什么不推荐直接返回类对象的原因，因为拷贝一个类需要花费更多的时间，而且还需要再次调用类的拷贝构造函数，因为这真的是一个拷贝过程。 返回一个类对象的引用和情况2是一样的，直接返回地址，也无需调用拷贝构造函数。此处返回的类对象应该是由参数传入的类对象引用而不应该是返回局部类对象的引用！！ 二 基础编码分析1.返回内部变量类型源码如下12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int func()&#123; int rst = 0; return rst;&#125;void* func2()&#123; void * p = NULL; return p;&#125;char&amp; fun3()&#123; char ch = 0; return ch;&#125;int main()&#123; int ret = func(); func2(); void* p = func2(); fun3(); char ch = fun3();&#125; 调试上述代码，查看相应的汇编码如下12345678910111213141516171819202122232425262728293031int main()&#123;00FA1880 push ebp 00FA1881 mov ebp,esp 00FA1883 sub esp,0E4h 00FA1889 push ebx 00FA188A push esi 00FA188B push edi 00FA188C lea edi,[ebp-0E4h] 00FA1892 mov ecx,39h 00FA1897 mov eax,0CCCCCCCCh 00FA189C rep stos dword ptr es:[edi] 00FA189E mov ecx,offset _A5C8350F_testreturn@cpp (0FAC003h) 00FA18A3 call @__CheckForDebuggerJustMyCode@4 (0FA1212h) int ret = func();00FA18A8 call func (0FA138Eh) 00FA18AD mov dword ptr [ret],eax func2();00FA18B0 call func2 (0FA1389h) void* p = func2();00FA18B5 call func2 (0FA1389h) 00FA18BA mov dword ptr [p],eax fun3();00FA18BD call fun3 (0FA1384h) char ch = fun3();00FA18C2 call fun3 (0FA1384h) 00FA18C7 mov al,byte ptr [eax] 00FA18C9 mov byte ptr [ch],al &#125; 首先看对与局部变量的返回是如何实现的，从上面的代码可以看到调用函数func后又从eax寄存器读出一个值付给了变量ret。也就是说eax保存了对于局部变量的返回。具体的实现可以进入函数func查看相应的汇编码如下：12345678910111213141516171819int func()&#123;00FA1810 push ebp 00FA1811 mov ebp,esp 00FA1813 sub esp,0CCh 00FA1819 push ebx 00FA181A push esi 00FA181B push edi 00FA181C lea edi,[ebp-0CCh] 00FA1822 mov ecx,33h 00FA1827 mov eax,0CCCCCCCCh 00FA182C rep stos dword ptr es:[edi] 00FA182E mov ecx,offset _A5C8350F_testreturn@cpp (0FAC003h) 00FA1833 call @__CheckForDebuggerJustMyCode@4 (0FA1212h) int rst = 0;00FA1838 mov dword ptr [rst],0 return rst;00FA183F mov eax,dword ptr [rst] &#125; 关键代码在return rst下面：00FA183F mov eax,dword ptr [rst]也就是return时把局部变量存储在了eax寄存器，返回调用函数后从该寄存器读出即为返回值。这也印证了上述的说法。 2.返回指针变量那对于指针变量的返回和普通变量类型有区别吗？继续查看上述的汇编代码：123void* p = func2();00FA18B5 call func2 (0FA1389h) 00FA18BA mov dword ptr [p],eax 这两句与int行变量的返回完全一致，进入func2函数继续查看,关键代码如下：1234 void * p = NULL;00FA17D8 mov dword ptr [p],0 return p;00FA17DF mov eax,dword ptr [p] 从这一点可以看出来返回指针变量与其他变量的方式是完全一样的，这也可以理解，毕竟指针也是内部变量类型之一。 3.返回局部变量的引用直接看调用fun3的汇编码：1234 char ch = fun3();00FA18C2 call fun3 (0FA1384h) 00FA18C7 mov al,byte ptr [eax] 00FA18C9 mov byte ptr [ch],al 直接的区别就是操作步骤增加了一步，之前从eax寄存器读出的就是返回值，而对于引用的返回确时[eax]也就是把eax寄存器保存的是值作为一个地址数据。至于这个地址是什么，需要进入fun3继续查看，关键代码如下：1234 char ch = 0;00FA1742 mov byte ptr [ch],0 return ch;00FA1746 lea eax,[ch] 最直接的变化就是00FA1746 lea eax,[ch] 没有将ch变量的值放入eax寄存器而是放入了ch的地址。这才有了上述函数调用结束后先去eax指向的地址读值再将该值赋予变量ch的两步过程。 总结起来就是直接返回变量时，返回的是变量值的一个拷贝。而返回变量的引用则是返回变量的地址，再根据这个地址读出变量的值。 三 更进一步–&gt;返回值为class/struct 1.简单描述返回值为类对象的过程。123456789101112class classname&#123;... ...&#125;classname fun()&#123; classname p; return p;&#125;int main()&#123; classname p; p = fun();&#125; 有如上示意代码，其大致过程：先在调用函数处创建匿名对象但不初始化2.将该匿名对象的this指针作为参数传入被调用函数fun3.在return时通过传入的指针调用匿名对象的拷贝构造函数4.结束时返回匿名对象的地址5.如果调用函数需要将返回的对象赋值给另一个类对象(示意中为p)，就会根据这个指针再进行一次复制（单纯的复制，不会调用其他函数）。所以上述代码调用了两次构造函数(两次classname p过程)和一次拷贝构造函数(在return p的时候将被调用函数的p作为匿名对象拷贝构造函数的参数)。 2.具体源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#pragma pack(1) struct Person&#123; int age; int id; int somethingelse; char name[12]; void display() &#123; printf("age :%X id:%X\n", age, id); printf("age:%X \n", &amp;age); printf("id:%X \n", &amp;id); printf("somethingelse:%X \n", &amp;somethingelse); printf("name:%X \n", name); &#125; Person() &#123; printf("Call Person()\n"); &#125; Person(const Person&amp;) &#123; printf("Call Person(const Person&amp;)\n"); &#125;&#125;;Person func1()&#123; Person p; return p;&#125;Person func2()&#123; Person* per = new Person(); return *per;&#125;Person&amp; func3()&#123; Person* p = new Person(); return *p;&#125;int main()&#123; Person p; func1().display(); p = func1(); p.display(); func2().display(); func3().display(); p = func3(); p.display(); return 0;&#125; 上述三个函数func1,func2func3分别分别代表返回局部内对象(栈内存)，返回动态对象(堆内存)，返回动态对象的引用。为了简洁，函数中没有进性delete操作。 3.返回局部对象的过程相应反汇编代码如下 123456789101112131415161718192021222324252627282930 Person p;01151E12 lea ecx,[p] 01151E15 call Person::Person (0115114Ah) func1().display();01151E1A lea eax,[ebp-100h] 01151E20 push eax 01151E21 call func1 (0115144Ch) 01151E26 add esp,4 01151E29 mov ecx,eax 01151E2B call Person::display (01151046h) p = func1();01151E30 lea eax,[ebp-120h] 01151E36 push eax 01151E37 call func1 (0115144Ch) 01151E3C add esp,4 01151E3F mov ecx,dword ptr [eax] 01151E41 mov dword ptr [p],ecx 01151E44 mov edx,dword ptr [eax+4] 01151E47 mov dword ptr [ebp-1Ch],edx 01151E4A mov ecx,dword ptr [eax+8] 01151E4D mov dword ptr [ebp-18h],ecx 01151E50 mov edx,dword ptr [eax+0Ch] 01151E53 mov dword ptr [ebp-14h],edx 01151E56 mov ecx,dword ptr [eax+10h] 01151E59 mov dword ptr [ebp-10h],ecx 01151E5C mov edx,dword ptr [eax+14h] 01151E5F mov dword ptr [ebp-0Ch],edx p.display();01151E62 lea ecx,[p] 01151E65 call Person::display (01151046h) 首先是Person p;直接调用相应的构造函数，过程比较清晰。重点看返回对象的函数func1().display();可以看到在调用函数func1之前有一个入栈的操作，调用函数之前入栈的都是需要传入函数的参数，但是函数func1并没有需要显示传入的参数，那么这个入栈的数据大概率是隐式传输的参数this指针，也就是前面提到的匿名对象的指针，但是该匿名对象的创建过程代码中并没有体现。 进入函数func1()相应的关键汇编码如下： 123456789 Person p;01151A92 lea ecx,[p] 01151A95 call Person::Person (0115114Ah) return p;01151A9A lea eax,[p] 01151A9D push eax 01151A9E mov ecx,dword ptr [ebp+8] 01151AA1 call Person::Person (01151375h) 01151AA6 mov eax,dword ptr [ebp+8] 其中语句01151A9E mov ecx,dword ptr [ebp+8] 将传入的参数放置ecx寄存器之后调用拷贝构造函数(一般来说，函数调用时ebp+4存放返回地址，ebp+8存放第一个传入的参数)。进入 Person::Person (01151375h)关键 源码如下： 1234567011518AC push ecx 011518AD lea edi,[ebp-0CCh] 011518B3 mov ecx,33h 011518B8 mov eax,0CCCCCCCCh 011518BD rep stos dword ptr es:[edi] 011518BF pop ecx 011518C0 mov dword ptr [this],ecx 上述代码很清除的表明ecx寄存器也就是上一步中传入的参数确实是当前构造函数的this指针，也就是匿名对象的地址。在拷贝构造函数完成之后，还有01151AA6 mov eax,dword ptr [ebp+8] 操作也就是将this指针放入eax寄存器。之后在函数调用处通过该指针调用返回的对象的成员函数display(); 至此返回类对象的过程完毕。 从p = func1()的汇编码中可以看到其差别主要是返回之后的一些复制操作，其余完全相同。 4.返回动态动态对象的过程相应的反汇编码如下： 1234567 func2().display();01151E6A lea eax,[ebp-140h] 01151E70 push eax 01151E71 call func2 (01151456h) 01151E76 add esp,4 01151E79 mov ecx,eax 01151E7B call Person::display (01151046h) 类比可知，该过程与返回局部类对象完全一致。 5.返回动态对象的引用返回动态对象的引用不同与上述过程，没有调用前函数入栈的操作。其反汇编码如下： 123456789101112131415161718192021 func3().display();01151E80 call func3 (01151451h) 01151E85 mov ecx,eax 01151E87 call Person::display (01151046h) p = func3();01151E8C call func3 (01151451h) 01151E91 mov ecx,dword ptr [eax] 01151E93 mov dword ptr [p],ecx 01151E96 mov edx,dword ptr [eax+4] 01151E99 mov dword ptr [ebp-1Ch],edx 01151E9C mov ecx,dword ptr [eax+8] 01151E9F mov dword ptr [ebp-18h],ecx 01151EA2 mov edx,dword ptr [eax+0Ch] 01151EA5 mov dword ptr [ebp-14h],edx 01151EA8 mov ecx,dword ptr [eax+10h] 01151EAB mov dword ptr [ebp-10h],ecx 01151EAE mov edx,dword ptr [eax+14h] 01151EB1 mov dword ptr [ebp-0Ch],edx p.display();01151EB4 lea ecx,[p] 01151EB7 call Person::display (01151046h) 进入fun3查看如下： 1234567891011121314151617181920 Person* p = new Person();01151C27 push 18h 01151C29 call operator new (01151352h) 01151C2E add esp,4 01151C31 mov dword ptr [ebp-0ECh],eax 01151C37 mov dword ptr [ebp-4],0 01151C3E cmp dword ptr [ebp-0ECh],0 01151C45 je func3+7Ah (01151C5Ah) 01151C47 mov ecx,dword ptr [ebp-0ECh] 01151C4D call Person::Person (0115114Ah) 01151C52 mov dword ptr [ebp-0F4h],eax 01151C58 jmp func3+84h (01151C64h) 01151C5A mov dword ptr [ebp-0F4h],0 01151C64 mov eax,dword ptr [ebp-0F4h] 01151C6A mov dword ptr [ebp-0E0h],eax 01151C70 mov dword ptr [ebp-4],0FFFFFFFFh 01151C77 mov ecx,dword ptr [ebp-0E0h] 01151C7D mov dword ptr [p],ecx return *p;01151C80 mov eax,dword ptr [p] 可以看到return *p时只有一步将对象地址放入寄存器的操作，没有拷贝的过程(没有匿名对象产生，也就没有相应的匿名对象this指针，无从调用) 也就是说返回类对象引用其实是返回其地址，这和返回内部变量类型是一致的，同样的禁止返回局部类对象的引用，编译器不会报错误，但这是一个危险操作。 全文完毕。 后记：感谢 Icoding_F2014博主的详尽分析，本文基本上算是对其分析过程的验证。 参考： Icoding_F2014对于上述过程的论证 修订记录： 2018-12-2 01:37 补充返回类对象的有关内容。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++相关</tag>
        <tag>return不同类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的环境编程之静态库和动态库]]></title>
    <url>%2F2018%2F11%2F21%2FLinux_LinkSharelib%2F</url>
    <content type="text"><![CDATA[静态库和动态库的链接各有优缺点,静态库会在文件编译二进制文件的时候,会直接链接到二进制文件里面,这样子文件体积比较大,而且如果我们更改分享库的时候需要重新编译.动态库只是保存分享库和二进制文件的依赖关系.在运行阶段才会加载动态库 参考书籍:&lt;Linux的环境编程,从应用到内核&gt; 操作系统:deepin 编译器:gcc 简单动态库与静态库分析这里要区分一下静态链接和动态链接的区别以及,静态库和动态库的区别. 静态库静态库在linux下是以”.a”结尾的,静态库将汇编 生成的.o文件进打包成一个.a文件,静态库可以在可执行文件编译的时候直接链接进可执行文件里面,移植方便,在新的操作系统上面运行不用搭建库环境. 创建静态库 123gcc -c test1.c test2.c test3.c ;-c命令是只编译不链接,会自动生成test1.o test2.o test3.oar -crv libtest.a test1.o test2.o test3.o ;使用ar工匠打包成静态库上面我们需要注意一下静态库和动态库的命名上市 lib****.so lib****.a ;我们在链接库的时候有时候会指定特定的库时,-l*** 就行,然后系统就自动会解析出来 -l lib***.so ,这个也是为什么这样命名 动态库动态库是在可执行文件编译的时候将库函数链接加载进去,在可执行文件 运行时依靠这依赖关系加载.这样可以使代码轻便,而且更新库文件的话,可执行文件不要重新编译. 制作动态库 1gcc -Wall -shared test1.c -o libtest.so 简单小例子 编译一个简单的C文件 test.c1vim test1.c 12345678内容如下:#include "stdio.h"#include "stdlib.h"int main(void) &#123; printf("Welcome !!\r\n"); return 0; &#125; 1gcc test1.c -o test1 ;这是默认动态链接 1gcc test1.c -o test1_1 -static ;这是静态链接 对比上图可以发现静态链接的可执行文件比动态链接的大特别多. 使用ldd(查询动态依赖关系)命令查看 可以看出来使用动态库链接的时候 使用ldd命令看到依赖的库,但是静态链接的会提示不是一个动态可执行文件,因为他是动态依赖的,运行过程不要动态依赖, 编译生成和使用动态库编译生成一个动态库 1234567#include "stdio.h"#include "stdlib.h"void Funful_call(void) &#123; printf("Welcome \r\n"); printf("调用动态库\r\n"); &#125; 1gcc -Wall -shared lib_funful.c -o libfunful.so 使用动态库 创建一个test3.c 123456789#include &quot;stdio.h&quot;#include &quot;stdlib.h&quot;int main(void) &#123; Funful_call(); return 0; &#125; 编译 1gcc -W test3.c -o test3 -L ./ -lfunful 运行会发现找不到libfunful.so ,这是因为我们上面只是指定了编译时候的动态库地址,但是我们运行的时候还是在系统默认的库地址(/usr/lib ;/lib)进行链接;可以通过/ect/ld.so.conf,配置文件和环境变量LD_LiBRARY_PATH指示额外的动态库路径. 还可以通过libfunful.so移到/usr/lib或者/lib里面,这样我们的库就可以正常运行. 手动加载动态库系统的C库提供了一系列接口,开手动加载动态库功能. 头文件: #include “dlfcn.h” ;//可是使用find命令查找 头文件: /bits/dlfcn.h 里面是对相应的宏定义 相关函数介绍dlopen 打开接口函数,返回一个句柄,然后通过dlsym得到相应的值 1void *dlopen (const char *file, int mode) __THROWNL; 参数: const char *file;找到文件地址指针 int mode; 打开的模式,在linux按照功能可以分为三类 解析方式: ​ RTLD_LAZY 在dlopen返回前，对于动态库中的未定义的符号不执行解析 ​ RTLD_NOW 在dlopen返回前，解析出所有未定义符号，如果解析不出来，在dlopen会返回NULL 作用范围: ​ RTLD_GLOBAL 动态库中定义的符号可被其后打开的其它库解析 ​ RTLD_LOCAL 与RTLD_GLOBAL作用相反，动态库中定义的符号不能被其后打开的其它库重定位。 作用方式 ​ RTLD_NODELETE 在dlclose()期间不卸载库，并且在以后使用dlopen()重新加载库时不初始化库中的静态变量 ​ RTLD_NOLOAD 不加载库 ​ RTLD_DEEPBIND 在搜索全局符号前先搜索库内的符号，避免同名符号的冲突。 dlclose 关闭一个分享库,这个句柄在调用dlclose之后就不能在使用. 11. int dlclose (void *handle) THROWNL __nonnull ((1)); 参数: 这个形参是dlopen返回的句柄. dlsym 这个函数是根据链接库的句柄和符号,返回相应的符号地址. 12void *dlsym (void *__restrict __handle, const char *__restrict __name) __THROW __nonnull ((2)); 参数: void *restrict handle; 这个是链接库句柄 const char *restrict name ;符号的字符串指针 手动加载动态库实例123456789101112131415161718192021#include "stdio.h"#include "stdlib.h"#include "dlfcn.h"int main(void) &#123;void *dlib=dlopen("./libfunful.so",RTLD_NOW); if(dlib == NULL ) &#123; printf("open libfunful.so failed\r\n"); return -1; &#125; void (*dfunc)(void) =dlsym(dlib,"Funful_call"); if(dfunc==NULL) &#123; printf("dlsym failed \r\n"); return -1; &#125; dfunc(); dlclose(dlib);return 0;&#125; 编译1gcc test3.c -ldl -o test3 ;这里需要我们指定一下依赖的dl库,否则会提示undefined dl的函数 总结上面讲解的动态库加载分为两中方法,一种是更新环境变量的方法,一种是手动加载各有利弊,]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>静态库</tag>
        <tag>动态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于七牛云测试域名回收解决方案]]></title>
    <url>%2F2018%2F11%2F20%2FTechnical_articles_1%2F</url>
    <content type="text"><![CDATA[之前写更新的几篇文章,没有注意到七牛云测试域名要回收的信息,今天突然发现测试域名复制外链的时候,竟然无法复制,而且提示错误:5402Bucket域名失败,所以就决定自定义一个个人域名解决. 融合 CDN 测试域名公告 但是发现之前文章的测试域名还能在blog中正常显示，所以先不管这个呢．先创建自定义域名． 解决方案自定义域名123本站域名:funful.ink七牛绑定域名:cdn.funful.ink 登录七牛云,进入对象存储,再进入到相应的存储空间,在空间概览,点击自定义域名.如图: 如图:点击自定义域名之后,会进入域名管理-&gt;创建域名里面,我们只需要填写一个加速域名,也就是二级域名,这里我的funful.ink已经备案了,所以我就在我的主域名前加一个字符串,然后点击创建就可以了.如图: 这是后再次去存储空间-&gt;空间概览会发现域名状态是: 处理中 配置CNAME 获得CNAME 上图点击我们的自定义域名就可以看到这个域名的基本信息,包括CNAME:将其复制下来. 打开阿里云官网-&gt;控制台-&gt;域名,在主域名下点击解析-&gt;添加记录 会出现如图设置: 上图的记录类型:选择CNAME;主机记录:就是我们七牛云自定义域名前缀;记录值:就是CNAME值;其他值默认就可以. 点击确认就配置好了CNAME 返回到七牛云我们的存储空间-&gt;空间概览会发现,融合CDN加速域名里面的域名状态已经成功了,如果是等待CNAME的话可能是需要等待几分钟. 使用存储空间上面已经配置好 进入储存空间-&gt;内容管理.选择外链默认域名之后就可以正常使用了,(外链域名不能使用七牛云的测试域名,因为这个测试域名只能使用一个月)]]></content>
      <categories>
        <category>各个方面方案解决</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[STM2F407与FreeRTOS的FreeRTOSConfig.h详解]]></title>
    <url>%2F2018%2F11%2F18%2FSTM32_FreeRTOS_config_2%2F</url>
    <content type="text"><![CDATA[上一篇，对config宏的基础配置和部分相关的配置，有些宏我们暂时没有用上，所以对这些宏定义的概念不太清楚，这章节是对余下部分解析。 config_*FreeRTOS与钩子函数有关的配置选项configUSE_IDLE_HOOK为1的话，就是使能空闲任务回调函数，也就是如果系统调用空闲函数的话，就会回调钩子函数，我们自己去实现这个函数，函数声明如下： 1void vApplicationIdleHook( void ); configUSE_TICK_HOOK为1的话使能时间片钩子函数，但是需要我们自己去实现这个函数，函数声明如下： 1void vApplicationTickHook( void ); FreeRTOS与运行时间和任务状态收集有关的配置选项configGENERATE_RUN_TIME_STATS为1 的话开启时间统计功能，如果定义这个宏的话，就必须还有定义另外两个宏，这个在后面的任务查询的时候我们有可能会配置，这两个宏分别是： 12portCONFIGURE_TIMER_FOR_RUN_TIME_STATSportALT_GET_RUN_TIME_COUNTER_VALUE configUSE_TRACE_FACILITY为1的话启动可视化跟踪调试，会增加一些结构体成员和API函数。 configUSE_STATS_FORMATTING_FUNCTIONSSet configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS to 1to include the vTaskList() and vTaskGetRunTimeStats() FreeRTOS与协程有关的配置选项（现在的MCU很强大，不需要节约资源，所以基本不配置协程）configUSE_CO_ROUTINES为1的话，工程需要编译协程，需要把协程文件包含进来，相应的API函数才会被编译。 configMAX_CO_ROUTINE_PRIORITIES设置协程的最大优先级，设置完之后，协程使用的优先级范围0~configMAX_CO_ROUTINE_PRIORITIES-1 FreeRTOS与软件定时器有关的配置选项configUSE_TIMERS为1则启动软件定时器，还有三个宏也需要定义， 123configTIMER_TASK_PRIORITYconfigTIMER_QUEUE_LENGTH configTIMER_TASK_STACK_DEPTHxxxxxxxxxx configTIMER_TASK_PRIORITY设置定时器任务的优先级，0~configMAX_PRIORITIES-1，如果定时器任务的优先级高的话，定时器的队列和回调函数会及时处理。 configTIMER_QUEUE_LENGTH设置定时器队列的队列长度。 configTIMER_TASK_STACK_DEPTH定时器任务的堆栈，可以根据定时器回调函数的大小，定义定时器任务堆栈大小。 FreeRTOS与中断有关的配置选项__NVIC_PRIO_BITS设置优先级位数，STMF407,是高四位，也就是BIT4，5，6，7 configLIBRARY_LOWEST_INTERRUPT_PRIORITY设置最低优先级，因为STM32的NVIC配置的组4，也就是16位抢占优先级，所以最低优先级为15，ARM的0优先级最大。 configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITYFreeRTOS可以管理的最低优先级，如果设为5的话，0-5不归FREERTOS管，其余的RTOS可以通过API函数管理。与BASEPRI这个寄存器相关。 configKERNEL_INTERRUPT_PRIORITY这个是设置内核中断优先级，也就是系统中断的PenSV和SysTick（滴答定时器） configMAX_SYSCALL_INTERRUPT_PRIORITY设置FreeRTOS的API函数的优先级，低于此优先级的中断可以安全调用FREERTOS的API函数，高于此优先级时，如果调用API函数，中断也可以打断。 总结上面有些宏，从字面意思理解并不难，但是我们需要结合相应的功能，才能熟练运用。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>Stm32F407</tag>
        <tag>FreeRTOS</tag>
        <tag>MDK5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM2F407与FreeRTOS的FreeRTOSConfig.h详解]]></title>
    <url>%2F2018%2F11%2F14%2FSTM32_FreeRTOS_config_1%2F</url>
    <content type="text"><![CDATA[FreeRTOS是一个RTOS类的嵌入式实时操作系统，并且是开源免费的，与其他实时操作系统相比，是一个很好的选择。在移植好FreeRTOS到STM32上面之后，需要根据板子外设配置相应的功能，FreeRTOSConfig.h里面的宏完成对系统的裁剪和配置。 系统配置文件FreeRTOSConfig.h在编译移植好的FreeROTS工程之后，需要都这个系统配置文件进行宏配置，这个配置文件与我们在编译kernel时的menuconfig类似，里面定义的宏，是对板子外设的和功能的裁剪配置。这个里面主要分为两个类的宏，一个是“INCLUDE_”开始的宏，一个是“config”开始的宏。FreeRTOSConfig.h是我们自己填充的.h文件，RTOS工程自带一个FreeRTOS.h文件，我们在FreeRTOSConfig.h定义的宏会对FreeRTOS.h进行条件编译。 INCLUDE_*这个宏的主要功能就是使能或者是失能，FreeRTOS中的API函数的，如果我们需要使用某个api函数就需要把这个宏置1，否则就是置0。在FreeRTOSConfig.h，在上面部分是宏的声明，在对应的.c文件里面会有条件编译，这个就可以达到减少系统占有的ROM和RAM。 INCLUDE_xTaskGetSchedulerState这个宏是对xTaskGetSchedulerState函数的条件判断，是获取任务调度表状态的函数。 INCLUDE_vTaskPrioritySet这个宏是对vTaskPrioritySet函数的条件判断，是任务优先级设置的函数。 INCLUDE_uxTaskPriorityGet这个宏是对uxTaskPriorityGet函数的条件判断，是获得任务优先级的函数。 INCLUDE_vTaskDelete这个宏是对vTaskDelete函数的条件判断，是获得任务优先级的函数。 INCLUDE_vTaskCleanUpResources这个宏是对vTaskCleanUpResources函数的条件判断，是对删除的任务进行资源回收的函数。 INCLUDE_vTaskSuspend这个宏是对vTaskSuspend函数的条件判断，是对任务进行挂起的函数。 INCLUDE_vTaskDelayUntil这个宏是对vTaskDelayUntil函数的条件判断，是设置任务延迟绝对时间的函数。 INCLUDE_vTaskDelay这个宏是对vTaskDelay函数的条件判断，是设置任务延迟相对时间的函数。 INCLUDE_eTaskGetState这个宏是对eTaskGetState函数的条件判断，是获得某个任务的状态的函数。 INCLUDE_xTimerPendFunctionCall这个宏是对xTimerPendFunctionCall函数的条件判断，是获得某个任务的状态的函数 config_*FreeRTOS基础配置选项1为抢占式调度，0为协程，抢占式调度器会在内核的中断中进行任务的切换，协程的话，会在三种情况下，进行任务的切换: 一个任务调用函数taskYIELD(); 一个任务调用可以使任务进入阻塞状态的API函数； 应用程序明确定义了在中断中执行上下文切换； configUSE_TIME_SLICING为1的话，在相同优先级下的任务使用合作式调度器，也就是时间片轮流执行。为0的话则不会。 configUSE_PORT_OPTIMISED_TASK_SELECTION选择下一个要执行的任务，为0是通用的方法，为1是特殊方法，使用硬件指令计算。 configUSE_TICKLESS_IDLEFreerRTOS支持低功耗tickless模式，为1使能，tickless低功耗模式是RTOS通过的低功耗方法， configUSE_QUEUE_SETS设置成1使能队列集功能（可以阻塞、挂起到多个队列和信号量），设置成0取消队列集功能。 configCPU_CLOCK_HZ设置CPU工作的频率。 configTICK_RATE_HZ设置滴答定时器的中断频率，这里设置为1000，周期就是1ms。 configMAX_PRIORITIES设置优先级的数量，范围为0~（configMAX_PRIORITIES-1），0为最低优先级，值越大优先级越高，而且我们的任务不可使用0优先级， configMINIMAL_STACK_SIZE设置最小任务堆栈大小，也就是空闲任务大小，单位是字， configMAX_TASK_NAME_LEN设置任务名最大长度，字节为单位 configUSE_16_BIT_TICKS设置系统节拍计数器变量数据类型。设为 1后portTickType 将被定义为无符号的16位整形类型，configUSE_16_BIT_TICKS 设为0 后portTickType 则被定义为无符号的32位整型。 configIDLE_SHOULD_YIELD这宏的作用是定义了与空闲任务（idle task）和其他任务处于同等优先级时，为1时，时间片轮到空闲任务的时候，空闲任务会将cpu的使用权交给其他任务 。 configUSE_TASK_NOTIFICATIONS为1 则开启任务通知功能。 configUSE_MUTEXES为1使用互斥信号量。 configQUEUE_REGISTRY_SIZE设置可以注册队列和信号量的最大数量，在内核调试器查询队列和信号量的时候需要设置这个宏， configCHECK_FOR_STACK_OVERFLOW设置堆栈溢出检测，每个任务的堆栈是从FreeRTOS的ucHeap中分配的，如果任务的堆栈溢出的话，会造成程序不稳定，为1的话则设置为堆栈溢出检测功能，需要和钩子函数结合使用，也就是一个回调函数，当溢出是会调用这个回调函数。 configUSE_RECURSIVE_MUTEXES为1的话是使能递归互斥信号量。 configUSE_MALLOC_FAILED_HOOK为1使用内存分配失败的钩子函数， configUSE_APPLICATION_TASK_TAG这个宏为1是使能两个函数进行编译： configUSE_APPLICATION_TASK_TAGF（）这个函数 vTaskSetApplicationTaskTag（）,这个函数是为任务分配一个标签值。 configUSE_COUNTING_SEMAPHORES设置1会启动计数型信号量， FreeRTOS与内存申请有关配置选项configSUPPORT_DYNAMIC_ALLOCATION定义为1的话FreeRTOS内核对象所需要的RAM会从FREERTOS的堆中动态的获取内存，为0则需要内核对象自己提供。 configTOTAL_HEAP_SIZE设置堆空间（Heap）的大小。只有当程序中采用FreeRTOS 提供的内存分配算法时才会用到。 总结总是我们没有用到的宏有些不会在FreeRTOSConfig.h定义，需要在FreeRTOS.h中查找，并且上面和针对config的宏还有部分配置解释。]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>Stm32F407</tag>
        <tag>FreeRTOS</tag>
        <tag>MDK5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES8266模块AT操作]]></title>
    <url>%2F2018%2F11%2F07%2FESP8266_Connect_TO_PhoneAndPC_WithTCP%2F</url>
    <content type="text"><![CDATA[这个教程是基于ESP8266和手机与电脑的TCP通信。 文档 AT的指令集 AT的示例教程 Android版的TCP调试助手可以去软件库里面下载 PC版的调试助手可以去CSDN下载，链接 Download 步骤ESP8266的AT操作 AT+RST（重启） AT+RESTORE（恢复出厂设置，第一次操作建议不要，如果不能正常工作的话，可以执行该命令） AT+CWMODE_DEF=3（WIFI模式（STA/AP/STA+AP）） AT+CWSAP=”OneNET”,”123456789”,1,3（设置ssoftAP的ssid，密码，通道号1，WAP2_PSK加密） AT+CIPMUX=1（多连接） AT+CIPSERVER=1,8080（设置TCP server 的端口号8080） 这样我们就设置好了，手机和电脑都可以正常连接到“OneNET”，我们还要注意下ESP8266的IP和端口，上面已经知道端口号是8080，服务器IP是192.168.4.1，可以使用”AT+CIFSR”得知。 手机端&amp;PC连接 手机开启wifi连接OneNET 手机端打开TCP调试助手，设置如图，点击connect 电脑连接ESP8266的串口显示 这就显示连接成功了，下来电脑端也连接”OneNET”，打开网络调试助手，设置如图 上面四步我们就将手机和电脑作为TCP client 连接到电脑了，下面测试通信。 通信ESP8266接收 手机端发送如图 电脑端发送如图 ESP8266串口显示 ESP8266发送 ESP82266多链接最多可以连接5个设备，上面我们知道手机分配的ID为0，电脑ID为1 先给手机端发送，执行命令 12345AT+CIPSEND=&lt;link ID&gt;,&lt;length&gt;AT+CIPSEND=0,11（给ID0发送11个字节数据）OK&gt;Hello,PHONE 给电脑端发送，执行命令 1234AT+CIPSEND=1,11（给ID1发送11个字节数据）OK&gt;Hello,PC 总结使用AT指令开发ESP8266，比较简单，但是ESP8266内置MCU，这使得浪费了硬件资源。这篇文章是基于TCP多连接的通信，至于单连接，就更简单了。]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
      <tags>
        <tag>AT指令集</tag>
        <tag>ESP8266</tag>
        <tag>TCP通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Orange's:一个操作系统的实现_1th_环境搭建]]></title>
    <url>%2F2018%2F11%2F03%2FOrange's_Implementation_of_an_operating_system_1th_build_environment%2F</url>
    <content type="text"><![CDATA[这章节主要是搭建操作系统环境和编写一个简单程序 环境 Deepin操作系统 Nasm bochs bximage(bochs自带的软盘映象制作软件) 参考书籍：《Orange’S:一个操作系统的实现》 我们自己写一个操作系统的话就需要有个虚拟机和软盘来运行这个操作系统，但是我们又不至于真的买个软盘，所以我们可以使用bximage生成一个虚拟软盘，把我们写的系统生成相应的文件烧录到虚拟软盘里面，使用dd命令就可以，在bochs启动的时候选择使用我们的虚拟软盘启动就可以。 软件安装及简单命令Nasm Nasm源码下载地址：Nasm 解压并进入解压目录 执行命令 123./configuremakemake install 简单指令 12汇编指令：nasm boot.asm -o boot.bin Bochs Bochs下载地址：Bochs官网 解压并进入解压目录 Bochs依赖软件安装 123sudo apt-get install build-essentialsudo apt-get install xorg-dev如果执行4命令报出别错误的话可能是别的依赖软件没有安装 ，请自行百度 执行以下命令 123./configure --enable-debugger --enable-disasm ；//这个命令是将bochs设置为可调式的makemake instal Bochs简单命令 12345我们在使用bochs启动的时候可以选择硬盘启动或者是软盘启动，所以这个时候，我们需要配置相应的配置文件，我们可能会在bochs源码里面发现有“.bochsrc”或者是“bochsrc” ，我们也可以自己写一个配置文件使用“bochs -f yourname” 这命令来启动我们自己写的配置文件“yourname&quot;。（linux下的.文件被隐藏使用 “ls -al”查看）启动配置文件: bochs -f yourname（直接bochs也可以启动默认配置文件）继续执行直到遇见断点：c单步执行 : n看寄存器信息：dump_cpu 打印一个”Hello World”在我们接触C语言的时候最基础的工程就是使用printf打印出”Hello World!”.这里我们也使用汇编打印一个hello 创建boot.asm并书写一下内容 123456789101112131415161718org 07c00h ; 告诉编译器程序加载到7c00处mov ax, csmov ds, axmov es, axcall DispStr ; 调用显示字符串例程jmp $ ; 无限循环DispStr:mov ax, BootMessagemov bp, ax ; ES:BP = 串地址mov cx, 16 ; CX = 串长度mov ax, 01301h ; AH = 13, AL = 01hmov bx, 000ch ; 页号为0(BH = 0) 黑底红字(BL = 0Ch,高亮)mov dl, 0int 10h ; 10h 号中断retBootMessage: db &quot;Hello, OS world!&quot;times 510-($-$$) db 0 ; 填充剩下的空间，使生成的二进制代码恰好为512字节dw 0xaa55 ; 结束标志 生成bin文件 1nasm boot.asm -o boot.bin bximage生成512字节的虚拟软盘 在终端下执行bximage 选择1，再输入”fd”（选择虚拟软盘），再确认，再确认，最终生成1.44M的a.img文件 也可以使用dd命令代替bximage，1dd if=/dev/zero of=a.img bs=1440k count=1 dd命令将boot.bin烧录到a.img 1dd if=./boot.bin of=./a.img bs=512 count=1 conv=notrunc 配置bochs文件 将烧录的a.img移到bochs的源码目录中 在bochs的源码目录里面，执行“ls -al”,可以看到一个.bochsrc vim .bochsrc 设置floppya 将boot设置为：floppy 终端执行”bochs -f .bochsrc” Please choose one: [6] 6 如果bochs带调试功能：需要输入c继续执行，才能执行。 现象： 总结这个章节主要是搭建操作系统运行的环境和编写一个简单的裸机文件，这个汇编程序比较简单，但是这个org命令让我想到了之前在学习内核的时候的相对地址和绝对地址，疑问编译器编译的指令是相对地址是从000h编译的，但是我们自己创建的引导扇区是从07C00h开始执行的，所以需要用到org命令。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>nasm</tag>
        <tag>bochs</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES8266模块二次开发SDK之MQTT局域网控制LED]]></title>
    <url>%2F2018%2F10%2F28%2FESP8266_SDK_MQTT_LED%2F</url>
    <content type="text"><![CDATA[根据乐鑫官网的提供的Pro，已经提供了 支持MQTT协议，，在乐鑫pro 基础上再局域网下面控制led 准备工程文档准备 下载链接 乐鑫 选用的平台NON-OS SDK 使用安信可一体化编程软件打开，文档的导入具体去安信可官网搜索，这里直接讲解导入后的操作。 删除third_party,将esp_mqtt_proj从example拉出来，将driver_lib的Makefile添加后.bak,目的是为了不讲driver_lib不编译进工程 如图， MQTT的windows环境准备 下载EMQ压缩包，根据你的windows环境选择，下载地址链接 解压到不带中文的目录下，打开windows命令，进入到该解压目录的bin文件夹下面， 在终端执行”emqttd console”，如果卡顿就重新执行 在浏览器输入”127.0.0.1:18083” 此时会进入EMQ的界面SSID为admin，Passwd为public 此时MQTT服务器已经搭建完成 硬件环境准备 一块MODEMCU或者是ESP8266的最小系统 一个USB转TTL或者是数据线 软件环境 烧录工具，可以在安信可官网下载 链接 串口工具，使用任意一款都可以， 步骤搭建测试环境 在工程中打开user_main.c和mqtt_config.h， 在mqtt_config.h需要修改以下几个宏 | CFG_HOLDER | 更新配置到FLASH中，只要数值和本次不一样就行， || —————– | —————————————- || MQTT_HOST | MQTT服务器的IP || MQTT_PORT | MQTT服务器的PORT || MQTT_CLIENT_ID | 客户端ID || MQTT_USER | MQTT服务器的登录账号”admin” || MQTT_PASS | MQTT服务器的登录”admin” || STA_SSID | ESP8266和电脑端连接的路由账号 || STA_PASS | ESP8266和电脑端连接的路由密码 || PROTOCOL_NAMEv311 | 根据MQTT协议的兼容性，在前面加#define，PROTOCOL_NAMEv31注释掉 || | | 右击该工程，Clean Project &amp;&amp;Build Project 可以看到顺利通过编译，如图 依照安信可官方提供的烧录方法可以知道， blank.bin、esp_init_data_default_v05.bin是乐鑫SDK提供的，而eagle.flash.bin和eagle.irom0text.bin是编译工程生成的，，下载地址需要我们将工程给的地址和安信可提供地址组合得到，如图 | SPI SPEED | 40MHz || ———- | ————– || SPI MODE | DOUT || FLASH SIZE | 32Mbit（根据板子而定） || | | 使用烧写工具擦写和下载， 将MQTT服务器Runing，(MQTT服务器和ESP8266需要在同一个局域网下面) 重启ESP8266模块，打开串口 BAUD 115200 在浏览器登录MQTT，可以看到会话界面，有刚才客户端ID,主题界面有工程中注册的主题如图 ​ 主题，是我们在user_main.c的mqttConnectedCb函数注册的主题 如图 串口也会打印出来 到这一步，我们整个MQTT的局域网服务器已经搭建起来，下面测试一下， 在EMQ界面切换到websocket测试，首先连接 订阅主题”/mqtt/topic/1” 给主题”/mqtt/topic/1” 发送”Hello World!” 如图 在串口端会打印出”Hello World!”,如图 ​ 这里整体的测试环境已经搭建完成，我们下面开始进行局域网，点亮LED 局域网点亮LED 回到工程进入user_main.c， 在user_init 函数中添加 12PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO5_U, FUNC_GPIO5); //选择GPIO5GPIO_OUTPUT_SET(GPIO_ID_PIN(5), 1); //默认GPIO5为高 ​ 在mqttConnectedCb函数中注册一个主题 1MQTT_Subscribe(client, "/hangtong/led/control", 0); 在mqttDataCb对收到的值解析 123456789101112if (data[0] == '0') &#123; GPIO_OUTPUT_SET(GPIO_ID_PIN(5), 0); MQTT_Publish(client, "/xuhong/LED/out", "LED status is open ...", strlen("LED status is open ..."), 0, 0); &#125; //接收到指令是0，GPIO15为高,也就是LED关灯，同时发布消息，主题是/xuhong/LED/out，信息是LED status is off ... if (data[0] == '1') &#123; GPIO_OUTPUT_SET(GPIO_ID_PIN(5), 1); MQTT_Publish(client, "/xuhong/LED/out", "LED status is off ...", strlen("LED status is off ..."), 0, 0); &#125; ​ Clean Project &amp;&amp;build Project 重复上面步骤， 在EMQ服务器上面我们，会发现出现了”/hangtong/led/control” 主题 ，在websocket向”/hangtong/led/control”主题发送0则GPIO5为低电平。发送1则GPIO5为高电平 成功， 总结 MQTT服务器的IP需要我们在电脑端查询得到， 局域网的控制，所以电脑端和ESP8266需要连接同一个路由]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
      <tags>
        <tag>ESP8266</tag>
        <tag>SDK</tag>
        <tag>MQTT</tag>
        <tag>局域网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES8266模块二次开发SDK之]]></title>
    <url>%2F2018%2F07%2F27%2FESP8266_SDK_api_HelloWorld%2F</url>
    <content type="text"><![CDATA[根据安信可官方文档，通过修改安信可提供的SDK，使串口输出Hello，World！ 准备 开发环境搭建： 链接 最新烧录工具： ESP FLASH TOOL 1.54版本的SDK： ESP8266_NONOS_SDK_v1.54 开发板(以下三种都可以）： ESP8266模块 NodeMcu 安信可开发板 下面根据我使用的NodeMcu，，前提是开发环境已经搭建完成，手中也有一块板子 ，需要的工具也已经下载了，记录一下，该教程操作步骤！ 步骤SDK编译生成BIN文件 打开AiThinker_IDE File- &gt;Import-&gt;C/C++-&gt;Existing Code as MakeFile Project，点击 Next 选择我们刚才下载的最新SDK的路径，取消C++，选中Cygwin GCC， 点击Finish 这样我们的工程就建立好了 在工程中，打开app，进入user，打开user_main.c 在user_init函数中添加一句 os_printf(“\r\nHello，World!\r\n”); 选中该工程右键选择Clean Project，然后再Build Project。 然后就可以 看到下面提示 下面就开始烧录 烧录 参考安信可官方的 ESP 系列模组烧录固件的指导： NodeMcu, 不需要我们手动的将GPIO0拉低， 根据我们上面的生成的两个bin文件可以知道，我们下载的1.54版本的SDK是支持云端升级的boot的 | 文件名称 | 8Mbit 地址分配 | 16Mbit 地址分配 | 32Mbit 地址分配 | 备注 || ————————- | :——–: | ———– | ———– | ———————– || boot.bin | 0x00000 | 0x00000 | 0x00000 | 由乐鑫在 SDK 中提供，建议一直使用最新版本 || user1.bin | 0x01000 | 0x01000 | 0x01000 | 主程序，由代码编译生成 || user2.bin | 0x81000 | 0x81000 | 0x81000 | 主程序，由代码编译生成 || esp_init_data_default.bin | 0xFC000 | 0x1FC000 | 0x3FC000 | 由乐鑫在 SDK 中提供 || blank.bin | 0xFE000 | 0x1FE000 | 0x3FE000 | 由乐鑫在 SDK 中提供 | 参考上图我们自己的烧录设置是（NodeMcu是32Mbit的） | boot_v1.5.bin | 0x00000 || ————————- | ——– || user1.1024.new.2.bin | 0x01000 || esp_init_data_default.bin | 0x3FC000 || blank.bin | 0x3FE000 || | | 烧录工具的设置 如图： 选好COM口，BAUD选的越大，下载速度越快，如果下载失败，可以将波特率降低 下载好之后，我们重启开发板，连接串口调试助手，波特率76800-1-8-0，如图 可以看到输出 Hello,World！ 总结 这个ESP8266的入门教程我们需要注意几点，第一是安信可提供的烧录指南的分两种情况，一种是支持云端升级的(BOOT)，另一种是不支持云端升级（No BOOT）。我们使用的1.5.4的SDK是支持云端升级的，1.2版本的不支持云端升级，两者下载的时候选的BIN文件，不相同。 使用ESP8266模块的下载的时候需要将GPIO0拉低。 ​]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
      <tags>
        <tag>ESP8266</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JZ2440的uboot-2009-11移植_支持Nor Flash]]></title>
    <url>%2F2018%2F06%2F12%2FJZ2440_uboot_2009_11_transplant_3_nor_flash%2F</url>
    <content type="text"><![CDATA[这一节是对第二阶段的代码进行移植，来支持Nor Flash 硬件环境Nor Flash介绍Nor Flash 是一种存储芯片，支持掉电存储、支持Executensil On Chip（片上程序运行）。所以很适合作为嵌入式中启动程序的存储介质。但是由于低写速度和擦除速度影响着他的性能，在1~16MB的闪存中较为常见。 MX29LV160D T/B 芯片 2MB的Flash（8位/16位） ,JZ2440选用数据宽度的16位 扇区分布; | 大小 | 8K-Byte | 16K-Byte | 32K-Byte | 64K-Byte || —- | ——- | ——– | ——– | ——– || 块数 | 2 | 1 | 1 | 31 | Word/Byte 模式选择，如果选用Word时需要错位连接 工作电压2.7V~3.6V 引脚封装48pin-TSOP/48ball-XFLGA/WFBGA 至少可靠性保存数据20年，擦除、编程次数10万个周期 代码分析我们之前顺腾摸瓜，从start.S-&gt;crt0.S，在crt0.S中分别调用了两个函数：board_init_f和board_init_r。 位置12board_init_f 位于u-boot-2016.09\common\Board_f.cboard_init_r 位于u-boot-2016.09\common\Board_r.c board_init_f功能1234567主要是初始化下面这些timer_init, /* initialize timer */get_clocks,env_init, init_baud_rate, /* initialze baudrate settings */serial_init, /* serial communications setup */console_init_f, /* stage 1 init of console */ board_init_r功能123board_init,initr_flashinitr_nand, 代码解读所以我们知道nor flash的设置在board_init_r里面， 进入到static int initr_flash(void) ，位于（common\Board_r.c） 123456flash_info[i].flash_id = FLASH_UNKNOWN;从这一句我们可以看出来flash__info是存储Nor flash信息的结构体 if (!flash_detect_legacy(cfi_fla sh_bank_addr(i), i)) flash_detect_legacy(phys_addr_t base, int banknum) if (jedec_flash_match(info, info-&gt;start[0])) int jedec_flash_match(flash_info_t *info, ulong base) 将读取到的板子ID和已有板子信息做对比 &#123; int ret = 0; int i; ulong mask = 0xFFFF; if (info-&gt;chipwidth == 1) mask = 0xFF; for (i = 0; i &lt; ARRAY_SIZE(jedec_table); i++) &#123; if ((jedec_table[i].mfr_id &amp; mask) == (info-&gt;manufacturer_id &amp; mask) &amp;&amp; (jedec_table[i].dev_id &amp; mask) == (info-&gt;device_id &amp; mask)) &#123; fill_info(info, &amp;jedec_table[i], base); ret = 1; break; &#125; return ret; &#125; 1234567#### 代码修改1上面分析完 ，我们就可以知道，我们只要将上面函数的饿 jedec_table结构体增加我们对应的信息就行了 ```c修改添加 static const struct amd_flash_info jedec_table[] 结构体 位置1drivers\mtd\Jedec_flash.c 添加1234567891011 在结构体补充相应的信息&#123; /* sheldon add for JZ2440_V2 Nor_Flash ： MT29LV160DB */ .mfr_id = (u16)MX_MANUFACT, //厂家 id .dev_id = 0x2249, //设备 id .name = &quot;MX29LV160D&quot;, .uaddr = &#123; [1] = MTD_UADDR_0x0555_0x02AA /* 1:x16 ,NOR Flash 的解锁地址 */ &#125;, .DevSize = SIZE_2MiB, //整个 nor flash 的大小 .CmdSet = P_ID_AMD_STD, .NumEraseRegions= 4, //擦除域，有几种大小的块就有几个擦除域， .regions = &#123; //查看芯片手册设置擦除块 ERASEINFO(0x10000, 31), //参照芯片手册里面的块信息 ERASEINFO(0x08000, 1), ERASEINFO(0x02000, 2), ERASEINFO(0x04000, 1), &#125; 代码修改2 我们还要修改myff244.h的一个宏 /#define CONFIG_SYS_MAX_FLASH_SECT (128) 因为我们的最大快区大于19了 测试重新编译uboot 下载到板子里面，就可以看到成功。 虽然我们看到串口打印出来的信息显示支持Flash，但是我们要测试下是否真的支持了 进入到uboot的命令行 输入：flinfo 可见扇区地址，扇区数、设备ID和厂商ID都是正确的。接下来进一步确认正确与否 查看命令 md.b A0000 10 查看0x50000地址开始的10个字节数据（） 拷贝命令 cp 30008000 A0000 10 将30008000的10个字节拷贝到A0000（A0000的地址不能低于uboot.bin的size，如果低于u-boot.bin的size ，一旦拷贝就会损坏u-boot） 擦除命令 erase A0000 Affff 擦除A0000~Affff之间的内容 以上这几个操作均正常，说明设备已经支持Nor flash NOR FLASH 移植成功 ​ ​ ​ ​]]></content>
      <categories>
        <category>uboot移植</category>
      </categories>
      <tags>
        <tag>移植</tag>
        <tag>arm</tag>
        <tag>linux</tag>
        <tag>Nor Flash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JZ2440的uboot-2009-11移植_串口输出]]></title>
    <url>%2F2018%2F06%2F08%2FJZ2440_uboot_2009_11_transplant_2_%E6%94%AF%E6%8C%81%E4%B8%B2%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[整理下自己之前的移植uboot时记录的笔记！这个章节是对uboot的第一阶段的代码进行优化和代码的修改，使其可以正确的启动串口。 修改启动代码 在上个章节，当我们编译完成之后会发现在根目录下面会有一个u-boot.lds的文件，这是链接文件，这个文件就在 u-boot-2016.09/arch/arm/cpu/u-boot.lds 进去之后发现，板子启动执行的第一个文件是start.S,代码流程 第一阶段启动代码修改 设置cpu为SVC32 模式 关闭看门狗 屏蔽中断，这个地方我们需要添加对2440的支持， 12345678910 在 #if defined(CONFIG_S3C2410) ldr r1, =0x3ff ldr r0, =INTSUBMSK str r1, [r0]添加：#elif defined(CONFIG_S3C2440) ldr r1, =0x7fff ldr r0, =INTSUBMSK str r1, [r0] 设置系统时钟，查看S3C2440的数据手册可以，FCLK:HCLK:PCLK=1:4:8,FCLK=405Mhz 123456789101112修改如下： ldr r0, =CLKDIVN mov r1, #5 str r1, [r0]/**配置为异步模式**/ mrc p15, 0, r1, c1, c0, 0 orr r1, r1, #0xc0000000 mcr p15, 0, r1, c1, c0, 0 #define S3C2440_MPLL_400MHZ ((0x7f&lt;&lt;12)|(0x02&lt;&lt;4)|(0x01))/* ldr r0, =0x4c000004 ldr r1, =S3C2440_MPLL_400MHZ str r1, [r0] 跳转到cpu_init_crit，关闭MMU，关闭I/D caches ,再进入lowlevel_init lowlevel_init，这个是配置Memory控制器。 在u-boot-2016.09/board/samsung/myff2440/lowlevel_init.S 12345上面我们修改了系统时钟的分频系数，所以此时的存储器控制器的SDRAM的刷新周期也需要更改，查数据手册，可知将#define REFCNT 1113 /* period=15.6us, HCLK=60Mhz, (2048+1-15.6*6.) */修改为：#define REFCNT 1269 /* period=7.8us, HCLK=100Mhz, (2048+1-7.8*100) */ ​ 然后进入 _main分支，也就是对第二阶段板子外设的设置， 位于uboot2016.9\ubootproject\u-boot-2016.09\arch\arm\lib\crt0.S 系统时钟移植添加s3c2440配置的宏1234567进入include/configs/myff2440.h将： #define CONFIG_S3C2440 /* specifically a SAMSUNG S3C2410 SoC */ #define CONFIG_MYFF2440 /* on a SAMSUNG SMDK2410 Board */修改为： #define CONFIG_S3C2440 /* specifically a SAMSUNG S3C2410 SoC */ #define CONFIG_MYFF2440 /* on a SAMSUNG SMDK2410 Board */ 修改分频系数12345678910111213141516171819202122232425进入uboot2016.9\ubootproject\u-boot-2016.09\board\samsung\myff2440\Myff2440.c将：#define FCLK_SPEED 1#if (FCLK_SPEED == 0) /* Fout = 203MHz, Fin = 12MHz for Audio */#define M_MDIV 0xC3#define M_PDIV 0x4#define M_SDIV 0x1#elif (FCLK_SPEED == 1) /* Fout = 202.8MHz */#define M_MDIV 0xA1#define M_PDIV 0x3#define M_SDIV 0x1#endif修改为：#define FCLK_SPEED 1#if (FCLK_SPEED == 0) /* Fout = 203MHz, Fin = 12MHz for Audio */#define M_MDIV 0xC3#define M_PDIV 0x4#define M_SDIV 0x1#elif (FCLK_SPEED == 1) /* Fout = 405.8MHz */#define M_MDIV 0x7f /*查数据手册可知，为了是FCLK=405MHZ，这三个分频值依次是0x7f、0x2、0x1*/#define M_PDIV 0x2#define M_SDIV 0x1#endif ​ 修改获取时钟函数在：u-boot-2016.09\arch\arm\cpu\arm920t\s3c24x0\Speed.c 12345678910111213141516171819202122232425262728293031323334353637将：static ulong get_PLLCLK(int pllreg)&#123; struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power(); ulong r, m, p, s; if (pllreg == MPLL) r = readl(&amp;clk_power-&gt;mpllcon); else if (pllreg == UPLL) r = readl(&amp;clk_power-&gt;upllcon); else hang(); m = ((r &amp; 0xFF000) &gt;&gt; 12) + 8; p = ((r &amp; 0x003F0) &gt;&gt; 4) + 2; s = r &amp; 0x3; return (CONFIG_SYS_CLK_FREQ * m) / (p &lt;&lt; s);&#125;修改为：static ulong get_PLLCLK(int pllreg)&#123; struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power(); ulong r, m, p, s; if (pllreg == MPLL) r = readl(&amp;clk_power-&gt;mpllcon); else if (pllreg == UPLL) r = readl(&amp;clk_power-&gt;upllcon); else hang(); m = ((r &amp; 0xFF000) &gt;&gt; 12) + 8; p = ((r &amp; 0x003F0) &gt;&gt; 4) + 2; s = r &amp; 0x3;#if defined(CONFIG_S3C2440) if (pllreg == MPLL) return 2 * m * (CONFIG_SYS_CLK_FREQ / (p &lt;&lt; s));#endif return (CONFIG_SYS_CLK_FREQ * m) / (p &lt;&lt; s);&#125; 12345678910111213141516171819202122232425262728将：ulong get_HCLK(void)&#123; struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power(); return (readl(&amp;clk_power-&gt;clkdivn) &amp; 2) ? get_FCLK() / 2 : get_FCLK();&#125;修改为：ulong get_HCLK(void)&#123; struct s3c24x0_clock_power *clk_power = s3c24x0_get_base_clock_power();#ifdef CONFIG_S3C2440 switch (readl(&amp;clk_power-&gt;clkdivn) &amp; 0x6) &#123; default: case 0: return get_FCLK(); case 2: return get_FCLK() / 2; case 4: return (readl(&amp;clk_power-&gt;camdivn) &amp; (1 &lt;&lt; 9)) ? get_FCLK() / 8 : get_FCLK() / 4; case 6: return (readl(&amp;clk_power-&gt;camdivn) &amp; (1 &lt;&lt; 8)) ? get_FCLK() / 6 : get_FCLK() / 3; &#125;#else return (readl(&amp;clk_power-&gt;clkdivn) &amp; 2) ? get_FCLK() / 2 : get_FCLK();#endif&#125; 添加摄像头分频寄存器CAMDIVN因为我们在修改get_HCLK函数时，用到了camera寄存器所以我们需要添加相关的宏。 12345678910111213141516171819202122在：u-boot-2016.09\arch\arm\include\asm\arch-s3c24x0\S3c24x0.h将：struct s3c24x0_clock_power &#123; u32 locktime; u32 mpllcon; u32 upllcon; u32 clkcon; u32 clkslow; u32 clkdivn;&#125;;修改为：struct s3c24x0_clock_power &#123; u32 locktime; u32 mpllcon; u32 upllcon; u32 clkcon; u32 clkslow; u32 clkdivn;#if defined(CONFIG_S3C2440) u32 camdivn;#endif&#125;; 支持CONFIG_S3C2440/CONFIG_MYFF2440的宏配置在前面我们修改板级支持的头文件中，我们修改了两个宏下面我们需要将系统中的CONFIG_S3C2410替换成CONFIG_S3C2440，将CONFIG_SMDK2410替换成CONFIG_MYFF2440 在ubuntu的根目录下，执行 1find .|xargs grep -ri "CONFIG_S3C2410" -l 会列出包含CONFIG_S3C2410的文件，将其替换， 同理执行： 1find .|xargs grep -ri &quot;CONFIG_SMDK2410&quot; -l 也将其替换 编译调试经过上面这几个步骤我们执行如下命令： 在u-boot-2009.11的顶层目录， 1make MyFF2440_config&amp;&amp;make 不出意外的话，就可以顺利生成u-boot.bin文件，烧进板子里面nor 启动，串口就能正常输出 注意我们在注释的时候尽量使用“/**/”符号，不要用“//”,因为有些交叉编译器不识别单行注释 ​]]></content>
      <categories>
        <category>uboot移植</category>
      </categories>
      <tags>
        <tag>移植</tag>
        <tag>arm</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Qt5移植4412时汉字及颜色显示]]></title>
    <url>%2F2018%2F06%2F08%2FQt%2BARM_fontsandcolor%2F</url>
    <content type="text"><![CDATA[我们只要将在csdn下载几个中文字库，放到arm板子的lib/fonts/里面就可一完美支持汉字了 参考文章:Qt5在Arm板上中文的显示问题 步骤在csdn下载中文字库链接地址 移到arm板子的/opt/qt5.7.0/lib/fonts(这是我的板子对应的qt的路径)下面设置库路径我们进入到板子系统的/etc/profile下面添加 12：export QTDIR=(字体所在路径) ：export QT_QWS_FONTDIR=$QTDIR/lib/fonts。（这个是字体所在的具体路径） 幸运的话 ，此时就可以显示汉字了，但是有些qt的控件仍然不支持汉字，则需要下面的转换例如： 123ui-&gt;label-&gt;setText("中文字体");改成ui-&gt;label-&gt;setText(QObject::trUtf8("中文字体"); 在运行程序时的可选参数程序启动命令选项：-fn 定义程序的字体 -bg 设置程序默认背景颜色 例如./myapplication -bg blue，颜色名称必须能被QColor类构造函数识别 -btn 设置默认的按钮颜色，例如./myapplication -btn green 同样颜色必须被认识 -fg 设置foreground颜色，例如./myapplication -fg ‘dark blue’ 同上需被认识 -name 设置应用程序名字 例如./myapplication -name texteditapplication -title 设置应用程序标题。./myapplication -title ‘Text Edit’ -geometry x++设置窗口大小， ./myapplication -geometry 300x200+50+50 -keyboard 启动键盘 -nokeyboard 关闭键盘 -mouse 启动鼠标 -nomouse 关闭鼠标 -qws 设置为服务程序 -display 设置显示器驱动 -decoration]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>移植</tag>
        <tag>Qt</tag>
        <tag>4412</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JZ2440的uboot-2009-11 移植]]></title>
    <url>%2F2018%2F06%2F05%2FJZ2440_uboot_2009_11_transplant_1%2F</url>
    <content type="text"><![CDATA[整理下自己之前的移植uboot时记录的笔记！ 移植环境：arm板子：JZ2440 uboot版本：2009-11 交叉编译链：arm-none-linux-gcc-4.4.3 下载：uboot官方下载地址:uboot官方下载, 交叉编译链:github.com/funful/Tools uboot的启动流程第一阶段 硬件设备初始化 加载u-boot第二阶段代码到RAM的空间 设置好栈 跳转到第二阶段的代码入口 第二阶段 初始化本阶段所使用的硬件设备 检测系统内存映射 将内核从Flash读取到RAM中 为内核设置启动参数 调用内核 建立2440的配置uboot-2009-11和之前的版本相比，有一点变化，我们在u-boot-2016.09/configs 可以看到各种板级支持配置，由于2440和2410相差不大，所以我们根据2410，来添加2440的配置 修改根目录的Makefile123#设置股下面两个变量ARCH = armCROSS_COMPILE = arm-none-linux-gnueabi- 添加my2440配置文件新建配置文件1cp u-boot-2016.05/configs/smdk2410_defconfig u-boot-2016.05/configs/my2440_defconfig 上面这条命令新建了my2440的板子配置 修改1gedit u-boot-2016.05/configs/my2440_defconfig 改动前后的内容如下:123456789101112131415161718192021222324改动前： CONFIG_ARM=y CONFIG_TARGET_SMDK2410=y CONFIG_HUSH_PARSER=y CONFIG_SYS_PROMPT="SMDK2410 # " CONFIG_CMD_USB=y # CONFIG_CMD_SETEXPR is not set CONFIG_CMD_DHCP=y CONFIG_CMD_PING=y CONFIG_CMD_CACHE=y CONFIG_CMD_EXT2=y CONFIG_CMD_FAT=y改动后： CONFIG_ARM=y CONFIG_TARGET_MY2440=y CONFIG_HUSH_PARSER=y CONFIG_SYS_PROMPT="MY2440 # " #修改成我们自己板子名称 CONFIG_CMD_USB=y # CONFIG_CMD_SETEXPR is not set CONFIG_CMD_DHCP=y CONFIG_CMD_PING=y CONFIG_CMD_CACHE=y CONFIG_CMD_EXT2=y CONFIG_CMD_FAT=y 添加my2440板级支持文件上一个步骤我们已经添加了配置文件，下面我们来添加支持文件，让编译器通过.UBoot源码中大部分和板子相关的代码在board目录下 新建板级支持.c文件1cp -rf u-boot-2016.05/board/samsung/smdk2410/ u-boot-2016.05/board/samsung/my2440/ 将板级支持文件和板级配置文件关联 1gedit u-boot-2016.05/arch/arm/Kconfig 找到2410的配置，来在下面添加2440配置 123456789101112在：config TARGET_SMDK2410 bool "Support smdk2410" select CPU_ARM920T添加： #注意Kconfig的语法，需要使用[Tab]键，缩进config TARGET_MY2440 bool "Support my2440" select CPU_ARM920T在：source "board/samsung/smdk2410/Kconfig"添加：source "board/samsung/myff2440/Kconfig" 修改板级支持文件夹里的Kconfig 12345678910111213141516171819202122232425gedit u-boot-2016.05/board/samsung/my2440/Kconfig配置文件打开后，可以看到很多配置还都是smdk2410的配置:if TARGET_SMDK2410config SYS_BOARD default "smdk2410"config SYS_VENDOR default "samsung"config SYS_SOC default "s3c24x0"config SYS_CONFIG_NAME default "smdk2410"endif修改为：if TARGET_MYFF2440config SYS_BOARD default "myff2440"config SYS_VENDOR default "samsung"config SYS_SOC default "s3c24x0"config SYS_CONFIG_NAME default "myff2440"endif 修改板级支持文件名字1mv u-boot-2016.05/board/samsung/my2440/smdk2410.c u-boot-2016.05/board/samsung/my2440/my2440.c 修改板级支持文件夹里的my2440.c123456gedit u-boot-2016.05/board/samsung/my2440/my2440.c打开后搜索: SMDK2410将 gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2410; 该为： gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_MINI2440; 这里板子底层初始化部分先暂时使用MINI2440板子的参数配置，目的先是为了编译能通过。 修改板级支持文件夹里的Makefile1234567gedit u-boot-2016.05/board/samsung/my2440/Makefile修改前： obj-y := smdk2410.o obj-y += lowlevel_init.o修改后： obj-y:= my2440.o obj-y += lowlevel_init.o 修改my2440.c的头文件 添加my2440的头文件 12cp u-boot-2016.05/include/configs/smdk2410.hu-boot-2016.05/include/configs/my2440.h 123456789gedit u-boot-2016.05/include/configs/my2440.h修改前： #define CONFIG_S3C24X0 /* This is a SAMSUNG S3C24x0-type SoC */ #define CONFIG_S3C2410 /* specifically a SAMSUNG S3C2410 SoC */ #define CONFIG_SMDK2410 /* on a SAMSUNG SMDK2410 Board */修改后： #define CONFIG_S3C24X0 /* This is a SAMSUNG S3C24x0-type SoC */ #define CONFIG_S3C2440/* specifically a SAMSUNG S3C2440 SoC */ #define CONFIG_MY2440/* on custom my2440 Board */ 编译调试 进入源码目录,cd u-boot-2016.09-11 在编译前先清空一次目录,sudo make distclean 修改编译配置,make my2440_config make sudo make 不出意外的话，就能顺利通过，如果没有通过的话，我们可以看看根目录下的.config文件的配置是够正确 ​]]></content>
      <categories>
        <category>uboot移植</category>
      </categories>
      <tags>
        <tag>移植</tag>
        <tag>arm</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux + Qt 移植 Mplayer]]></title>
    <url>%2F2018%2F05%2F25%2Flinux%2BQt_c_conplicationMplayer%2F</url>
    <content type="text"><![CDATA[参考文章:Tiny4412开发板Mplayer 移植 迅为4412的linux和Qt 移植Mplayer！ 步骤解压MPlayer-1.0rc2.tar.bz2进入该目录 执行12345678910111213141516171819sudo ./configure --host-cc=/usr/bin/gcc \ --cc=/usr/share/arm/4.3.2/bin/arm-linux-gcc-4.3.2 \ --target=arm-linux \ --enable-static \ --disable-win32dll\ --disable-dvdread \ --disable-dvdread-internal \ --disable-dvdnav\ --disable-libdvdcss-internal \ --enable-fbdev \ --disable-mencoder \ --disable-live\ --disable-mp3lib \ --enable-mad\ --enable-libavcodec_a \ --disable-live \ --disable-ivtv \ --prefix=/usr/share/arm/Mplayer_Ku/\ 成功之后 执行 make 然后 123456789101112131415161718make install --target=arm-linux \--enable-static \--disable-win32dll \--disable-dvdread \--disable-dvdread-internal\--disable-dvdnav \--disable-libdvdcss-internal \--enable-fbdev \--disable-mencoder\--disable-live \--disable-mp3lib\ --enable-mad \--enable-libavcodec_a \--disable-live \--disable-ivtv \--prefix=/usr/share/arm/Mplayer_Ku \--with-extraincdir=/usr/local/lib/mad_arm/include \--with-extralibdir=/usr/local/lib/mad_arm/lib\ 进入前面自己定义的库路径12cd /usr/share/arm/Mplayer_ku/bin arm-linux-readelf -h mplayer 可以看到生成的mplayer文件是ARM下的 ELF32 然后将mplayer移到arm板子上面，并且将相应的动态库移到ARM下的lib 错误及解决 在libmpeg2/motion_comp_arm_s.S文件前面添加 1234#ifndef HAVE_PLD.macro pld reg.endm#endif make失败 提示 find -lmad```1234567891011接下来要把libmad的安装一下 ，参考文章[libmad的移植、交叉编译、安装——基于ubuntu16](https://blog.csdn.net/seven159/article/details/72614293)安装完成之后继续make3. make install 失败（错误代码）：```cstrip: Unable to recognise the format of the input file `/usr/share/arm/Mplayer_Ku/bin/mplayer&apos;install: strip process terminated abnormallyMakefile:256: recipe for target &apos;install-mplayer&apos; failed 解决方案 : 进入到Makefile 的256行 在256行上面一行添加 1INSTALLSTRIP := 因为**INSTALLSTRIP 的默认参数是-s 我们需要将其置为空 ​]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>移植</tag>
        <tag>Qt</tag>
        <tag>Mplayer</tag>
      </tags>
  </entry>
</search>
