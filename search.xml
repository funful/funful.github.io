<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>全志A64编译固件报Fault</title>
    <url>/2019/10/19/2019-10-19-%E5%85%A8%E5%BF%97A64%E7%BC%96%E8%AF%91%E5%9B%BA%E4%BB%B6%E6%8A%A5Fault/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>Ubuntu： Ubuntu 19.04</li>
<li>固件： 全志CQA64-LinuxQT</li>
<li>arm交叉编译器：crosstool-NG linaro-1.13.1-4.9-2014.09 - Linaro GCC 4.9-2014.09</li>
<li>时间：19-10-2019</li>
</ul>
<h2 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h2><ul>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">freadahead.c: In function 'freadahead':</span><br><span class="line">freadahead.c:<span class="number">92</span>:<span class="number">3</span>: error: <span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread, ungetc on your system, then report this to bug-gnulib."</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">error</span> <span class="meta-string">"Please port gnulib freadahead.c to your platform! Look at the definition of fflush, fread, ungetc on your system, then report this to bug-gnulib."</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ul>
<li><p>进入host-m4-1.4.18/lib中，对fflush.c，fpending.c，fpurge.c，freadahead.c，freading.c，fseeko.c中”_IO_ftrylockfile“ 替换为“_IO_EOF_SEEN”</p>
</li>
<li><p>进入host-m4-1.4.18/lib中，对stdio-impl.h中添加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+<span class="comment">/* Glibc 2.28 made _IO_IN_BACKUP private.  For now, work around this</span></span><br><span class="line"><span class="comment">+   problem by defining it ourselves.  <span class="doctag">FIXME:</span> Do not rely on glibc</span></span><br><span class="line"><span class="comment">+   internals.  */</span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">if</span> !defined _IO_IN_BACKUP &amp;&amp; defined _IO_EOF_SEEN</span></span><br><span class="line">+<span class="meta"># <span class="meta-keyword">define</span> _IO_IN_BACKUP 0x100</span></span><br><span class="line">+<span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>参考Patch：<a href="http://git.openembedded.org/openembedded-core/tree/meta/recipes-devtools/m4/m4/m4-1.4.18-glibc-change-work-around.patch" target="_blank" rel="noopener">m4.patch</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>BUG调试</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C内嵌ARM汇编</title>
    <url>/2019/08/24/2019-08-24-C-Assembly/</url>
    <content><![CDATA[<p>汇编语言经常会用在启动引导文件中，设置好相应的堆栈和必要的功能外设，才会跳转到C入口，但是我们只是知道汇编指令的功能，看不到每一步的具体实现。下面通过C语言内嵌汇编，做一些简单的例子。</p>
<a id="more"></a>

<h1 id="C语言内嵌汇编基本格式"><a href="#C语言内嵌汇编基本格式" class="headerlink" title="C语言内嵌汇编基本格式"></a>C语言内嵌汇编基本格式</h1><p>C语言内嵌汇编有两种基本格式，volatile表明编译其不要优化代码，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__asm__ __volatile__(</span><br><span class="line">	<span class="string">"xxxxxxxxxxxx\n"</span>   ；指令<span class="number">1</span> 用“\n”换行</span><br><span class="line">	<span class="string">"xxxxxxxxxxxx\n"</span>   ；指令<span class="number">2</span> 用“\n”换行</span><br><span class="line">	<span class="string">"xxxxxxxxxxxx\n"</span>   ；指令<span class="number">3</span> 用“\n”换行</span><br><span class="line">	：声明输出或输入变量；“=&amp;r” 输出变量；“+r”输入输出变量</span><br><span class="line">	：声明输入变量 ； “r” 输入变量</span><br><span class="line">	：声明保护寄存器；“r0”  。。。。</span><br><span class="line">);</span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"xxxxxxxxxxxx\n"</span>   ；指令<span class="number">1</span> 用“\n”换行</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"xxxxxxxxxxxx\n"</span>   ；指令<span class="number">2</span> 用“\n”换行</span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="string">"xxxxxxxxxxxx\n"</span>   ；指令<span class="number">3</span> 用“\n”换行</span></span></span><br><span class="line"><span class="function"><span class="params">	：声明输出或输入变量；“=&amp;r” 输出变量；“+r”输入输出变量</span></span></span><br><span class="line"><span class="function"><span class="params">	：声明输入变量 ； “r” 输入变量</span></span></span><br><span class="line"><span class="function"><span class="params">	：声明保护寄存器；“r0”  。。。。</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"> int main()&#123;</span><br><span class="line">   unsigned int register a asm(&quot;r5&quot;);</span><br><span class="line"> </span><br><span class="line">   printf(&quot;a = %d\r\n&quot;,a);</span><br><span class="line">   __asm__ __volatile__(</span><br><span class="line">        &quot;mov r5,#100\n&quot;</span><br><span class="line">         :</span><br><span class="line">         :</span><br><span class="line">         :&quot;r5&quot;</span><br><span class="line">                   );</span><br><span class="line"> </span><br><span class="line">  printf(&quot;a = %d\r\n&quot;,a);</span><br><span class="line"> return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上面简单例子是将a变量和r5通用寄存器进行绑定，在内嵌汇编里面对r5寄存器操作a的值也会相应改变</p>
<h1 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> #include &lt;stdlib.h&gt;</span><br><span class="line"> </span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">   unsigned int a=1, b=2,c=3;</span><br><span class="line">   int d,e,f;</span><br><span class="line">    __asm__ __volatile__(</span><br><span class="line">            &quot;mov r0, %[a]\n&quot;</span><br><span class="line">            &quot;mov r1, %[b]\n&quot;</span><br><span class="line">            &quot;mov r2, %[c]\n&quot;</span><br><span class="line"></span><br><span class="line">           &quot;mov %[d], r0\n&quot;</span><br><span class="line">           &quot;mov %[e], r1\n&quot;</span><br><span class="line">            &quot;mov %[f], r2\n&quot;</span><br><span class="line">            :[d]&quot;=&amp;r&quot;(d),[e]&quot;=&amp;r&quot;(e),[f]&quot;=&amp;r&quot;(f)</span><br><span class="line">            :[a]&quot;r&quot;(a),[b]&quot;r&quot;(b),[c]&quot;r&quot;(c)</span><br><span class="line">            :&quot;r0&quot;,&quot;r1&quot;,&quot;r2&quot;</span><br><span class="line">                    );</span><br><span class="line">    printf(&quot;d = %d\r\n&quot;,d);</span><br><span class="line">    printf(&quot;e = %d\r\n&quot;,e);</span><br><span class="line">    printf(&quot;f = %d\r\n&quot;,f);</span><br><span class="line">    return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>上面内嵌汇编的功能就是将变量a,b,c的值赋值给变量d，e，f。第一个冒号后面将C函数的变量声明为输出变量名且别名位%[d] %[e]%[f]。也可以使用默认的%0 %1 依次对C函数的变量进行操作</p>
<h1 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="function"><span class="keyword">int</span>   <span class="title">mysum</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  sum1,sum2;</span><br><span class="line">         __asm__ __volatile__(</span><br><span class="line">              <span class="string">"ldr r0 ,=0xfffffff8\n"</span></span><br><span class="line">              <span class="string">"ldr r1 ,=0xa\n"</span></span><br><span class="line">               <span class="string">"adds %[sum1] ,r0,r1\n"</span></span><br><span class="line">               <span class="string">"ldr r0, =1\n"</span></span><br><span class="line">               <span class="string">"ldr r1, =1\n"</span></span><br><span class="line">               <span class="string">"adc %[sum2],r0,r1\n"</span></span><br><span class="line">                :[sum1]<span class="string">"=&amp;r"</span>(sum1),[sum2]<span class="string">"=&amp;r"</span>(sum2)</span><br><span class="line">                :[num1]<span class="string">"r"</span>(num1),[num2]<span class="string">"r"</span>(num2)</span><br><span class="line">                :<span class="string">"r0"</span>,<span class="string">"r1"</span></span><br><span class="line">                  );</span><br><span class="line"></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">"sum1 = %ld\n"</span>,sum1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sum2 = %ld\n"</span>,sum2);</span><br><span class="line">       <span class="keyword">return</span> sum2;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> a=<span class="number">0xfffffff4</span> ,b =<span class="number">0x11</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"sum =a+b= %ld\r\n"</span>,mysum(a,b));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子是add指令的使用，add是基础的加指令，CSPR_C不会产生进位结合借位。adds会产生CSPR_C不会产生进位结合借位。adc在相加的时候会将CSPR_C的位相加。</p>
<p>这里ldr是一个伪指令：ldr可以将任意值赋值给寄存器。在这里mov指令需要满足三个条件中的一个才能使用：</p>
<ol>
<li>立即数小于255 ； eg：mov r0 ，254</li>
<li>立即数右移偶数次小于255 ； eg： mov r0 ，0xf100 ； 0xff00右移8位，0xf1小于0xff，</li>
<li>立即数是特殊值；0xfffffff</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里举的例子都是比较简单的，虽然汇编使用不多，但是在能看懂汇编语言我们才可以在其基础上修改，例如堆栈的大小和基地址。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QEMU</tag>
        <tag>ARM汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>QEMU模拟AMRM-A9（tftp挂载kenel，nfs挂载rotfs）</title>
    <url>/2019/07/30/2019-07-30-QEMU-ARM-A9-TFTP-NFS/</url>
    <content><![CDATA[<p>初次接触linux系统是使用的2440的板子，跟着韦东山老师学习了uboot kernel 和文件系统，也算是入门了，后面又使用4412板子做了一些应用层的项目。但是底层的uboot和内核和文件系统都是在厂商的支持下，做的较为简单二次开发。已经毕业一个月了，业余时间太多，想好好学学驱动层的东西，但是苦于刚毕业，所以准备采用qemu模拟出arm的开发环境，这样我们只用关注软件层面。</p>
<a id="more"></a>

<h1 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h1><ul>
<li>Ubuntu：Ubuntu 19.04</li>
<li>qemu： QEMU emulator version 3.1.0 </li>
<li>arm交叉编译器：gcc version 4.8.3 20140320 </li>
</ul>
<h1 id="QEMU简介"><a href="#QEMU简介" class="headerlink" title="QEMU简介"></a>QEMU简介</h1><h1 id="Ubuntu安装qemu-system-arm"><a href="#Ubuntu安装qemu-system-arm" class="headerlink" title="Ubuntu安装qemu-system-arm"></a>Ubuntu安装qemu-system-arm</h1><p>这里有两种方法：</p>
<h2 id="系统提供的源安装："><a href="#系统提供的源安装：" class="headerlink" title="系统提供的源安装："></a>系统提供的源安装：</h2><p>在ubuntu的Terminal下输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install qemu</span><br><span class="line">sudo apt-get install qemu-system-arm</span><br><span class="line">安装完之后：qemu-system-arm  -version 查看qemu版本</span><br></pre></td></tr></table></figure>

<p>  使用ubuntn16版本的时候，使用第一个命令安装就可以，但是使用Ubuntu19.04时，使用第一个命令安装完，搜索不到qemu-system-arm这个命令，还需要使用第二个命令安装。使用系统的源安装可以解决库依赖的问题。</p>
<h2 id="源文件编译安装："><a href="#源文件编译安装：" class="headerlink" title="源文件编译安装："></a>源文件编译安装：</h2><p>使用源文件安装我们需要使用git 将工程clone到本地（如果没有git的话，需要先去官网注册，然后在Ubuntu安装，配置等），安装之前还需要解决QEMU编译依赖的包，也可以在安装的过程中根据缺少的库依次安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">下载源码：sudo git clone git://git.qemu.org/qemu.git</span><br><span class="line">可以使用git命令切换到稳定版本：git checkout  xxxx</span><br><span class="line">编译配置 ./configure (可以使用 ./configure -help 查看支持的参数)</span><br><span class="line">安装:  make &amp;&amp; make install (不出意外的话可以成功安装)</span><br></pre></td></tr></table></figure>

<p>比较这个两种方法可以知道，第二种虽然比较复杂，但是灵活度更高，可以配置参数。第一种安装简单。</p>
<p>在启动uboot之前，我们还需要安装arm的交叉编译器，这里推荐不要用太老，也不要用太新的编译器（个人建议，以为有时候uboot kernel和文件系统会因为交叉编译器太老启动失败），可以直接去CodeSourcery  Linaro   或者别的官网下载源码。</p>
<h1 id="qemu-system-arm启动uboot"><a href="#qemu-system-arm启动uboot" class="headerlink" title="qemu-system-arm启动uboot"></a>qemu-system-arm启动uboot</h1><p>下载uboot源码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.在浏览器下载：https://ftp.denx.de/pub/u-boot/</span><br><span class="line">2.wget命令下载：wget  https://ftp.denx.de/pub/u-boot/u-boot-xxxxx.tar.bz2（版本自己选择）</span><br></pre></td></tr></table></figure>

<p>检测arm交叉编译器是否安装成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arm-none-linux-gnueabi-gcc  -v</span><br></pre></td></tr></table></figure>

<p>这里我自己编译一个简单的脚本 配置生成uboot</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash </span><br><span class="line">export ARCH=arm        #指定编译生成架构 ，也可以在uboot根目录的Makefile修改</span><br><span class="line">export CROSS_COMPILE=arm-none-linux-gnueabi- #指定编译生成的交叉编译链，也可以在uboot根目录的Makefile修改</span><br><span class="line">make vexpress_ca9x4_defconfig   #编译我们要生成平台u-boot.bin的配置文件，在uboot根目录下会生成.config文件（主要有点，ls -al 才能看到）。另外make menuconfig图形化配置也会最终修改.config文件里面的内容。也可以直接修改.config</span><br><span class="line">source /etc/profile   #我将交叉编译链的环境变量添加到profile文件里面。以防万一，让其生效</span><br><span class="line">make          #生成</span><br></pre></td></tr></table></figure>

<p>执行成功之后会看到生成u-boot u-boot.bin等文件，使用以下命令可以核对生成文件的架f构：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">file u-boot</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.funful.ink/2019-7-30-1.png" alt></p>
<p>qemu启动uboot脚本（注意给脚本权限）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"> #</span>!/bin/sh</span><br><span class="line">qemu-system-arm  \</span><br><span class="line">         -M  vexpress-a9 \  #指定开发板</span><br><span class="line">         -m 512M \          #内存</span><br><span class="line">         -nographic  \      #不使用LCD屏，即使用当前Terminal</span><br><span class="line">         -kernel  /home/linux/armuboot/u-boot-2017.05/u-boot \</span><br></pre></td></tr></table></figure>

<p>uboot有一个循环的命令解释器，在启动3秒内（时间可设置），按任意键即可进入。</p>
<p><img src="http://cdn.funful.ink/2019-7-30-2.png" alt></p>
<p>可以在3秒内进入uboot的终端解释器，使用print打印当前的环境变量</p>
<p><img src="http://cdn.funful.ink/2019-7-30-3.png" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print     #打印当前变量</span><br><span class="line">serenv    #设置环境变量</span><br><span class="line">saveenv   #保存环境变量到flash</span><br></pre></td></tr></table></figure>

<p>这里uboot已经启动成功，下面我们使用uboot加载kernel，如果有板子的话一般都是通过下载到板子里面然后再启动，但是这样子比较浪费时间，这里我们采用tftp网口下载直接运行的方式运行kernel。</p>
<h1 id="uboot引导kernel-rootfs"><a href="#uboot引导kernel-rootfs" class="headerlink" title="uboot引导kernel+rootfs"></a>uboot引导kernel+rootfs</h1><p>在uboot初始化完成之后会将需要传给内核的参数放到一段内存空间，然后运行内核 文件系统，内核会从这段空间取相应的信息MachineID bootargs console等等信息(个人理解，如果不正确Email联系)</p>
<h2 id="tftp加载kernel"><a href="#tftp加载kernel" class="headerlink" title="tftp加载kernel"></a>tftp加载kernel</h2><p>uboot通过以太网从ftp服务器获得kernel的uImage，所以我们在使用虚拟机Ubuntu系统要和qemu位于同一个网段，这里将Ubuntu设置位NAT模式。创建一个网桥，将ubuntu和qemu的网卡都连接到网桥。uImage和zImage的区别是uImage压缩过，解压之后uImage和zImage几乎相同。之前分析uboot的uboot代码的时候只支持uImage启动，但是可以通过修改uboot代码支持启动zImage，也不难。tftp加载kernel的原理就是在Ubuntu安装tftp服务器，uboot会从tftp下载内核。下面分步进行操作：</p>
<ol>
<li><p>创建网桥和qemu的虚拟网卡tap0</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">安装工具包：apt-get install uml-utilities bridge-utils</span><br><span class="line"></span><br><span class="line">修改/etc/network/interfaces文件：</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">auto tap0</span><br><span class="line">auto ens33</span><br><span class="line">auto tap0</span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet dhcp</span><br><span class="line"> bridge_ports all tap0</span><br><span class="line">重启，使用nmcli可以看到添加到的br0桥</span><br><span class="line">添加tap0网卡，并将网卡连接到br0：</span><br><span class="line"> tunctl -t tap0 -u root</span><br><span class="line"> brctl addif br0 tap0</span><br><span class="line"> ifconfig tap0 0.0.0.0  promisc up</span><br><span class="line">配置之后重启网络： service networking  restart</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装tftp服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> apt-get install tftp-hpa tftpd-hpa xinetd</span><br><span class="line"> 修改配置文件:/etc/default/tftpd-hpa :</span><br><span class="line"> TFTP_USERNAME="tftp"</span><br><span class="line">TFTP_DIRECTORY="/home/linux/tftpboot"    #这个是我们创建的tftp服务器存放文件路径，权限：0777</span><br><span class="line">TFTP_ADDRESS="0.0.0.0:69"</span><br><span class="line">TFTP_OPTIONS="-l -c -s"</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译内核：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">下载linux源码：https://mirrors.edge.kernel.org/pub/linux/kernel/</span><br><span class="line">进入源码根目录的Makefile：修改ARCH和CROSS_COMPILE</span><br><span class="line">ARCH  ？=arm</span><br><span class="line">CROSS_COMPILE？=arm-none-linux-gnueabi-</span><br><span class="line">执行配置文件：make vexpress_defconfig （linux-5.2/arch/arm/configs 里面放的各种板子支持的配置文件）</span><br><span class="line">使用图形配置kernel支持nfs和tftp：</span><br><span class="line">  make  menuconfig</span><br><span class="line">安装生成： make LOADADDR=0x60003000 uImage -j6 # (-j6是多线程执行)</span><br></pre></td></tr></table></figure>
</li>
<li><p>qemu的启动脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> qemu-system-arm \</span><br><span class="line">-M vexpress-a9 \</span><br><span class="line">-kernel /home/linux/armuboot/u-boot-2017.05/u-boot \</span><br><span class="line">-nographic \</span><br><span class="line">-m 512M \</span><br><span class="line">-net nic \</span><br><span class="line">-net tap,ifname=tap0</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="5">
<li><p>加载内核</p>
<ol>
<li><p>手动加载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在手动加载之前需要重启系统，并且确保tap0连接到br0网桥，使用nmcli命令查看br0的IP</span><br><span class="line">执行4步骤的脚本，在3秒内，任意键进入终端执行如下命令：</span><br><span class="line">setenv IPADDR 192.168.5.126</span><br><span class="line">setenv SERVERIP 192.168.5.128 #这里的IP是br0的IP</span><br><span class="line">tftp   0x60003000 uImage  #将tftp的路径下的uImage下载到0x60003000地址</span><br><span class="line">bootm  0x60003000   #手动启动内核</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动加载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">进入uboot根目录 打开vim include/configs/vexpress_common.h</span><br><span class="line">修改如下：</span><br><span class="line"><span class="meta">#</span>define CONFIG_BOOTCOMMAND "tftp 0x60003000 uImage;tftp 0x60500000 vexpress-v2p-ca9.dtb; setenv bootargs 'root=/dev/mmcblk0  console=ttyAMA0';bootm 0x60003000 - 0x60500000;"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>define CONFIG_IPADDR 192.168.5.126 </span><br><span class="line"><span class="meta">#</span>define CONFIG_NETMASK 255.255.255.0</span><br><span class="line"><span class="meta">#</span>define CONFIG_SERVERIP 192.168.5.139</span><br><span class="line">执行4步骤的脚本，会相继看到下面两个过程</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.funful.ink/2019-7-30-4.png" alt></p>
<p><img src="http://cdn.funful.ink/2019-7-30-5.png" alt></p>
</li>
</ol>
</li>
</ol>
<h2 id="nfs加载rootfs"><a href="#nfs加载rootfs" class="headerlink" title="nfs加载rootfs"></a>nfs加载rootfs</h2><p>上面已经成功启动内核，但是还需要文件系统的支持才能进入命令行终端，可以使用busybox工具创建，可以参考网上教程。这里可以使用两种方式挂载rootfs，但是为了使用方便，我们通过nfs挂载，便于后续的开发调试。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">安装：</span><br><span class="line">sudo apt-get install nfs-kernel-server</span><br><span class="line">配置：</span><br><span class="line">在/etc/exports文件中添加：</span><br><span class="line">/home/linux/armsystem/rootfs *(rw,sync,no_root_squash,no_subtree_check)</span><br><span class="line">保存</span><br><span class="line">重启服务：</span><br><span class="line">service rpcbind restart</span><br><span class="line">service nfs-kernel-server restart</span><br><span class="line">进入uboot的根目录修改文件：</span><br><span class="line">vim  include/configs/vexpress_common.h</span><br><span class="line"><span class="meta"> #</span>define CONFIG_BOOTCOMMAND "tftp 0x60003000 uImage;tftp 0x60500000 vexpress    -v2p-ca9.dtb; setenv bootargs 'root=/dev/nfs rw nfsroot=192.168.5.140:/home/    linux/armsystem/rootfs ip=192.168.5.126:192.168.5.140:255.255.255.0:eh0:off     init=/linuxrc  console=ttyAMA0';bootm 0x60003000 - 0x60500000;"</span><br><span class="line"><span class="meta"> #</span>define CONFIG_IPADDR 192.168.5.126 </span><br><span class="line"><span class="meta"> #</span>define CONFIG_NETMASK 255.255.255.0</span><br><span class="line"><span class="meta"> #</span>define CONFIG_SERVERIP 192.168.5.140</span><br><span class="line">重新编译uboot</span><br><span class="line">执行上一节4步骤脚本</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.funful.ink/2019-7-31-1.png" alt></p>
<p>到此整个环境就搭建完成了。期间会遇见很多不可知的错误，慢慢研究就肯定能搞明白。</p>
<p>#nfs挂载一直失败</p>
<p>使用nfs挂在文件系统的时候，前面搭建一切顺利，但就是挂载不上去的原因就是较新版本的Ubuntu系统，只支持nfs协议3和协议4，但是uboot只支持nfs协议2，所以需要修改Ubuntu的配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim  /etc/default/nfs-kernel-server</span><br><span class="line">尾行添加：RPCNFSDOPTS=&quot;--nfs-version 2,3,4 --debug --syslog&quot; </span><br><span class="line">保存，重启nfs即可</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用qemu模拟arm有利也有弊，我们不能真正的点亮LED灯，但是对于学习内核驱动，不用关注硬件，将会有更多的时间学习驱动。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title>Video for Linux two</title>
    <url>/2019/05/25/2019-05-25-V4L2/</url>
    <content><![CDATA[<p>Linux操作系统内核的采用的是V4L2视频设备内核驱动。该框架是在V4L的基础上进行扩展升级。视频的采集使用流水线的方式传输，通过使用V4L2的视频采集框架流程，在内核空间申请出缓存，在主线程下，图像的每一帧都向缓存空间传输。</p>
<a id="more"></a>

<h1 id="V4L2（Video-for-Linux-two-）流程"><a href="#V4L2（Video-for-Linux-two-）流程" class="headerlink" title="V4L2（Video for Linux two ）流程"></a>V4L2（Video for Linux two ）流程</h1><p>在将QT+opencv 移植到Arm上面的时候发现不能直接用QT或者是Opencv提供的库函数进行视频采集，从网上查得发现，还需要将GTK的库也移植到板子上去，好像实施的可能性不大，（网上说的非常复杂，并且得不偿失），这里可以使用V4l2 ，他给linux下的视频设备提供了一套接口规范。从Linux2.5之后都默认有这个开发接口。（可以看下/usr/include/linux/下面是否有videodev2.h）</p>
<p>可以在V4L2官网下载英文版的手册</p>
<p>CSDN 有中文版的</p>
<p>下面的我们需要常用的结构体和宏在进行了总结，都可以在</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">/usr/include/linux/videodev.h</span><br></pre></td></tr></table></figure>

<p>查找的到</p>
<ul>
<li>V4L2的常用结构体介绍()</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span>        //申请帧缓冲，对应命令<span class="title">VIDIOC_REQBUFS</span> </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">v4l2_capability</span>        //视频设备的功能，对应命令<span class="title">VIDIOC_QUERYCAP</span>  <span class="title">struct</span> <span class="title">v4l2_input</span>        //视频输入信息，对应命令<span class="title">VIDIOC_ENUMINPUT</span></span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">v4l2_standard</span>        //视频的制式，比如<span class="title">PAL</span>，<span class="title">NTSC</span>，对应命令                                                            <span class="title">VIDIOC_ENUMSTD</span> </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">v4l2format</span>       //帧的格式，对应命令<span class="title">VIDIOC_GFMT</span>、<span class="title">VIDIOC_S_FMT</span>等</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">v4l2_buffer</span>        //驱动中的一帧图像缓存，对应命令<span class="title">VIDIOC_QUERYBUF</span> </span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">v4l2_crop</span>        //视频信号矩形边框</span></span><br><span class="line"><span class="class"><span class="title">v4l2_std_id</span>        //视频制式</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>V4L2常用的宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VIDIOC_REQBUFS <span class="comment">//分配内存 </span></span><br><span class="line">VIDIOC_QUERYBUF         <span class="comment">//把VIDIOC_REQBUFS中分配的数据缓存转换成物理地址 </span></span><br><span class="line">VIDIOC_QUERYCAP        <span class="comment">//查询驱动功能 </span></span><br><span class="line">VIDIOC_ENUM_FMT        <span class="comment">//获取当前驱动支持的视频格式 </span></span><br><span class="line">VIDIOC_S_FMT        <span class="comment">//设置当前驱动的频捕获格式 </span></span><br><span class="line">VIDIOC_G_FMT        <span class="comment">//读取当前驱动的频捕获格式 </span></span><br><span class="line">VIDIOC_TRY_FMT        <span class="comment">//验证当前驱动的显示格式 </span></span><br><span class="line">VIDIOC_CROPCAP        <span class="comment">//查询驱动的修剪能力 </span></span><br><span class="line">VIDIOC_S_CROP        <span class="comment">//设置视频信号的矩形边框 </span></span><br><span class="line">VIDIOC_G_CROP        <span class="comment">//读取视频信号的矩形边框</span></span><br><span class="line">VIDIOC_QBUF        <span class="comment">//把数据从缓存中读取出来 </span></span><br><span class="line">VIDIOC_DQBUF        <span class="comment">//把数据放回缓存队列 </span></span><br><span class="line">VIDIOC_STREAMON        <span class="comment">//开始视频显示函数 </span></span><br><span class="line">VIDIOC_STREAMOFF        <span class="comment">//结束视频显示函数 </span></span><br><span class="line">VIDIOC_QUERYSTD         <span class="comment">//检查当前视频设备支持的标准，例如PAL或NTSC。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>看了网上好多博主写的对V4L2的流程分析，总结了下，先理清楚流程，然后再进行代码的更改和搬移（这个流程是基于视频的采集）</p>
<ul>
<li><p>打开设备文件/dev/video* ，linux下一切皆文件。open函数提供了阻塞/非阻塞的方式进行打开，</p>
</li>
<li><p>打开这个文件之后，我们就要看看，这个文件有什么功能 ，视频输入，采集，音频输入输出等。</p>
</li>
<li><p>视频信号帧的裁剪，这里涉及到两个结构体</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct v4l2_crop        //视频信号矩形边框</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct v4l2_cropcap   //可裁剪区域描述</span><br></pre></td></tr></table></figure>

<p>v4l2_cropcap 这个结构体就是限定了，我们可以裁剪的区域范围大小</p>
<p>我们通过对结构体v4l2_crop，赋值，来进行裁剪 </p>
</li>
<li><p>重新设置帧的格式包括，宽度和高度等</p>
</li>
<li><p>接下来就是我们需要对帧缓冲区和内存进行分配，因为在驱动模块用户空间和内核空间是分开的，我们如果需要读取内核空间的内容的话，可以通过内存映射，或者是通过特定的函数(read )进行访问，也可以使用用户指针的方式，这里我们使用mmap函数将内核空间的内存映射到用户空间</p>
</li>
<li><p>接下来，初始化完成之后，我们就要开启数据流，这里我们在上面一步会设定缓存数量，不能超过5帧，启动数据流就是说，我们用户取出一帧，设备采集到一帧放入队列</p>
</li>
<li><p>然后将所取到的数据，进行格式转换。，这里数据转换的时候可以将RGB/YUV 转换成MJPEG，MJPEG是运动静止图像压缩技术，可以单独的压缩每一帧图像。生成序列化的运动图像。它就是一种数字压缩格式，只对帧内的空间<a href="http://baike.baidu.com/view/104445.htm" target="_blank" rel="noopener">冗余</a>进行压缩，不对帧间的时间<a href="http://baike.baidu.com/view/104445.htm" target="_blank" rel="noopener">冗余</a>进行压缩，压缩效率低</p>
</li>
</ul>
</li>
<li><p>具体流程图如图：</p>
<p><img src="http://cdn.funful.ink/2019-5-25.png" alt></p>
<h1 id="移植Qt的具体代码"><a href="#移植Qt的具体代码" class="headerlink" title="移植Qt的具体代码"></a>移植Qt的具体代码</h1></li>
<li><p>V4L2_QT.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"v4l2_qt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_v4l2_qt.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"v4l2_heade.h"</span></span></span><br><span class="line">V4L2_QT::V4L2_QT(QWidget *parent) :</span><br><span class="line">    QMainWindow(parent),</span><br><span class="line">    ui(<span class="keyword">new</span> Ui::V4L2_QT)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    Camera_fd = <span class="number">-1</span>;</span><br><span class="line">     buffers = <span class="literal">NULL</span>;</span><br><span class="line">     n_buffers = <span class="number">0</span>;</span><br><span class="line">    device   =  <span class="string">"/dev/video0"</span>;<span class="comment">//linux</span></span><br><span class="line">    device_2 = <span class="string">"/dev/video4"</span>;<span class="comment">//</span></span><br><span class="line">    pixel_format = V4L2_PIX_FMT_YUYV;	<span class="comment">//视频格式为MJPEG</span></span><br><span class="line">    pre_w = WIDTH;	<span class="comment">//预览窗口w</span></span><br><span class="line">    pre_h = HEIGHT;	<span class="comment">//预览窗口h</span></span><br><span class="line">    timer=<span class="keyword">new</span> QTimer(<span class="keyword">this</span>);</span><br><span class="line">    frame=<span class="keyword">new</span> QImage(rgb,WIDTH,HEIGHT,QImage::Format_RGB888);</span><br><span class="line">    <span class="keyword">this</span>-&gt;setMaximumSize(<span class="number">640</span>,<span class="number">480</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;setMinimumSize(<span class="number">640</span>,<span class="number">480</span>);</span><br><span class="line">    ui-&gt;label-&gt;setMaximumSize(<span class="number">640</span>,<span class="number">480</span>);</span><br><span class="line">    ui-&gt;label-&gt;setMinimumSize(<span class="number">640</span>,<span class="number">480</span>);</span><br><span class="line"></span><br><span class="line">     readCamera();  <span class="comment">//camera 初始化，开启视频流</span></span><br><span class="line">    connect(timer,SIGNAL(timeout()),<span class="keyword">this</span>,SLOT(post_preview()));  <span class="comment">//将视频流post到preview窗口中，实现预览</span></span><br><span class="line">    timer-&gt;start(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V4L2_QT::~V4L2_QT()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">    releaseCamera();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> V4L2_QT::xioctl(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, <span class="keyword">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        r = ioctl(fd, request, arg);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">-1</span> == r &amp;&amp; EINTR == errno);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> V4L2_QT::errno_exit(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s error %d, %s\n"</span>, s, errno, strerror(errno));</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>  V4L2_QT::opendevice(<span class="keyword">char</span>*device)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    Camera_fd=open(device,O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(Camera_fd&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Cann't Open %s,%d,%s/n"</span>,device,errno ,strerror(errno));</span><br><span class="line">         <span class="keyword">return</span> errno;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">        PRINTK(<span class="string">"OPen video Success\n"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Memory Requset</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> V4L2_QT::init_mmap()</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_requestbuffers</span> <span class="title">reqbufs</span>;</span><span class="comment">//向驱动申请帧缓冲的请求，里面包含申请的个数</span></span><br><span class="line">   CLEAR(reqbufs);<span class="comment">//clear</span></span><br><span class="line">   reqbufs.count=<span class="number">4</span>;<span class="comment">//缓存数量，也就是说在缓存队列里保持4张照片</span></span><br><span class="line">   reqbufs.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;<span class="comment">//数据流格式</span></span><br><span class="line">   reqbufs.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">   <span class="keyword">if</span>(<span class="number">-1</span>==xioctl(Camera_fd,VIDIOC_REQBUFS,&amp;reqbufs))</span><br><span class="line">      &#123;</span><br><span class="line">       <span class="keyword">if</span> (EINVAL == errno)&#123;</span><br><span class="line">           <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s does not support memory mapping\n"</span>, device);</span><br><span class="line">           <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">           &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">       errno_exit(<span class="string">"VIDIOC_REQBUFS"</span>);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">if</span> (reqbufs.count &lt; <span class="number">2</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Insufficient buffer memory on %s\n"</span>, device);</span><br><span class="line">       <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   buffers = (struct buffer *)<span class="built_in">calloc</span>(reqbufs.count, <span class="keyword">sizeof</span>(*buffers));</span><br><span class="line">   <span class="keyword">if</span> (!buffers)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Out of memory\n"</span>);</span><br><span class="line">       <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (n_buffers = <span class="number">0</span>; n_buffers &lt; reqbufs.count; ++n_buffers)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">       CLEAR(buf);</span><br><span class="line"></span><br><span class="line">       buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">       buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">       buf.index = n_buffers;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="number">-1</span> == xioctl(Camera_fd, VIDIOC_QUERYBUF, &amp;buf))</span><br><span class="line">           errno_exit(<span class="string">"VIDIOC_QUERYBUF"</span>);</span><br><span class="line"></span><br><span class="line">       buffers[n_buffers].length=buf.length;</span><br><span class="line">       buffers[n_buffers].start = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)mmap(<span class="literal">NULL</span>,buf.length,PROT_READ | PROT_WRITE ,MAP_SHARED ,Camera_fd, buf.m.offset);</span><br><span class="line">       <span class="keyword">if</span> (MAP_FAILED == buffers[n_buffers].start)</span><br><span class="line">           errno_exit(<span class="string">"mmap"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   PRINTK(<span class="string">"init_mmap Success\n"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> V4L2_QT::init_device(<span class="keyword">unsigned</span> <span class="keyword">int</span> w, <span class="keyword">unsigned</span> <span class="keyword">int</span> h)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_capability</span> <span class="title">cap</span>;</span><span class="comment">//这个设备的功能，比如是否是视频输入设备</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_format</span> <span class="title">fmt</span>;</span><span class="comment">//帧的格式，比如宽度，高度等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_cropcap</span>  <span class="title">cropcap</span>;</span> <span class="comment">//输入设备裁剪</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_crop</span> <span class="title">crop</span>;</span> <span class="comment">//输入设备裁剪</span></span><br><span class="line"> <span class="keyword">if</span>(xioctl(Camera_fd,VIDIOC_QUERYCAP,&amp;cap))<span class="comment">//Check vedio input</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span>(EINVAL==errno)</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s is no V4l2 device \n"</span>,device);</span><br><span class="line">        <span class="keyword">return</span>(EXIT_FAILURE);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">         errno_exit(<span class="string">"VIDIOC_QUERYCAP"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span>(!(cap.capabilities&amp;V4L2_CAP_VIDEO_CAPTURE))</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"no video capture device\n"</span>);</span><br><span class="line">             <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line"> <span class="keyword">if</span>(<span class="number">-1</span>==xioctl(Camera_fd,VIDIOC_CROPCAP,&amp;cropcap))</span><br><span class="line">      errno_exit(<span class="string">"VIDIOC_CROPCA"</span>);</span><br><span class="line"> crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line"> crop.c = cropcap.defrect;</span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == xioctl(Camera_fd, VIDIOC_S_CROP, &amp;crop))</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">switch</span> (errno)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">case</span> EINVAL:</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> CLEAR(fmt);<span class="comment">//清除帧的格式</span></span><br><span class="line"> <span class="comment">//重新设置帧的格式</span></span><br><span class="line"> fmt.type=V4L2_BUF_TYPE_VIDEO_CAPTURE;<span class="comment">// 数据流类型，必须永远是//V4L2_BUF_TYPE_VIDEO_CAPTURE</span></span><br><span class="line"> fmt.fmt.pix.width=w;</span><br><span class="line"> fmt.fmt.pix.pixelformat = pixel_format;</span><br><span class="line"> fmt.fmt.pix.field = V4L2_FIELD_ANY;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == xioctl(Camera_fd, VIDIOC_S_FMT, &amp;fmt))<span class="comment">//把刚才的帧格式写入</span></span><br><span class="line">     errno_exit(<span class="string">"VIDIOC_S_FMT"</span>);</span><br><span class="line"> <span class="keyword">if</span> ((fmt.fmt.pix.width != w) || (fmt.fmt.pix.height != h))<span class="comment">//判断是否写入</span></span><br><span class="line"> &#123;</span><br><span class="line">     qWarning(<span class="string">"  Frame size:   %ux%u (requested size %ux%u is not supported by device)\n"</span>,</span><br><span class="line">         fmt.fmt.pix.width, fmt.fmt.pix.height, w, h);</span><br><span class="line">     w = fmt.fmt.pix.width;</span><br><span class="line">     h = fmt.fmt.pix.height;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">     qWarning(<span class="string">"  Frame size:   %dx%d\n"</span>, w, h);</span><br><span class="line"> &#125;</span><br><span class="line">     PRINTK(<span class="string">"init_device Success\n"</span>);</span><br><span class="line">    <span class="comment">//配置完成之后，接下来进行内存分配</span></span><br><span class="line">init_mmap();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> V4L2_QT::readCamera()</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">if</span>(opendevice(device))&#123;</span><br><span class="line">   init_device(pre_w,pre_h);</span><br><span class="line">   stream_on();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">else</span>&#123;</span><br><span class="line"> opendevice(device_2);</span><br><span class="line"> init_device(pre_w,pre_h);</span><br><span class="line">  stream_on();</span><br><span class="line">  &#125;</span><br><span class="line">PRINTK(<span class="string">"readCamera Success\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> V4L2_QT::process_image(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> size)</span><br><span class="line">  &#123;</span><br><span class="line">  qDebug()&lt;&lt;size&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      PRINTK(<span class="string">"process_image get in"</span>);</span><br><span class="line">   <span class="comment">//showPicData(buf, size);</span></span><br><span class="line">  convertMJPEG2Mat(buf);</span><br><span class="line">  PRINTK(<span class="string">"yuv--&gt;rgb Success out \n"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//convertMJPEG2Mat(buf);</span></span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">void</span> V4L2_QT::stream_on()</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">enum</span> v4l2_buf_type type;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span><span class="comment">//代表驱动中的一帧</span></span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n_buffers;++i)</span><br><span class="line"> &#123;</span><br><span class="line">     CLEAR(buf);</span><br><span class="line">     buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">     buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">     buf.index=i;</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">-1</span> == xioctl(Camera_fd, VIDIOC_QBUF, &amp;buf))</span><br><span class="line">         errno_exit(<span class="string">"VIDIOC_QBUF"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="number">-1</span> == xioctl(Camera_fd, VIDIOC_STREAMON, &amp;type))</span><br><span class="line">     errno_exit(<span class="string">"VIDIOC_STREAMON"</span>);</span><br><span class="line"> PRINTK(<span class="string">"stream_on Success\n"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> V4L2_QT::post_preview()</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">v4l2_buffer</span> <span class="title">buf</span>;</span></span><br><span class="line">  CLEAR(buf);</span><br><span class="line">  buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">  buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == xioctl(Camera_fd, VIDIOC_DQBUF, &amp;buf))</span><br><span class="line">      errno_exit(<span class="string">"VIDIOC_DQBUF"</span>);</span><br><span class="line">   assert(buf.index &lt; n_buffers);</span><br><span class="line">     PRINTK(<span class="string">"post_preview---&gt;process_images\n"</span>);</span><br><span class="line">   process_image(buffers[buf.index].start, buf.bytesused);</span><br><span class="line">   PRINTK(<span class="string">"process_image Sucess\n"</span>);</span><br><span class="line"></span><br><span class="line">   v4l2_buffer queue_buf;</span><br><span class="line">   CLEAR(queue_buf);</span><br><span class="line">   queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">   queue_buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">   queue_buf.index =buf.index;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == xioctl(Camera_fd, VIDIOC_QBUF, &amp;queue_buf))</span><br><span class="line">         errno_exit(<span class="string">"VIDIOC_QBUF"</span>);</span><br><span class="line">   PRINTK(<span class="string">"number=%d\n"</span>,number++);</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="keyword">void</span> V4L2_QT::releaseCamera()</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n_buffers; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">      munmap(buffers[i].start, buffers[i].length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">free</span>(buffers);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">-1</span> == ::close(Camera_fd))</span><br><span class="line">      errno_exit(<span class="string">"close"</span>);</span><br><span class="line">  Camera_fd = <span class="number">-1</span>;</span><br><span class="line">  timer-&gt;stop();</span><br><span class="line"> &#125;</span><br><span class="line">     <span class="keyword">int</span> V4L2_QT::convert_yuv_to_rgb_pixel(<span class="keyword">int</span> y, <span class="keyword">int</span> u, <span class="keyword">int</span> v)  <span class="comment">//</span></span><br><span class="line">  &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> pixel32 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *pixel = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;pixel32;</span><br><span class="line">  <span class="keyword">int</span> r, g, b;</span><br><span class="line">  r = y + (<span class="number">1.370705</span> * (v<span class="number">-128</span>));</span><br><span class="line">  g = y - (<span class="number">0.698001</span> * (v<span class="number">-128</span>)) - (<span class="number">0.337633</span> * (u<span class="number">-128</span>));</span><br><span class="line">  b = y + (<span class="number">1.732446</span> * (u<span class="number">-128</span>));</span><br><span class="line">  <span class="keyword">if</span>(r &gt; <span class="number">255</span>) r = <span class="number">255</span>;</span><br><span class="line">  <span class="keyword">if</span>(g &gt; <span class="number">255</span>) g = <span class="number">255</span>;</span><br><span class="line">  <span class="keyword">if</span>(b &gt; <span class="number">255</span>) b = <span class="number">255</span>;</span><br><span class="line">  <span class="keyword">if</span>(r &lt; <span class="number">0</span>) r = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(g &lt; <span class="number">0</span>) g = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(b &lt; <span class="number">0</span>) b = <span class="number">0</span>;</span><br><span class="line">  pixel[<span class="number">0</span>] = r * <span class="number">220</span> / <span class="number">256</span>;</span><br><span class="line">  pixel[<span class="number">1</span>] = g * <span class="number">220</span> / <span class="number">256</span>;</span><br><span class="line">  pixel[<span class="number">2</span>] = b * <span class="number">220</span> / <span class="number">256</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pixel32;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//yuv422×ªRGB24</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> V4L2_QT::convert_yuv_to_rgb_buffer(<span class="keyword">unsigned</span> <span class="keyword">char</span> *yuv, <span class="keyword">unsigned</span> <span class="keyword">char</span> *rgb, <span class="keyword">unsigned</span> <span class="keyword">int</span> width, <span class="keyword">unsigned</span> <span class="keyword">int</span> height)    <span class="comment">//Êý×é ÏñËØÑÕÉ«×ª»»yuv ×ª»»rgb</span></span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> in;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> pixel_16=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> pixel_24[<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> pixel32;</span><br><span class="line">  <span class="keyword">int</span> y0, u, y1, v;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(in = <span class="number">0</span>; in &lt; width * height * <span class="number">2</span>; in += <span class="number">4</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      pixel_16 = yuv[in + <span class="number">3</span>] &lt;&lt; <span class="number">24</span> |</span><br><span class="line">                 yuv[in + <span class="number">2</span>] &lt;&lt; <span class="number">16</span> |</span><br><span class="line">                 yuv[in + <span class="number">1</span>] &lt;&lt;  <span class="number">8</span> |</span><br><span class="line">                 yuv[in + <span class="number">0</span>];</span><br><span class="line">      y0 = (pixel_16 &amp; <span class="number">0x000000ff</span>);</span><br><span class="line">      u  = (pixel_16 &amp; <span class="number">0x0000ff00</span>) &gt;&gt;  <span class="number">8</span>;</span><br><span class="line">      y1 = (pixel_16 &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">      v  = (pixel_16 &amp; <span class="number">0xff000000</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">      pixel32 = convert_yuv_to_rgb_pixel(y0, u, v);<span class="comment">//YUV UV·ÖÁ¿×÷ÓÃ²»Ã÷ÏÔ ŒõÐ¡UV·ÖÁ¿ ÔÚŒÆËãRGBµÄÊ±ºòÓÃÁÙœüµÄŽúÌæ</span></span><br><span class="line">      pixel_24[<span class="number">0</span>] = (pixel32 &amp; <span class="number">0x000000ff</span>);</span><br><span class="line">      pixel_24[<span class="number">1</span>] = (pixel32 &amp; <span class="number">0x0000ff00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">      pixel_24[<span class="number">2</span>] = (pixel32 &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">      rgb[out++] = pixel_24[<span class="number">0</span>];</span><br><span class="line">      rgb[out++] = pixel_24[<span class="number">1</span>];</span><br><span class="line">      rgb[out++] = pixel_24[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">      pixel32 = convert_yuv_to_rgb_pixel(y1, u, v);<span class="comment">//YUV UV·ÖÁ¿×÷ÓÃ²»Ã÷ÏÔ ŒõÐ¡UV·ÖÁ¿ ÔÚŒÆËãRGBµÄÊ±ºòÓÃÁÙœüµÄŽúÌæ</span></span><br><span class="line">      pixel_24[<span class="number">0</span>] = (pixel32 &amp; <span class="number">0x000000ff</span>);</span><br><span class="line">      pixel_24[<span class="number">1</span>] = (pixel32 &amp; <span class="number">0x0000ff00</span>) &gt;&gt; <span class="number">8</span>;</span><br><span class="line">      pixel_24[<span class="number">2</span>] = (pixel32 &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>;</span><br><span class="line">      rgb[out++] = pixel_24[<span class="number">0</span>];</span><br><span class="line">      rgb[out++] = pixel_24[<span class="number">1</span>];</span><br><span class="line">      rgb[out++] = pixel_24[<span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> V4L2_QT::convertMJPEG2Mat(<span class="keyword">unsigned</span> <span class="keyword">char</span>*mjpeg)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line"> convert_yuv_to_rgb_buffer(mjpeg,rgb,WIDTH,HEIGHT);</span><br><span class="line">     pixmap = QPixmap::fromImage(*frame);</span><br><span class="line"> ui-&gt;label-&gt;setPixmap(pixmap);</span><br><span class="line">PRINTK(<span class="string">"yuv--&gt;rgb Success\n"</span>);</span><br><span class="line">      <span class="comment">//sprintf(ImageName,"ImageName%04ld.jpg",ImageNum++);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//imwrite(ImageName,RGBImage);</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>V4L2_QT.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifndef V4L2_QT_H</span><br><span class="line"></span><br><span class="line">define V4L2_QT_H</span><br><span class="line"></span><br><span class="line">include &lt;QMainWindow&gt;</span><br><span class="line"></span><br><span class="line">include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">include &lt;QLabel&gt;</span><br><span class="line"></span><br><span class="line">include&lt;QWidget&gt;</span><br><span class="line"></span><br><span class="line">include&lt;QPixmap&gt;</span><br><span class="line"></span><br><span class="line">include&lt;QLabel&gt;</span><br><span class="line"></span><br><span class="line">include&lt;QPainter&gt;</span><br><span class="line"></span><br><span class="line">include&lt;QTimer&gt;</span><br><span class="line"></span><br><span class="line">include &lt;QWidget&gt;</span><br><span class="line"></span><br><span class="line">include &lt;opencv2/highgui/highgui.hpp&gt;</span><br><span class="line"></span><br><span class="line">include &lt;opencv2/core/core.hpp&gt;</span><br><span class="line"></span><br><span class="line">include &lt;qtimer.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;opencv2/highgui/highgui_c.h&gt;</span><br><span class="line"></span><br><span class="line">  //Kernel Header file</span><br><span class="line"></span><br><span class="line">include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;linux/fs.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;linux/stat.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;linux/types.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;linux/videodev2.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;sys/time.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;sys/mman.h&gt; //memory</span><br><span class="line"></span><br><span class="line">include &lt;sys/ioctl.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;sys/stat.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">include &lt;assert.h&gt;  //invok the assert()  function</span><br><span class="line">     namespace Ui &#123;</span><br><span class="line">     class V4L2_QT;</span><br><span class="line">     &#125;</span><br><span class="line">     class V4L2_QT : public QMainWindow</span><br><span class="line">     Q_OBJECT</span><br><span class="line">     public slots:</span><br><span class="line">        void post_preview();</span><br><span class="line">     public:</span><br><span class="line">     explicit V4L2_QT(QWidget *parent = 0);</span><br><span class="line">     ~V4L2_QT();</span><br><span class="line">       unsigned char rgb[WIDTH*HEIGHT*3];</span><br><span class="line">     private:</span><br><span class="line">    </span><br><span class="line">     Ui::V4L2_QT *ui;</span><br><span class="line">     struct buffer</span><br><span class="line">     &#123;</span><br><span class="line">         unsigned char *start;</span><br><span class="line">         size_t length;</span><br><span class="line">     &#125;;</span><br><span class="line">    </span><br><span class="line">     QTimer *timer;</span><br><span class="line">     QImage *frame;</span><br><span class="line">    QPixmap pixmap;</span><br><span class="line">     struct buffer *buffers;</span><br><span class="line">     unsigned int n_buffers ;</span><br><span class="line">     int number;</span><br><span class="line">     char *device;</span><br><span class="line">     char *device_2;</span><br><span class="line">     int Camera_fd;</span><br><span class="line">      int index;</span><br><span class="line">     unsigned int pre_w;//预览窗口w</span><br><span class="line">     unsigned int pre_h;//预览窗口h</span><br><span class="line">    </span><br><span class="line">     int pixel_format;</span><br><span class="line">    </span><br><span class="line">    int  xioctl(int fd, int request, void *arg);</span><br><span class="line">    void errno_exit(const char *s);</span><br><span class="line">    void init_mmap();</span><br><span class="line">    int  opendevice(char*device);</span><br><span class="line">    int init_device(unsigned int w, unsigned int h);</span><br><span class="line">    void readCamera();</span><br><span class="line">    void stream_on();</span><br><span class="line">    void releaseCamera();</span><br><span class="line">    void process_image(unsigned char *buf,int size);</span><br><span class="line">    int  convert_yuv_to_rgb_pixel(int y, int u, int v);</span><br><span class="line">    int  convert_yuv_to_rgb_buffer(unsigned char *yuv, unsigned char *rgb, unsigned int width, unsigned int height);</span><br><span class="line">    void convertMJPEG2Mat(unsigned char*mjpeg);</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>V4L2</tag>
      </tags>
  </entry>
  <entry>
    <title>ES8266模块二次开发SDK之MQTT局域网控制LED</title>
    <url>/2019/05/20/ESP8266_SDK_MQTT_LED/</url>
    <content><![CDATA[<p>根据乐鑫官网的提供的Pro，已经提供了 支持MQTT协议，，在乐鑫pro</p>
<p>基础上再局域网下面控制led</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><h2 id="工程文档准备"><a href="#工程文档准备" class="headerlink" title="工程文档准备"></a>工程文档准备</h2><ol>
<li>下载链接 <a href="https://www.espressif.com/zh-hans/support/download/sdks-demos" target="_blank" rel="noopener">乐鑫</a></li>
<li>选用的平台NON-OS SDK</li>
<li>使用安信可一体化编程软件打开，文档的导入具体去安信可官网搜索，这里直接讲解导入后的操作。 删除third_party,将esp_mqtt_proj从example拉出来，将driver_lib的Makefile添加后.bak,目的是为了不讲driver_lib不编译进工程</li>
<li>如图，<img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-8-25.png" alt></li>
</ol>
<h2 id="MQTT的windows环境准备"><a href="#MQTT的windows环境准备" class="headerlink" title="MQTT的windows环境准备"></a>MQTT的windows环境准备</h2><ol>
<li>下载EMQ压缩包，根据你的windows环境选择，下载地址<a href="http://www.emqtt.com/downloads" target="_blank" rel="noopener">链接</a></li>
<li>解压到不带中文的目录下，打开windows命令，进入到该解压目录的bin文件夹下面，</li>
<li>在终端执行”emqttd console”，如果卡顿就重新执行</li>
<li>在浏览器输入”127.0.0.1:18083”</li>
<li>此时会进入EMQ的界面SSID为admin，Passwd为public</li>
<li>此时MQTT服务器已经搭建完成</li>
</ol>
<h2 id="硬件环境准备"><a href="#硬件环境准备" class="headerlink" title="硬件环境准备"></a>硬件环境准备</h2><ol>
<li>一块MODEMCU或者是ESP8266的最小系统</li>
<li>一个USB转TTL或者是数据线</li>
</ol>
<h2 id="软件环境"><a href="#软件环境" class="headerlink" title="软件环境"></a>软件环境</h2><ol>
<li>烧录工具，可以在安信可官网下载 <a href="http://wiki.ai-thinker.com/esp_download" target="_blank" rel="noopener">链接</a></li>
<li>串口工具，使用任意一款都可以，</li>
</ol>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h2><ol>
<li><p>在工程中打开user_main.c和mqtt_config.h，</p>
</li>
<li><p>在mqtt_config.h需要修改以下几个宏</p>
<table>
<thead>
<tr>
<th>CFG_HOLDER</th>
<th>更新配置到FLASH中，只要数值和本次不一样就行，</th>
</tr>
</thead>
<tbody><tr>
<td>MQTT_HOST</td>
<td>MQTT服务器的IP</td>
</tr>
<tr>
<td>MQTT_PORT</td>
<td>MQTT服务器的PORT</td>
</tr>
<tr>
<td>MQTT_CLIENT_ID</td>
<td>客户端ID</td>
</tr>
<tr>
<td>MQTT_USER</td>
<td>MQTT服务器的登录账号”admin”</td>
</tr>
<tr>
<td>MQTT_PASS</td>
<td>MQTT服务器的登录”admin”</td>
</tr>
<tr>
<td>STA_SSID</td>
<td>ESP8266和电脑端连接的路由账号</td>
</tr>
<tr>
<td>STA_PASS</td>
<td>ESP8266和电脑端连接的路由密码</td>
</tr>
<tr>
<td>PROTOCOL_NAMEv311</td>
<td>根据MQTT协议的兼容性，在前面加#define，PROTOCOL_NAMEv31注释掉</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>右击该工程，Clean Project &amp;&amp;Build Project</p>
</li>
<li><p>可以看到顺利通过编译，如图<img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-8-25-2.png" alt></p>
<p>依照安信可官方提供的烧录方法可以知道，<img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-8-25-3.png" alt></p>
<p>blank.bin、esp_init_data_default_v05.bin是乐鑫SDK提供的，而eagle.flash.bin和eagle.irom0text.bin是编译工程生成的，，下载地址需要我们将工程给的地址和安信可提供地址组合得到，如图</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-8-25-4.png" alt></p>
<table>
<thead>
<tr>
<th>SPI SPEED</th>
<th>40MHz</th>
</tr>
</thead>
<tbody><tr>
<td>SPI MODE</td>
<td>DOUT</td>
</tr>
<tr>
<td>FLASH SIZE</td>
<td>32Mbit（根据板子而定）</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>使用烧写工具擦写和下载，</p>
</li>
<li><p>将MQTT服务器Runing，(MQTT服务器和ESP8266需要在同一个局域网下面)</p>
</li>
<li><p>重启ESP8266模块，打开串口 BAUD 115200</p>
</li>
<li><p>在浏览器登录MQTT，可以看到会话界面，有刚才客户端ID,主题界面有工程中注册的主题如图</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-8-25-6.png" alt></p>
<p>​</p>
</li>
<li><p>主题，是我们在user_main.c的mqttConnectedCb函数注册的主题 如图 <img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-8-25-5.png" alt>  </p>
</li>
<li><p>串口也会打印出来</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-8-25-7.png" alt></p>
</li>
<li><p>到这一步，我们整个MQTT的局域网服务器已经搭建起来，下面测试一下，</p>
<ol>
<li><p>在EMQ界面切换到websocket测试，首先连接</p>
</li>
<li><p>订阅主题”/mqtt/topic/1”</p>
</li>
<li><p>给主题”/mqtt/topic/1” 发送”Hello World!”</p>
</li>
<li><p>如图  <img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-8-25-8.png" alt></p>
</li>
<li><p>在串口端会打印出”Hello World!”,如图<img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-8-25-9.png" alt></p>
<p>​</p>
</li>
</ol>
<p>这里整体的测试环境已经搭建完成，我们下面开始进行局域网，点亮LED</p>
</li>
</ol>
<h2 id="局域网点亮LED"><a href="#局域网点亮LED" class="headerlink" title="局域网点亮LED"></a>局域网点亮LED</h2><ol>
<li><p>回到工程进入user_main.c，</p>
</li>
<li><p>在user_init 函数中添加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO5_U, FUNC_GPIO5); <span class="comment">//选择GPIO5</span></span><br><span class="line">GPIO_OUTPUT_SET(GPIO_ID_PIN(<span class="number">5</span>), <span class="number">1</span>); <span class="comment">//默认GPIO5为高</span></span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>在mqttConnectedCb函数中注册一个主题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MQTT_Subscribe(client, <span class="string">"/hangtong/led/control"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在mqttDataCb对收到的值解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (data[<span class="number">0</span>] == <span class="string">'0'</span>) &#123;</span><br><span class="line">        GPIO_OUTPUT_SET(GPIO_ID_PIN(<span class="number">5</span>), <span class="number">0</span>);</span><br><span class="line">        MQTT_Publish(client, <span class="string">"/xuhong/LED/out"</span>, <span class="string">"LED status is open ..."</span>,</span><br><span class="line">                <span class="built_in">strlen</span>(<span class="string">"LED status is open ..."</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收到指令是0，GPIO15为高,也就是LED关灯，同时发布消息，主题是/xuhong/LED/out，信息是LED status is off ...</span></span><br><span class="line">    <span class="keyword">if</span> (data[<span class="number">0</span>] == <span class="string">'1'</span>) &#123;</span><br><span class="line">        GPIO_OUTPUT_SET(GPIO_ID_PIN(<span class="number">5</span>), <span class="number">1</span>);</span><br><span class="line">        MQTT_Publish(client, <span class="string">"/xuhong/LED/out"</span>, <span class="string">"LED status is off ..."</span>,</span><br><span class="line">                <span class="built_in">strlen</span>(<span class="string">"LED status is off ..."</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>Clean Project &amp;&amp;build Project</p>
</li>
<li><p>重复上面步骤，</p>
</li>
<li><p>在EMQ服务器上面我们，会发现出现了”/hangtong/led/control” 主题 ，在websocket向”/hangtong/led/control”主题发送0则GPIO5为低电平。发送1则GPIO5为高电平</p>
</li>
<li><p>成功，</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>MQTT服务器的IP需要我们在电脑端查询得到，</li>
<li>局域网的控制，所以电脑端和ESP8266需要连接同一个路由</li>
</ul>
]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
      <tags>
        <tag>ESP8266</tag>
        <tag>SDK</tag>
        <tag>MQTT</tag>
        <tag>局域网</tag>
      </tags>
  </entry>
  <entry>
    <title>STM2F407与FreeRTOS的FreeRTOSConfig.h详解<2></title>
    <url>/2019/05/19/STM32_FreeRTOS_config_2/</url>
    <content><![CDATA[<p>上一篇，对config宏的基础配置和部分相关的配置，有些宏我们暂时没有用上，所以对这些宏定义的概念不太清楚，这章节是对余下部分解析。</p>
<a id="more"></a>

<h1 id="config"><a href="#config" class="headerlink" title="config_*"></a>config_*</h1><h2 id="FreeRTOS与钩子函数有关的配置选项"><a href="#FreeRTOS与钩子函数有关的配置选项" class="headerlink" title="FreeRTOS与钩子函数有关的配置选项"></a>FreeRTOS与钩子函数有关的配置选项</h2><h3 id="configUSE-IDLE-HOOK"><a href="#configUSE-IDLE-HOOK" class="headerlink" title="configUSE_IDLE_HOOK"></a>configUSE_IDLE_HOOK</h3><p>为1的话，就是使能空闲任务回调函数，也就是如果系统调用空闲函数的话，就会回调钩子函数，我们自己去实现这个函数，函数声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vApplicationIdleHook</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="configUSE-TICK-HOOK"><a href="#configUSE-TICK-HOOK" class="headerlink" title="configUSE_TICK_HOOK"></a>configUSE_TICK_HOOK</h3><p>为1的话使能时间片钩子函数，但是需要我们自己去实现这个函数，函数声明如下：    </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vApplicationTickHook</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="FreeRTOS与运行时间和任务状态收集有关的配置选项"><a href="#FreeRTOS与运行时间和任务状态收集有关的配置选项" class="headerlink" title="FreeRTOS与运行时间和任务状态收集有关的配置选项"></a>FreeRTOS与运行时间和任务状态收集有关的配置选项</h2><h3 id="configGENERATE-RUN-TIME-STATS"><a href="#configGENERATE-RUN-TIME-STATS" class="headerlink" title="configGENERATE_RUN_TIME_STATS"></a>configGENERATE_RUN_TIME_STATS</h3><p>为1 的话开启时间统计功能，如果定义这个宏的话，就必须还有定义另外两个宏，这个在后面的任务查询的时候我们有可能会配置，这两个宏分别是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">portCONFIGURE_TIMER_FOR_RUN_TIME_STATS</span><br><span class="line">portALT_GET_RUN_TIME_COUNTER_VALUE</span><br></pre></td></tr></table></figure>

<h3 id="configUSE-TRACE-FACILITY"><a href="#configUSE-TRACE-FACILITY" class="headerlink" title="configUSE_TRACE_FACILITY"></a>configUSE_TRACE_FACILITY</h3><p>为1的话启动可视化跟踪调试，会增加一些结构体成员和API函数。</p>
<h3 id="configUSE-STATS-FORMATTING-FUNCTIONS"><a href="#configUSE-STATS-FORMATTING-FUNCTIONS" class="headerlink" title="configUSE_STATS_FORMATTING_FUNCTIONS"></a>configUSE_STATS_FORMATTING_FUNCTIONS</h3><p>Set configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS to 1<br>to include the vTaskList() and vTaskGetRunTimeStats() </p>
<h2 id="FreeRTOS与协程有关的配置选项（现在的MCU很强大，不需要节约资源，所以基本不配置协程）"><a href="#FreeRTOS与协程有关的配置选项（现在的MCU很强大，不需要节约资源，所以基本不配置协程）" class="headerlink" title="FreeRTOS与协程有关的配置选项（现在的MCU很强大，不需要节约资源，所以基本不配置协程）"></a>FreeRTOS与协程有关的配置选项（现在的MCU很强大，不需要节约资源，所以基本不配置协程）</h2><h3 id="configUSE-CO-ROUTINES"><a href="#configUSE-CO-ROUTINES" class="headerlink" title="configUSE_CO_ROUTINES"></a>configUSE_CO_ROUTINES</h3><p>为1的话，工程需要编译协程，需要把协程文件包含进来，相应的API函数才会被编译。</p>
<h3 id="configMAX-CO-ROUTINE-PRIORITIES"><a href="#configMAX-CO-ROUTINE-PRIORITIES" class="headerlink" title="configMAX_CO_ROUTINE_PRIORITIES"></a>configMAX_CO_ROUTINE_PRIORITIES</h3><p>设置协程的最大优先级，设置完之后，协程使用的优先级范围0~configMAX_CO_ROUTINE_PRIORITIES-1</p>
<h3 id="FreeRTOS与软件定时器有关的配置选项"><a href="#FreeRTOS与软件定时器有关的配置选项" class="headerlink" title="FreeRTOS与软件定时器有关的配置选项"></a>FreeRTOS与软件定时器有关的配置选项</h3><h3 id="configUSE-TIMERS"><a href="#configUSE-TIMERS" class="headerlink" title="configUSE_TIMERS"></a>configUSE_TIMERS</h3><p>为1则启动软件定时器，还有三个宏也需要定义，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">configTIMER_TASK_PRIORITY</span><br><span class="line">configTIMER_QUEUE_LENGTH </span><br><span class="line">configTIMER_TASK_STACK_DEPTHxxxxxxxxxx</span><br></pre></td></tr></table></figure>

<h3 id="configTIMER-TASK-PRIORITY"><a href="#configTIMER-TASK-PRIORITY" class="headerlink" title="configTIMER_TASK_PRIORITY"></a>configTIMER_TASK_PRIORITY</h3><p>设置定时器任务的优先级，0~configMAX_PRIORITIES-1，如果定时器任务的优先级高的话，定时器的队列和回调函数会及时处理。</p>
<h3 id="configTIMER-QUEUE-LENGTH"><a href="#configTIMER-QUEUE-LENGTH" class="headerlink" title="configTIMER_QUEUE_LENGTH"></a>configTIMER_QUEUE_LENGTH</h3><p>设置定时器队列的队列长度。</p>
<h3 id="configTIMER-TASK-STACK-DEPTH"><a href="#configTIMER-TASK-STACK-DEPTH" class="headerlink" title="configTIMER_TASK_STACK_DEPTH"></a>configTIMER_TASK_STACK_DEPTH</h3><p>定时器任务的堆栈，可以根据定时器回调函数的大小，定义定时器任务堆栈大小。</p>
<h2 id="FreeRTOS与中断有关的配置选项"><a href="#FreeRTOS与中断有关的配置选项" class="headerlink" title="FreeRTOS与中断有关的配置选项"></a>FreeRTOS与中断有关的配置选项</h2><h3 id="NVIC-PRIO-BITS"><a href="#NVIC-PRIO-BITS" class="headerlink" title="__NVIC_PRIO_BITS"></a>__NVIC_PRIO_BITS</h3><p>设置优先级位数，STMF407,是高四位，也就是BIT4，5，6，7</p>
<h3 id="configLIBRARY-LOWEST-INTERRUPT-PRIORITY"><a href="#configLIBRARY-LOWEST-INTERRUPT-PRIORITY" class="headerlink" title="configLIBRARY_LOWEST_INTERRUPT_PRIORITY"></a>configLIBRARY_LOWEST_INTERRUPT_PRIORITY</h3><p>设置最低优先级，因为STM32的NVIC配置的组4，也就是16位抢占优先级，所以最低优先级为15，ARM的0优先级最大。</p>
<h3 id="configLIBRARY-MAX-SYSCALL-INTERRUPT-PRIORITY"><a href="#configLIBRARY-MAX-SYSCALL-INTERRUPT-PRIORITY" class="headerlink" title="configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY"></a>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</h3><p>FreeRTOS可以管理的最低优先级，如果设为5的话，0-5不归FREERTOS管，其余的RTOS可以通过API函数管理。与BASEPRI这个寄存器相关。</p>
<h3 id="configKERNEL-INTERRUPT-PRIORITY"><a href="#configKERNEL-INTERRUPT-PRIORITY" class="headerlink" title="configKERNEL_INTERRUPT_PRIORITY"></a>configKERNEL_INTERRUPT_PRIORITY</h3><p>这个是设置内核中断优先级，也就是系统中断的PenSV和SysTick（滴答定时器）</p>
<h3 id="configMAX-SYSCALL-INTERRUPT-PRIORITY"><a href="#configMAX-SYSCALL-INTERRUPT-PRIORITY" class="headerlink" title="configMAX_SYSCALL_INTERRUPT_PRIORITY"></a>configMAX_SYSCALL_INTERRUPT_PRIORITY</h3><p>设置FreeRTOS的API函数的优先级，低于此优先级的中断可以安全调用FREERTOS的API函数，高于此优先级时，如果调用API函数，中断也可以打断。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面有些宏，从字面意思理解并不难，但是我们需要结合相应的功能，才能熟练运用。</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>Stm32F407</tag>
        <tag>FreeRTOS</tag>
        <tag>MDK5</tag>
      </tags>
  </entry>
  <entry>
    <title>STM2F407与FreeRTOS的FreeRTOSConfig.h详解<1></title>
    <url>/2019/05/18/STM32_FreeRTOS_config_1/</url>
    <content><![CDATA[<p>FreeRTOS是一个RTOS类的嵌入式实时操作系统，并且是开源免费的，与其他实时操作系统相比，是一个很好的选择。在移植好FreeRTOS到STM32上面之后，需要根据板子外设配置相应的功能，FreeRTOSConfig.h里面的宏完成对系统的裁剪和配置。</p>
<a id="more"></a>

<h1 id="系统配置文件FreeRTOSConfig-h"><a href="#系统配置文件FreeRTOSConfig-h" class="headerlink" title="系统配置文件FreeRTOSConfig.h"></a>系统配置文件FreeRTOSConfig.h</h1><p>在编译移植好的FreeROTS工程之后，需要都这个系统配置文件进行宏配置，这个配置文件与我们在编译kernel时的menuconfig类似，里面定义的宏，是对板子外设的和功能的裁剪配置。这个里面主要分为两个类的宏，一个是“INCLUDE_”开始的宏，一个是“config”开始的宏。FreeRTOSConfig.h是我们自己填充的.h文件，RTOS工程自带一个FreeRTOS.h文件，我们在FreeRTOSConfig.h定义的宏会对FreeRTOS.h进行条件编译。</p>
<h1 id="INCLUDE"><a href="#INCLUDE" class="headerlink" title="INCLUDE_*"></a>INCLUDE_*</h1><p>这个宏的主要功能就是使能或者是失能，FreeRTOS中的API函数的，如果我们需要使用某个api函数就需要把这个宏置1，否则就是置0。在FreeRTOSConfig.h，在上面部分是宏的声明，在对应的.c文件里面会有条件编译，这个就可以达到减少系统占有的ROM和RAM。</p>
<h3 id="INCLUDE-xTaskGetSchedulerState"><a href="#INCLUDE-xTaskGetSchedulerState" class="headerlink" title="INCLUDE_xTaskGetSchedulerState"></a>INCLUDE_xTaskGetSchedulerState</h3><p>这个宏是对xTaskGetSchedulerState函数的条件判断，是获取任务调度表状态的函数。</p>
<h3 id="INCLUDE-vTaskPrioritySet"><a href="#INCLUDE-vTaskPrioritySet" class="headerlink" title="INCLUDE_vTaskPrioritySet"></a>INCLUDE_vTaskPrioritySet</h3><p>这个宏是对vTaskPrioritySet函数的条件判断，是任务优先级设置的函数。</p>
<h4 id="INCLUDE-uxTaskPriorityGet"><a href="#INCLUDE-uxTaskPriorityGet" class="headerlink" title="INCLUDE_uxTaskPriorityGet"></a>INCLUDE_uxTaskPriorityGet</h4><p>这个宏是对uxTaskPriorityGet函数的条件判断，是获得任务优先级的函数。</p>
<h3 id="INCLUDE-vTaskDelete"><a href="#INCLUDE-vTaskDelete" class="headerlink" title="INCLUDE_vTaskDelete"></a>INCLUDE_vTaskDelete</h3><p>这个宏是对vTaskDelete函数的条件判断，是获得任务优先级的函数。</p>
<h3 id="INCLUDE-vTaskCleanUpResources"><a href="#INCLUDE-vTaskCleanUpResources" class="headerlink" title="INCLUDE_vTaskCleanUpResources"></a>INCLUDE_vTaskCleanUpResources</h3><p>这个宏是对vTaskCleanUpResources函数的条件判断，是对删除的任务进行资源回收的函数。</p>
<h3 id="INCLUDE-vTaskSuspend"><a href="#INCLUDE-vTaskSuspend" class="headerlink" title="INCLUDE_vTaskSuspend"></a>INCLUDE_vTaskSuspend</h3><p>这个宏是对vTaskSuspend函数的条件判断，是对任务进行挂起的函数。</p>
<h3 id="INCLUDE-vTaskDelayUntil"><a href="#INCLUDE-vTaskDelayUntil" class="headerlink" title="INCLUDE_vTaskDelayUntil"></a>INCLUDE_vTaskDelayUntil</h3><p>这个宏是对vTaskDelayUntil函数的条件判断，是设置任务延迟绝对时间的函数。</p>
<h3 id="INCLUDE-vTaskDelay"><a href="#INCLUDE-vTaskDelay" class="headerlink" title="INCLUDE_vTaskDelay"></a>INCLUDE_vTaskDelay</h3><p>这个宏是对vTaskDelay函数的条件判断，是设置任务延迟相对时间的函数。</p>
<h3 id="INCLUDE-eTaskGetState"><a href="#INCLUDE-eTaskGetState" class="headerlink" title="INCLUDE_eTaskGetState"></a>INCLUDE_eTaskGetState</h3><p>这个宏是对eTaskGetState函数的条件判断，是获得某个任务的状态的函数。</p>
<h3 id="INCLUDE-xTimerPendFunctionCall"><a href="#INCLUDE-xTimerPendFunctionCall" class="headerlink" title="INCLUDE_xTimerPendFunctionCall"></a>INCLUDE_xTimerPendFunctionCall</h3><p>这个宏是对xTimerPendFunctionCall函数的条件判断，是获得某个任务的状态的函数</p>
<h1 id="config"><a href="#config" class="headerlink" title="config_*"></a>config_*</h1><h2 id="FreeRTOS基础配置选项"><a href="#FreeRTOS基础配置选项" class="headerlink" title="FreeRTOS基础配置选项"></a>FreeRTOS基础配置选项</h2><h3 id="1为抢占式调度，0为协程，抢占式调度器会在内核的中断中进行任务的切换，协程的话，会在三种情况下，进行任务的切换"><a href="#1为抢占式调度，0为协程，抢占式调度器会在内核的中断中进行任务的切换，协程的话，会在三种情况下，进行任务的切换" class="headerlink" title="1为抢占式调度，0为协程，抢占式调度器会在内核的中断中进行任务的切换，协程的话，会在三种情况下，进行任务的切换:"></a>1为抢占式调度，0为协程，抢占式调度器会在内核的中断中进行任务的切换，协程的话，会在三种情况下，进行任务的切换:</h3><ol>
<li>一个任务调用函数taskYIELD();</li>
<li>一个任务调用可以使任务进入阻塞状态的API函数；</li>
<li>应用程序明确定义了在中断中执行上下文切换；</li>
</ol>
<h3 id="configUSE-TIME-SLICING"><a href="#configUSE-TIME-SLICING" class="headerlink" title="configUSE_TIME_SLICING"></a>configUSE_TIME_SLICING</h3><p>为1的话，在相同优先级下的任务使用合作式调度器，也就是时间片轮流执行。为0的话则不会。</p>
<h3 id="configUSE-PORT-OPTIMISED-TASK-SELECTION"><a href="#configUSE-PORT-OPTIMISED-TASK-SELECTION" class="headerlink" title="configUSE_PORT_OPTIMISED_TASK_SELECTION"></a>configUSE_PORT_OPTIMISED_TASK_SELECTION</h3><p>选择下一个要执行的任务，为0是通用的方法，为1是特殊方法，使用硬件指令计算。</p>
<h3 id="configUSE-TICKLESS-IDLE"><a href="#configUSE-TICKLESS-IDLE" class="headerlink" title="configUSE_TICKLESS_IDLE"></a>configUSE_TICKLESS_IDLE</h3><p>FreerRTOS支持低功耗tickless模式，为1使能，tickless低功耗模式是RTOS通过的低功耗方法，</p>
<h3 id="configUSE-QUEUE-SETS"><a href="#configUSE-QUEUE-SETS" class="headerlink" title="configUSE_QUEUE_SETS"></a>configUSE_QUEUE_SETS</h3><p>设置成1使能队列集功能（可以阻塞、挂起到多个队列和信号量），设置成0取消队列集功能。</p>
<h3 id="configCPU-CLOCK-HZ"><a href="#configCPU-CLOCK-HZ" class="headerlink" title="configCPU_CLOCK_HZ"></a>configCPU_CLOCK_HZ</h3><p>设置CPU工作的频率。</p>
<h3 id="configTICK-RATE-HZ"><a href="#configTICK-RATE-HZ" class="headerlink" title="configTICK_RATE_HZ"></a>configTICK_RATE_HZ</h3><p>设置滴答定时器的中断频率，这里设置为1000，周期就是1ms。</p>
<h3 id="configMAX-PRIORITIES"><a href="#configMAX-PRIORITIES" class="headerlink" title="configMAX_PRIORITIES"></a>configMAX_PRIORITIES</h3><p>设置优先级的数量，范围为0~（configMAX_PRIORITIES-1），0为最低优先级，值越大优先级越高，而且我们的任务不可使用0优先级，</p>
<h3 id="configMINIMAL-STACK-SIZE"><a href="#configMINIMAL-STACK-SIZE" class="headerlink" title="configMINIMAL_STACK_SIZE"></a>configMINIMAL_STACK_SIZE</h3><p>设置最小任务堆栈大小，也就是空闲任务大小，单位是字，</p>
<h3 id="configMAX-TASK-NAME-LEN"><a href="#configMAX-TASK-NAME-LEN" class="headerlink" title="configMAX_TASK_NAME_LEN"></a>configMAX_TASK_NAME_LEN</h3><p>设置任务名最大长度，字节为单位</p>
<h3 id="configUSE-16-BIT-TICKS"><a href="#configUSE-16-BIT-TICKS" class="headerlink" title="configUSE_16_BIT_TICKS"></a>configUSE_16_BIT_TICKS</h3><p>设置系统节拍计数器变量数据类型。设为 1后portTickType 将被定义为无符号的16位整形类型，configUSE_16_BIT_TICKS 设为0 后portTickType 则被定义为无符号的32位整型。</p>
<h3 id="configIDLE-SHOULD-YIELD"><a href="#configIDLE-SHOULD-YIELD" class="headerlink" title="configIDLE_SHOULD_YIELD"></a>configIDLE_SHOULD_YIELD</h3><p>这宏的作用是定义了与空闲任务（idle task）和其他任务处于同等优先级时，为1时，时间片轮到空闲任务的时候，空闲任务会将cpu的使用权交给其他任务    。</p>
<h3 id="configUSE-TASK-NOTIFICATIONS"><a href="#configUSE-TASK-NOTIFICATIONS" class="headerlink" title="configUSE_TASK_NOTIFICATIONS"></a>configUSE_TASK_NOTIFICATIONS</h3><p>为1 则开启任务通知功能。</p>
<h3 id="configUSE-MUTEXES"><a href="#configUSE-MUTEXES" class="headerlink" title="configUSE_MUTEXES"></a>configUSE_MUTEXES</h3><p>为1使用互斥信号量。</p>
<h3 id="configQUEUE-REGISTRY-SIZE"><a href="#configQUEUE-REGISTRY-SIZE" class="headerlink" title="configQUEUE_REGISTRY_SIZE"></a>configQUEUE_REGISTRY_SIZE</h3><p>设置可以注册队列和信号量的最大数量，在内核调试器查询队列和信号量的时候需要设置这个宏，</p>
<h3 id="configCHECK-FOR-STACK-OVERFLOW"><a href="#configCHECK-FOR-STACK-OVERFLOW" class="headerlink" title="configCHECK_FOR_STACK_OVERFLOW"></a>configCHECK_FOR_STACK_OVERFLOW</h3><p>设置堆栈溢出检测，每个任务的堆栈是从FreeRTOS的ucHeap中分配的，如果任务的堆栈溢出的话，会造成程序不稳定，为1的话则设置为堆栈溢出检测功能，需要和钩子函数结合使用，也就是一个回调函数，当溢出是会调用这个回调函数。</p>
<h3 id="configUSE-RECURSIVE-MUTEXES"><a href="#configUSE-RECURSIVE-MUTEXES" class="headerlink" title="configUSE_RECURSIVE_MUTEXES"></a>configUSE_RECURSIVE_MUTEXES</h3><p>为1的话是使能递归互斥信号量。</p>
<h3 id="configUSE-MALLOC-FAILED-HOOK"><a href="#configUSE-MALLOC-FAILED-HOOK" class="headerlink" title="configUSE_MALLOC_FAILED_HOOK"></a>configUSE_MALLOC_FAILED_HOOK</h3><p>为1使用内存分配失败的钩子函数，</p>
<h3 id="configUSE-APPLICATION-TASK-TAG"><a href="#configUSE-APPLICATION-TASK-TAG" class="headerlink" title="configUSE_APPLICATION_TASK_TAG"></a>configUSE_APPLICATION_TASK_TAG</h3><p>这个宏为1是使能两个函数进行编译：</p>
<ol>
<li>configUSE_APPLICATION_TASK_TAGF（）这个函数</li>
<li>vTaskSetApplicationTaskTag（）,这个函数是为任务分配一个标签值。</li>
</ol>
<h3 id="configUSE-COUNTING-SEMAPHORES"><a href="#configUSE-COUNTING-SEMAPHORES" class="headerlink" title="configUSE_COUNTING_SEMAPHORES"></a>configUSE_COUNTING_SEMAPHORES</h3><p>设置1会启动计数型信号量，</p>
<h2 id="FreeRTOS与内存申请有关配置选项"><a href="#FreeRTOS与内存申请有关配置选项" class="headerlink" title="FreeRTOS与内存申请有关配置选项"></a>FreeRTOS与内存申请有关配置选项</h2><h3 id="configSUPPORT-DYNAMIC-ALLOCATION"><a href="#configSUPPORT-DYNAMIC-ALLOCATION" class="headerlink" title="configSUPPORT_DYNAMIC_ALLOCATION"></a>configSUPPORT_DYNAMIC_ALLOCATION</h3><p>定义为1的话FreeRTOS内核对象所需要的RAM会从FREERTOS的堆中动态的获取内存，为0则需要内核对象自己提供。</p>
<h3 id="configTOTAL-HEAP-SIZE"><a href="#configTOTAL-HEAP-SIZE" class="headerlink" title="configTOTAL_HEAP_SIZE"></a>configTOTAL_HEAP_SIZE</h3><p>设置堆空间（Heap）的大小。只有当程序中采用FreeRTOS 提供的内存分配算法时才会用到。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总是我们没有用到的宏有些不会在FreeRTOSConfig.h定义，需要在FreeRTOS.h中查找，并且上面和针对config的宏还有部分配置解释。</p>
]]></content>
      <categories>
        <category>STM32</category>
      </categories>
      <tags>
        <tag>Stm32F407</tag>
        <tag>FreeRTOS</tag>
        <tag>MDK5</tag>
      </tags>
  </entry>
  <entry>
    <title>Orange's:一个操作系统的实现_1th_环境搭建</title>
    <url>/2019/05/17/Orange&#39;s_Implementation_of_an_operating_system_1th_build_environment/</url>
    <content><![CDATA[<p>这章节主要是搭建操作系统环境和编写一个简单程序</p>
<a id="more"></a>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>Deepin操作系统</li>
<li>Nasm</li>
<li>bochs</li>
<li>bximage(bochs自带的软盘映象制作软件)</li>
<li>参考书籍：《Orange’S:一个操作系统的实现》</li>
<li>我们自己写一个操作系统的话就需要有个虚拟机和软盘来运行这个操作系统，但是我们又不至于真的买个软盘，所以我们可以使用bximage生成一个虚拟软盘，把我们写的系统生成相应的文件烧录到虚拟软盘里面，使用dd命令就可以，在bochs启动的时候选择使用我们的虚拟软盘启动就可以。</li>
</ul>
<h1 id="软件安装及简单命令"><a href="#软件安装及简单命令" class="headerlink" title="软件安装及简单命令"></a>软件安装及简单命令</h1><h2 id="Nasm"><a href="#Nasm" class="headerlink" title="Nasm"></a>Nasm</h2><ol>
<li><p>Nasm源码下载地址：<a href="https://www.nasm.us/pub/nasm/releasebuilds/2.14rc16/" target="_blank" rel="noopener">Nasm</a>  </p>
</li>
<li><p>解压并进入解压目录</p>
</li>
<li><p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>简单指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">汇编指令：</span><br><span class="line">nasm boot.asm -o boot.bin</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Bochs"><a href="#Bochs" class="headerlink" title="Bochs"></a>Bochs</h2><ol>
<li><p>Bochs下载地址：<a href="http://bochs.sourceforge.net/" target="_blank" rel="noopener">Bochs官网</a></p>
</li>
<li><p>解压并进入解压目录</p>
</li>
<li><p>Bochs依赖软件安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install build-essential</span><br><span class="line">sudo apt-get install  xorg-dev</span><br><span class="line">如果执行4命令报出别错误的话可能是别的依赖软件没有安装 ，请自行百度</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行以下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --enable-debugger --enable-disasm   ；//这个命令是将bochs设置为可调式的</span><br><span class="line">make</span><br><span class="line">make instal</span><br></pre></td></tr></table></figure>
</li>
<li><p>Bochs简单命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们在使用bochs启动的时候可以选择硬盘启动或者是软盘启动，所以这个时候，我们需要配置相应的配置文件，我们可能会在bochs源码里面发现有“.bochsrc”或者是“bochsrc” ，我们也可以自己写一个配置文件使用“bochs -f yourname” 这命令来启动我们自己写的配置文件“yourname&quot;。（linux下的.文件被隐藏使用 “ls -al”查看）</span><br><span class="line">启动配置文件:  bochs -f yourname（直接bochs也可以启动默认配置文件）</span><br><span class="line">继续执行直到遇见断点：c</span><br><span class="line">单步执行 : n</span><br><span class="line">看寄存器信息：dump_cpu</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="打印一个”Hello-World”"><a href="#打印一个”Hello-World”" class="headerlink" title="打印一个”Hello World”"></a>打印一个”Hello World”</h1><p>在我们接触C语言的时候最基础的工程就是使用printf打印出”Hello World!”.这里我们也使用汇编打印一个hello</p>
<ol>
<li><p>创建boot.asm并书写一下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org 07c00h          ; 告诉编译器程序加载到7c00处</span><br><span class="line">mov ax, cs</span><br><span class="line">mov ds, ax</span><br><span class="line">mov es, ax</span><br><span class="line">call    DispStr         ; 调用显示字符串例程</span><br><span class="line">jmp $          ; 无限循环</span><br><span class="line">DispStr:</span><br><span class="line">mov ax, BootMessage</span><br><span class="line">mov bp, ax          ; ES:BP = 串地址</span><br><span class="line">mov cx, 16          ; CX = 串长度</span><br><span class="line">mov ax, 01301h      ; AH = 13,  AL = 01h</span><br><span class="line">mov bx, 000ch       ; 页号为0(BH = 0) 黑底红字(BL = 0Ch,高亮)</span><br><span class="line">mov dl, 0</span><br><span class="line">int 10h         ; 10h 号中断</span><br><span class="line">ret</span><br><span class="line">BootMessage:        db  &quot;Hello, OS world!&quot;</span><br><span class="line">times   510-($-$$)   db  0   ; 填充剩下的空间，使生成的二进制代码恰好为512字节</span><br><span class="line">dw  0xaa55              ; 结束标志</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成bin文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nasm boot.asm -o boot.bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>bximage生成512字节的虚拟软盘</p>
<ol>
<li>在终端下执行bximage <img src="http://p9zz81nyl.bkt.clouddn.com/2018-11-3-1.png" alt></li>
<li>选择1，再输入”fd”（选择虚拟软盘），再确认，再确认，最终生成1.44M的a.img文件</li>
<li>也可以使用dd命令代替bximage，<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=a.img bs=1440k count=1</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>dd命令将boot.bin烧录到a.img</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dd if=./boot.bin of=./a.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置bochs文件</p>
<ol>
<li>将烧录的a.img移到bochs的源码目录中</li>
<li>在bochs的源码目录里面，执行“ls -al”,可以看到一个.bochsrc</li>
<li>vim .bochsrc<ol>
<li>设置floppya</li>
<li>将boot设置为：floppy<br><img src="http://p9zz81nyl.bkt.clouddn.com/2018-11-3-2.png" alt></li>
</ol>
</li>
</ol>
</li>
<li><p>终端执行”bochs -f .bochsrc”</p>
</li>
<li><p>Please choose one: [6] 6</p>
</li>
<li><p>如果bochs带调试功能：需要输入c继续执行，才能执行。</p>
</li>
<li><p>现象：<img src="http://p9zz81nyl.bkt.clouddn.com/2018-11-3-3.png" alt></p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个章节主要是搭建操作系统运行的环境和编写一个简单的裸机文件，这个汇编程序比较简单，但是这个org命令让我想到了之前在学习内核的时候的相对地址和绝对地址，疑问编译器编译的指令是相对地址是从000h编译的，但是我们自己创建的引导扇区是从07C00h开始执行的，所以需要用到org命令。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>nasm</tag>
        <tag>bochs</tag>
        <tag>deepin</tag>
      </tags>
  </entry>
  <entry>
    <title>ES8266模块二次开发SDK之<输出hello world></title>
    <url>/2019/05/16/ESP8266_SDK_api_HelloWorld/</url>
    <content><![CDATA[<p>根据安信可官方文档，通过修改安信可提供的SDK，使串口输出Hello，World！</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备#"></a>准备#</h1><ul>
<li>开发环境搭建： <a href="http://wiki.ai-thinker.com/ai_ide_install" target="_blank" rel="noopener">链接</a></li>
<li>最新烧录工具： <a href="http://wiki.ai-thinker.com/_media/esp8266/flash_download_tools_v3.6.4.rar" target="_blank" rel="noopener">ESP FLASH TOOL </a></li>
<li>1.54版本的SDK： <a href="http://wiki.ai-thinker.com/_media/esp8266/sdk/esp8266_nonos_sdk_v1.5.4.7z" target="_blank" rel="noopener">ESP8266_NONOS_SDK_v1.54</a></li>
<li>开发板(以下三种都可以）：<ul>
<li>ESP8266模块</li>
<li>NodeMcu</li>
<li>安信可开发板</li>
</ul>
</li>
</ul>
<p>下面根据我使用的NodeMcu，，前提是开发环境已经搭建完成，手中也有一块板子 ，需要的工具也已经下载了，记录一下，该教程操作步骤！</p>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤#"></a>步骤#</h1><h2 id="SDK编译生成BIN文件"><a href="#SDK编译生成BIN文件" class="headerlink" title="SDK编译生成BIN文件##"></a>SDK编译生成BIN文件##</h2><ol>
<li><p>打开AiThinker_IDE</p>
</li>
<li><p>File- &gt;Import-&gt;C/C++-&gt;Existing Code as MakeFile Project，点击 Next</p>
</li>
<li><p>选择我们刚才下载的最新SDK的路径，取消C++，选中Cygwin  GCC， 点击Finish</p>
</li>
<li><p>这样我们的工程就建立好了</p>
</li>
<li><p>在工程中，打开app，进入user，打开user_main.c</p>
</li>
<li><p>在user_init函数中添加一句 os_printf(“\r\nHello，World!\r\n”);</p>
</li>
<li><p>选中该工程右键选择Clean Project，然后再Build Project。</p>
</li>
<li><p>然后就可以 看到下面提示</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-7-27.11.png" alt></p>
</li>
<li><p>下面就开始烧录</p>
</li>
</ol>
<h2 id="烧录"><a href="#烧录" class="headerlink" title="烧录##"></a>烧录##</h2><ol>
<li><p>参考安信可官方的 ESP 系列模组烧录固件的指导： <a href="http://wiki.ai-thinker.com/esp_download" target="_blank" rel="noopener"></a></p>
</li>
<li><p>NodeMcu, 不需要我们手动的将GPIO0拉低，</p>
</li>
<li><p>根据我们上面的生成的两个bin文件可以知道，我们下载的1.54版本的SDK是支持云端升级的boot的</p>
</li>
<li><table>
<thead>
<tr>
<th>文件名称</th>
<th align="center">8Mbit 地址分配</th>
<th>16Mbit 地址分配</th>
<th>32Mbit 地址分配</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>boot.bin</td>
<td align="center">0x00000</td>
<td>0x00000</td>
<td>0x00000</td>
<td>由乐鑫在 SDK 中提供，建议一直使用最新版本</td>
</tr>
<tr>
<td>user1.bin</td>
<td align="center">0x01000</td>
<td>0x01000</td>
<td>0x01000</td>
<td>主程序，由代码编译生成</td>
</tr>
<tr>
<td>user2.bin</td>
<td align="center">0x81000</td>
<td>0x81000</td>
<td>0x81000</td>
<td>主程序，由代码编译生成</td>
</tr>
<tr>
<td>esp_init_data_default.bin</td>
<td align="center">0xFC000</td>
<td>0x1FC000</td>
<td>0x3FC000</td>
<td>由乐鑫在 SDK 中提供</td>
</tr>
<tr>
<td>blank.bin</td>
<td align="center">0xFE000</td>
<td>0x1FE000</td>
<td>0x3FE000</td>
<td>由乐鑫在 SDK 中提供</td>
</tr>
</tbody></table>
</li>
<li><p>参考上图我们自己的烧录设置是（NodeMcu是32Mbit的）</p>
<table>
<thead>
<tr>
<th>boot_v1.5.bin</th>
<th>0x00000</th>
</tr>
</thead>
<tbody><tr>
<td>user1.1024.new.2.bin</td>
<td>0x01000</td>
</tr>
<tr>
<td>esp_init_data_default.bin</td>
<td>0x3FC000</td>
</tr>
<tr>
<td>blank.bin</td>
<td>0x3FE000</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>烧录工具的设置 如图：</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-7-27.12.png" alt></p>
</li>
<li><p>选好COM口，BAUD选的越大，下载速度越快，如果下载失败，可以将波特率降低</p>
</li>
<li><p>下载好之后，我们重启开发板，连接串口调试助手，波特率76800-1-8-0，如图</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_2018-7-27.13.png" alt></p>
</li>
<li><p>可以看到输出 Hello,World！</p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结#"></a>总结#</h1><ul>
<li><p>这个ESP8266的入门教程我们需要注意几点，第一是安信可提供的烧录指南的分两种情况，一种是支持云端升级的(BOOT)，另一种是不支持云端升级（No BOOT）。我们使用的1.5.4的SDK是支持云端升级的，1.2版本的不支持云端升级，两者下载的时候选的BIN文件，不相同。</p>
</li>
<li><p>使用ESP8266模块的下载的时候需要将GPIO0拉低。</p>
<p>​</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
      <tags>
        <tag>ESP8266</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title>关于七牛云测试域名回收解决方案</title>
    <url>/2019/05/15/Technical_articles_1/</url>
    <content><![CDATA[<p>之前写更新的几篇文章,没有注意到七牛云测试域名要回收的信息,今天突然发现测试域名复制外链的时候,竟然无法复制,而且提示错误:5402Bucket域名失败,所以就决定自定义一个个人域名解决.</p>
<a id="more"></a>



<h1 id="融合-CDN-测试域名公告"><a href="#融合-CDN-测试域名公告" class="headerlink" title="融合 CDN 测试域名公告"></a>融合 CDN 测试域名公告</h1><p><img src="http://cdn.funful.ink/2018-11-20.png" alt></p>
<p>但是发现之前文章的测试域名还能在blog中正常显示，所以先不管这个呢．先创建自定义域名．</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本站域名:funful.ink</span><br><span class="line"></span><br><span class="line">七牛绑定域名:cdn.funful.ink</span><br></pre></td></tr></table></figure>

<ol>
<li><p>登录七牛云,进入对象存储,再进入到相应的存储空间,在空间概览,点击自定义域名.如图:</p>
<p><img src="http://cdn.funful.ink/2018-11-20-1.png" alt></p>
</li>
<li><p>如图:点击自定义域名之后,会进入域名管理-&gt;创建域名里面,我们只需要填写一个加速域名,也就是二级域名,这里我的funful.ink已经备案了,所以我就在我的主域名前加一个字符串,然后点击创建就可以了.如图:</p>
<p><img src="http://cdn.funful.ink/2018-11-20-2.png" alt></p>
</li>
<li><p>这是后再次去存储空间-&gt;空间概览会发现域名状态是: 处理中</p>
<p><img src="http://cdn.funful.ink/2018-11-20-3.png" alt></p>
</li>
</ol>
<h2 id="配置CNAME"><a href="#配置CNAME" class="headerlink" title="配置CNAME"></a>配置CNAME</h2><ol>
<li><p>获得CNAME</p>
<p>上图点击我们的自定义域名就可以看到这个域名的基本信息,包括CNAME:将其复制下来.</p>
</li>
<li><p>打开阿里云官网-&gt;控制台-&gt;域名,在主域名下点击解析-&gt;添加记录</p>
</li>
<li><p>会出现如图设置:</p>
<p><img src="http://cdn.funful.ink/2018-11-20-4.png" alt></p>
</li>
</ol>
<p>上图的记录类型:选择CNAME;主机记录:就是我们七牛云自定义域名前缀;记录值:就是CNAME值;其他值默认就可以. 点击确认就配置好了CNAME</p>
<ol start="4">
<li>返回到七牛云我们的存储空间-&gt;空间概览会发现,融合CDN加速域名里面的域名状态已经成功了,如果是等待CNAME的话可能是需要等待几分钟.</li>
</ol>
<h1 id="使用存储空间"><a href="#使用存储空间" class="headerlink" title="使用存储空间"></a>使用存储空间</h1><p>上面已经配置好 进入储存空间-&gt;内容管理.选择外链默认域名之后就可以正常使用了,(外链域名不能使用七牛云的测试域名,因为这个测试域名只能使用一个月)</p>
<p><img src="http://cdn.funful.ink/2018-11-20-5.png" alt></p>
]]></content>
      <categories>
        <category>各个方面方案解决</category>
      </categories>
  </entry>
  <entry>
    <title>ES8266模块AT操作<多连接TCP通信></title>
    <url>/2019/05/14/ESP8266_Connect_TO_PhoneAndPC_WithTCP/</url>
    <content><![CDATA[<p>这个教程是基于ESP8266和手机与电脑的TCP通信。</p>
<a id="more"></a>

<h1 id="文档"><a href="#文档" class="headerlink" title="文档#"></a>文档#</h1><ul>
<li><a href="http://wiki.ai-thinker.com/_media/esp8266/docs/4a-esp8266_at_instruction_set_cn.pdf" target="_blank" rel="noopener">AT的指令集</a></li>
<li><a href="http://wiki.ai-thinker.com/_media/esp8266/docs/4b-esp8266_at_command_examples_cn.pdf" target="_blank" rel="noopener">AT的示例教程</a></li>
<li>Android版的TCP调试助手可以去软件库里面下载</li>
<li>PC版的调试助手可以去CSDN下载，链接 <a href="https://download.csdn.net/download/ajian0051/9478097" target="_blank" rel="noopener">Download</a></li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤#"></a>步骤#</h1><h2 id="ESP8266的AT操作"><a href="#ESP8266的AT操作" class="headerlink" title="ESP8266的AT操作##"></a>ESP8266的AT操作##</h2><ol>
<li>AT+RST（重启）</li>
<li>AT+RESTORE（恢复出厂设置，第一次操作建议不要，如果不能正常工作的话，可以执行该命令）</li>
<li>AT+CWMODE_DEF=3（WIFI模式（STA/AP/STA+AP））</li>
<li>AT+CWSAP=”OneNET”,”123456789”,1,3（设置ssoftAP的ssid，密码，通道号1，WAP2_PSK加密）</li>
<li>AT+CIPMUX=1（多连接）</li>
<li>AT+CIPSERVER=1,8080（设置TCP server 的端口号8080）</li>
<li>这样我们就设置好了，手机和电脑都可以正常连接到“OneNET”，我们还要注意下ESP8266的IP和端口，上面已经知道端口号是8080，服务器IP是192.168.4.1，可以使用”AT+CIFSR”得知。</li>
</ol>
<h2 id="手机端-amp-PC连接"><a href="#手机端-amp-PC连接" class="headerlink" title="手机端&amp;PC连接##"></a>手机端&amp;PC连接##</h2><ol>
<li><p>手机开启wifi连接OneNET</p>
</li>
<li><p>手机端打开TCP调试助手，设置如图，点击connect</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_picture.jpg" alt></p>
</li>
<li><p>电脑连接ESP8266的串口显示</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_1.png" alt></p>
</li>
<li><p>这就显示连接成功了，下来电脑端也连接”OneNET”，打开网络调试助手，设置如图</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_2.png" alt></p>
</li>
<li><p>上面四步我们就将手机和电脑作为TCP client 连接到电脑了，下面测试通信。</p>
</li>
</ol>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信##"></a>通信##</h2><h3 id="ESP8266接收"><a href="#ESP8266接收" class="headerlink" title="ESP8266接收###"></a>ESP8266接收###</h3><ol>
<li><p>手机端发送如图</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_5.jpg" alt></p>
</li>
<li><p>电脑端发送如图</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_3.png" alt></p>
</li>
<li><p>ESP8266串口显示</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_4.png" alt></p>
</li>
</ol>
<h3 id="ESP8266发送"><a href="#ESP8266发送" class="headerlink" title="ESP8266发送###"></a>ESP8266发送###</h3><ol>
<li><p>ESP82266多链接最多可以连接5个设备，上面我们知道手机分配的ID为0，电脑ID为1</p>
</li>
<li><p>先给手机端发送，执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+CIPSEND=&lt;link ID&gt;,&lt;length&gt;</span><br><span class="line">AT+CIPSEND=0,11（给ID0发送11个字节数据）</span><br><span class="line">OK</span><br><span class="line">&gt;</span><br><span class="line">Hello,PHONE</span><br></pre></td></tr></table></figure>

<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_8.jpg" alt></p>
</li>
<li><p>给电脑端发送，执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AT+CIPSEND=1,11（给ID1发送11个字节数据）</span><br><span class="line">OK</span><br><span class="line">&gt;</span><br><span class="line">Hello,PC</span><br></pre></td></tr></table></figure>

<p><img src="http://p9zz81nyl.bkt.clouddn.com/blog_7.png" alt></p>
</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结#"></a>总结#</h1><p>使用AT指令开发ESP8266，比较简单，但是ESP8266内置MCU，这使得浪费了硬件资源。这篇文章是基于TCP多连接的通信，至于单连接，就更简单了。</p>
]]></content>
      <categories>
        <category>ESP8266</category>
      </categories>
      <tags>
        <tag>AT指令集</tag>
        <tag>ESP8266</tag>
        <tag>TCP通信</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ2440的uboot-2009-11移植<2>_串口输出</title>
    <url>/2019/05/13/JZ2440_uboot_2009_11_transplant_2_%E6%94%AF%E6%8C%81%E4%B8%B2%E5%8F%A3/</url>
    <content><![CDATA[<p>整理下自己之前的移植uboot时记录的笔记！这个章节是对uboot的第一阶段的代码进行优化和代码的修改，使其可以正确的启动串口。</p>
<a id="more"></a>

<h2 id="修改启动代码"><a href="#修改启动代码" class="headerlink" title="修改启动代码"></a>修改启动代码</h2><ul>
<li><p>在上个章节，当我们编译完成之后会发现在根目录下面会有一个u-boot.lds的文件，这是链接文件，这个文件就在 u-boot-2016.09/arch/arm/cpu/u-boot.lds </p>
</li>
<li><p>进去之后发现，板子启动执行的第一个文件是start.S,代码流程      </p>
<h3 id="第一阶段启动代码修改"><a href="#第一阶段启动代码修改" class="headerlink" title="第一阶段启动代码修改"></a>第一阶段启动代码修改</h3><ul>
<li><p>设置cpu为SVC32 模式</p>
</li>
<li><p>关闭看门狗</p>
</li>
<li><p>屏蔽中断，这个地方我们需要添加对2440的支持，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 在</span><br><span class="line"> #if defined(CONFIG_S3C2410)</span><br><span class="line">	ldr	r1, =0x3ff</span><br><span class="line">	ldr	r0, =INTSUBMSK</span><br><span class="line">	str	r1, [r0]</span><br><span class="line">添加：</span><br><span class="line">#elif  defined(CONFIG_S3C2440)</span><br><span class="line">	ldr	r1, =0x7fff</span><br><span class="line">	ldr	r0, =INTSUBMSK</span><br><span class="line">	str	r1, [r0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置系统时钟，查看S3C2440的数据手册可以，FCLK:HCLK:PCLK=1:4:8,FCLK=405Mhz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改如下：</span><br><span class="line">	ldr	r0, =CLKDIVN</span><br><span class="line">	mov	r1, #5</span><br><span class="line">	str	r1, [r0]</span><br><span class="line">/**配置为异步模式**/</span><br><span class="line">	mrc p15, 0, r1, c1, c0, 0		</span><br><span class="line">	orr r1, r1, #0xc0000000 		</span><br><span class="line">	mcr p15, 0, r1, c1, c0, 0		</span><br><span class="line">#define S3C2440_MPLL_400MHZ 	((0x7f&lt;&lt;12)|(0x02&lt;&lt;4)|(0x01))/* </span><br><span class="line">	ldr r0, =0x4c000004</span><br><span class="line">	ldr r1, =S3C2440_MPLL_400MHZ</span><br><span class="line">	str r1, [r0]</span><br></pre></td></tr></table></figure>
</li>
<li><p>跳转到cpu_init_crit，关闭MMU，关闭I/D caches ,再进入lowlevel_init</p>
</li>
<li><p>lowlevel_init，这个是配置Memory控制器。 在u-boot-2016.09/board/samsung/myff2440/lowlevel_init.S</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上面我们修改了系统时钟的分频系数，所以此时的存储器控制器的SDRAM的刷新周期也需要更改，查数据手册，可知</span><br><span class="line">将</span><br><span class="line">#define REFCNT			1113	/* period=15.6us, HCLK=60Mhz, (2048+1-15.6*6.) */</span><br><span class="line">修改为：</span><br><span class="line">#define REFCNT			1269	/* period=7.8us, HCLK=100Mhz, (2048+1-7.8*100) */</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>然后进入 _main分支，也就是对第二阶段板子外设的设置， 位于uboot2016.9\ubootproject\u-boot-2016.09\arch\arm\lib\crt0.S</p>
</li>
</ul>
<h3 id="系统时钟移植"><a href="#系统时钟移植" class="headerlink" title="系统时钟移植"></a>系统时钟移植</h3><h4 id="添加s3c2440配置的宏"><a href="#添加s3c2440配置的宏" class="headerlink" title="添加s3c2440配置的宏"></a>添加s3c2440配置的宏</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">进入include/configs/myff2440.h</span><br><span class="line">将：</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> CONFIG_S3C2440		<span class="comment">/* specifically a SAMSUNG S3C2410 SoC */</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> CONFIG_MYFF2440		<span class="comment">/* on a SAMSUNG SMDK2410 Board */</span></span></span><br><span class="line">修改为：</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> CONFIG_S3C2440		<span class="comment">/* specifically a SAMSUNG S3C2410 SoC */</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> CONFIG_MYFF2440		<span class="comment">/* on a SAMSUNG SMDK2410 Board */</span></span></span><br></pre></td></tr></table></figure>

<h4 id="修改分频系数"><a href="#修改分频系数" class="headerlink" title="修改分频系数"></a>修改分频系数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">进入uboot2016<span class="number">.9</span>\ubootproject\u-boot<span class="number">-2016.09</span>\board\samsung\myff2440\Myff2440.c</span><br><span class="line">将：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FCLK_SPEED 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (FCLK_SPEED == 0)		<span class="comment">/* Fout = 203MHz, Fin = 12MHz for Audio */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_MDIV	0xC3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PDIV	0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_SDIV	0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (FCLK_SPEED == 1)		<span class="comment">/* Fout = 202.8MHz */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_MDIV	0xA1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PDIV	0x3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_SDIV	0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">修改为：</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FCLK_SPEED 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (FCLK_SPEED == 0)		<span class="comment">/* Fout = 203MHz, Fin = 12MHz for Audio */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_MDIV	0xC3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PDIV	0x4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_SDIV	0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> (FCLK_SPEED == 1)		<span class="comment">/* Fout = 405.8MHz */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_MDIV	0x7f        <span class="comment">/*查数据手册可知，为了是FCLK=405MHZ，这三个分频值依次是0x7f、0x2、0x1*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PDIV	0x2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M_SDIV	0x1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>​</p>
<h4 id="修改获取时钟函数"><a href="#修改获取时钟函数" class="headerlink" title="修改获取时钟函数"></a>修改获取时钟函数</h4><p>在：u-boot-2016.09\arch\arm\cpu\arm920t\s3c24x0\Speed.c</p>
<ul>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">将：</span><br><span class="line"><span class="function"><span class="keyword">static</span> ulong <span class="title">get_PLLCLK</span><span class="params">(<span class="keyword">int</span> pllreg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s3c24x0_clock_power</span> *<span class="title">clk_power</span> = <span class="title">s3c24x0_get_base_clock_power</span>();</span></span><br><span class="line">        ulong r, m, p, s;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pllreg == MPLL)</span><br><span class="line">                r = readl(&amp;clk_power-&gt;mpllcon);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pllreg == UPLL)</span><br><span class="line">                r = readl(&amp;clk_power-&gt;upllcon);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                hang();</span><br><span class="line">        m = ((r &amp; <span class="number">0xFF000</span>) &gt;&gt; <span class="number">12</span>) + <span class="number">8</span>;</span><br><span class="line">        p = ((r &amp; <span class="number">0x003F0</span>) &gt;&gt; <span class="number">4</span>) + <span class="number">2</span>;</span><br><span class="line">        s = r &amp; <span class="number">0x3</span>;</span><br><span class="line">        <span class="keyword">return</span> (CONFIG_SYS_CLK_FREQ * m) / (p &lt;&lt; s);</span><br><span class="line">&#125;</span><br><span class="line">修改为：</span><br><span class="line"><span class="function"><span class="keyword">static</span> ulong <span class="title">get_PLLCLK</span><span class="params">(<span class="keyword">int</span> pllreg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s3c24x0_clock_power</span> *<span class="title">clk_power</span> = <span class="title">s3c24x0_get_base_clock_power</span>();</span></span><br><span class="line">        ulong r, m, p, s;</span><br><span class="line">        <span class="keyword">if</span> (pllreg == MPLL)</span><br><span class="line">                r = readl(&amp;clk_power-&gt;mpllcon);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pllreg == UPLL)</span><br><span class="line">                r = readl(&amp;clk_power-&gt;upllcon);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                hang();</span><br><span class="line">        m = ((r &amp; <span class="number">0xFF000</span>) &gt;&gt; <span class="number">12</span>) + <span class="number">8</span>;</span><br><span class="line">        p = ((r &amp; <span class="number">0x003F0</span>) &gt;&gt; <span class="number">4</span>) + <span class="number">2</span>;</span><br><span class="line">        s = r &amp; <span class="number">0x3</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_S3C2440)</span></span><br><span class="line">        <span class="keyword">if</span> (pllreg == MPLL)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span> * m * (CONFIG_SYS_CLK_FREQ / (p &lt;&lt; s));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> (CONFIG_SYS_CLK_FREQ * m) / (p &lt;&lt; s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">将：</span><br><span class="line"><span class="function">ulong <span class="title">get_HCLK</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s3c24x0_clock_power</span> *<span class="title">clk_power</span> = <span class="title">s3c24x0_get_base_clock_power</span>();</span></span><br><span class="line">        <span class="keyword">return</span> (readl(&amp;clk_power-&gt;clkdivn) &amp; <span class="number">2</span>) ? get_FCLK() / <span class="number">2</span> : get_FCLK();</span><br><span class="line">&#125;</span><br><span class="line">修改为：</span><br><span class="line"><span class="function">ulong <span class="title">get_HCLK</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">s3c24x0_clock_power</span> *<span class="title">clk_power</span> = <span class="title">s3c24x0_get_base_clock_power</span>();</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_S3C2440</span></span><br><span class="line">        <span class="keyword">switch</span> (readl(&amp;clk_power-&gt;clkdivn) &amp; <span class="number">0x6</span>) &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> get_FCLK();</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> get_FCLK() / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> (readl(&amp;clk_power-&gt;camdivn) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">9</span>)) ?</span><br><span class="line">                        get_FCLK() / <span class="number">8</span> : get_FCLK() / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="keyword">return</span> (readl(&amp;clk_power-&gt;camdivn) &amp; (<span class="number">1</span> &lt;&lt; <span class="number">8</span>)) ?</span><br><span class="line">                        get_FCLK() / <span class="number">6</span> : get_FCLK() / <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> (readl(&amp;clk_power-&gt;clkdivn) &amp; <span class="number">2</span>) ? get_FCLK() / <span class="number">2</span> : get_FCLK();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="添加摄像头分频寄存器CAMDIVN"><a href="#添加摄像头分频寄存器CAMDIVN" class="headerlink" title="添加摄像头分频寄存器CAMDIVN"></a>添加摄像头分频寄存器CAMDIVN</h4><p>因为我们在修改get_HCLK函数时，用到了camera寄存器所以我们需要添加相关的宏。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">在：u-boot<span class="number">-2016.09</span>\arch\arm\include\<span class="keyword">asm</span>\arch-s3c24x0\S3c24x0.h</span><br><span class="line">将：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3c24x0_clock_power</span> &#123;</span></span><br><span class="line">	u32	locktime;</span><br><span class="line">	u32	mpllcon;</span><br><span class="line">	u32	upllcon;</span><br><span class="line">	u32	clkcon;</span><br><span class="line">	u32	clkslow;</span><br><span class="line">	u32	clkdivn;</span><br><span class="line">&#125;;</span><br><span class="line">修改为：</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3c24x0_clock_power</span> &#123;</span></span><br><span class="line">	u32	locktime;</span><br><span class="line">	u32	mpllcon;</span><br><span class="line">	u32	upllcon;</span><br><span class="line">	u32	clkcon;</span><br><span class="line">	u32	clkslow;</span><br><span class="line">	u32	clkdivn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_S3C2440)</span></span><br><span class="line">	u32	camdivn;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="支持CONFIG-S3C2440-CONFIG-MYFF2440的宏配置"><a href="#支持CONFIG-S3C2440-CONFIG-MYFF2440的宏配置" class="headerlink" title="支持CONFIG_S3C2440/CONFIG_MYFF2440的宏配置"></a>支持CONFIG_S3C2440/CONFIG_MYFF2440的宏配置</h3><p>在前面我们修改板级支持的头文件中，我们修改了两个宏下面我们需要将系统中的CONFIG_S3C2410替换成CONFIG_S3C2440，将CONFIG_SMDK2410替换成CONFIG_MYFF2440</p>
<p>在ubuntu的根目录下，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find .|xargs grep -ri "CONFIG_S3C2410" -l</span><br></pre></td></tr></table></figure>

<p> 会列出包含CONFIG_S3C2410的文件，将其替换，</p>
<p>同理执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find .|xargs grep -ri &quot;CONFIG_SMDK2410&quot; -l</span><br></pre></td></tr></table></figure>

<p>也将其替换</p>
<h2 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h2><p>经过上面这几个步骤我们执行如下命令：</p>
<p> 在u-boot-2009.11的顶层目录，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make MyFF2440_config&amp;&amp;make</span><br></pre></td></tr></table></figure>

<p>不出意外的话，就可以顺利生成u-boot.bin文件，烧进板子里面nor 启动，串口就能正常输出    </p>
<img src="http://p9zz81nyl.bkt.clouddn.com/1.jpg">

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>我们在注释的时候尽量使用“/**/”符号，不要用“//”,因为有些交叉编译器不识别单行注释</p>
<p>​</p>
</li>
</ul>
]]></content>
      <categories>
        <category>uboot移植</category>
      </categories>
      <tags>
        <tag>移植</tag>
        <tag>arm</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ2440的uboot-2009-11移植<3>_支持Nor Flash</title>
    <url>/2019/05/13/JZ2440_uboot_2009_11_transplant_3_nor_flash/</url>
    <content><![CDATA[<p>这一节是对第二阶段的代码进行移植，来支持Nor Flash</p>
<a id="more"></a>

<h2 id="硬件环境"><a href="#硬件环境" class="headerlink" title="硬件环境"></a>硬件环境</h2><h3 id="Nor-Flash介绍"><a href="#Nor-Flash介绍" class="headerlink" title="Nor Flash介绍"></a>Nor Flash介绍</h3><p>Nor Flash 是一种存储芯片，支持掉电存储、支持Executensil On Chip（片上程序运行）。所以很适合作为嵌入式中启动程序的存储介质。但是由于低写速度和擦除速度影响着他的性能，在1~16MB的闪存中较为常见。</p>
<h3 id="MX29LV160D-T-B-芯片"><a href="#MX29LV160D-T-B-芯片" class="headerlink" title="MX29LV160D T/B 芯片"></a>MX29LV160D T/B 芯片</h3><ol>
<li><p>2MB的Flash（8位/16位） ,JZ2440选用数据宽度的16位</p>
</li>
<li><p>扇区分布;</p>
<table>
<thead>
<tr>
<th>大小</th>
<th>8K-Byte</th>
<th>16K-Byte</th>
<th>32K-Byte</th>
<th>64K-Byte</th>
</tr>
</thead>
<tbody><tr>
<td>块数</td>
<td>2</td>
<td>1</td>
<td>1</td>
<td>31</td>
</tr>
</tbody></table>
</li>
<li><p>Word/Byte 模式选择，如果选用Word时需要错位连接</p>
</li>
<li><p>工作电压2.7V~3.6V</p>
</li>
<li><p>引脚封装48pin-TSOP/48ball-XFLGA/WFBGA</p>
</li>
<li><p>至少可靠性保存数据20年，擦除、编程次数10万个周期</p>
</li>
</ol>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>我们之前顺腾摸瓜，从start.S-&gt;crt0.S，在crt0.S中分别调用了两个函数：board_init_f和board_init_r。</p>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">board_init_f 位于u-boot<span class="number">-2016.09</span>\common\Board_f.c</span><br><span class="line">board_init_r 位于u-boot<span class="number">-2016.09</span>\common\Board_r.c</span><br></pre></td></tr></table></figure>

<h4 id="board-init-f功能"><a href="#board-init-f功能" class="headerlink" title="board_init_f功能"></a>board_init_f功能</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">主要是初始化下面这些</span><br><span class="line">timer_init,        <span class="comment">/* initialize timer */</span></span><br><span class="line">get_clocks,</span><br><span class="line">env_init,        </span><br><span class="line">init_baud_rate,        <span class="comment">/* initialze baudrate settings */</span></span><br><span class="line">serial_init,        <span class="comment">/* serial communications setup */</span></span><br><span class="line">console_init_f,        <span class="comment">/* stage 1 init of console */</span></span><br></pre></td></tr></table></figure>

<h4 id="board-init-r功能"><a href="#board-init-r功能" class="headerlink" title="board_init_r功能"></a>board_init_r功能</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">board_init,</span><br><span class="line">initr_flash</span><br><span class="line">initr_nand,</span><br></pre></td></tr></table></figure>

<h4 id="代码解读"><a href="#代码解读" class="headerlink" title="代码解读"></a>代码解读</h4><p>所以我们知道nor flash的设置在board_init_r里面，</p>
<ol>
<li><p>进入到static int initr_flash(void) ，位于（common\Board_r.c）</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flash_info[i].flash_id = FLASH_UNKNOWN;从这一句我们可以看出来flash__info是存储Nor flash信息的结构体</span><br><span class="line"> if (!flash_detect_legacy(cfi_fla sh_bank_addr(i), i))</span><br><span class="line">  flash_detect_legacy(phys_addr_t base, int banknum)</span><br><span class="line">       if (jedec_flash_match(info, info-&gt;start[0]))</span><br><span class="line">          int jedec_flash_match(flash_info_t *info, ulong base)    将读取到的板子ID和已有板子信息做对比</span><br><span class="line">           &#123;                                                                                             int ret = 0;                                                                                  int i;                                                                                      ulong mask = 0xFFFF;                                                                         if (info-&gt;chipwidth == 1)                                                                     mask = 0xFF;                                                                             for (i = 0; i &lt; ARRAY_SIZE(jedec_table); i++) &#123;                                               if ((jedec_table[i].mfr_id &amp; mask) == (info-&gt;manufacturer_id &amp; mask) &amp;&amp;                          (jedec_table[i].dev_id &amp; mask) == (info-&gt;device_id &amp; mask)) &#123;                                  fill_info(info, &amp;jedec_table[i], base);                                                        ret = 1;                                                                                  break;                                                                      &#125;                                                                                           return ret;                                                                             &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 代码修改1</span><br><span class="line"></span><br><span class="line">上面分析完 ，我们就可以知道，我们只要将上面函数的饿 jedec_table结构体增加我们对应的信息就行了</span><br><span class="line"></span><br><span class="line"> ```c</span><br><span class="line">修改添加  static const struct amd_flash_info jedec_table[]   结构体</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="位置-1"><a href="#位置-1" class="headerlink" title="位置"></a>位置</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">drivers\mtd\Jedec_flash.c</span><br></pre></td></tr></table></figure>

<h5 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 在结构体补充相应的信息</span><br><span class="line">&#123;      /*  sheldon add for JZ2440_V2 Nor_Flash ： MT29LV160DB */                                         .mfr_id     = (u16)MX_MANUFACT,   //厂家 id                                                     .dev_id     = 0x2249,   //设备 id                                                      </span><br><span class="line">        .name       = &quot;MX29LV160D&quot;,                                                   </span><br><span class="line">        .uaddr      = &#123;                                                               </span><br><span class="line">          [1] = MTD_UADDR_0x0555_0x02AA /* 1:x16 ,NOR Flash 的解锁地址 */</span><br><span class="line">               &#125;,                                                                            </span><br><span class="line">          .DevSize    = SIZE_2MiB,              //整个 nor flash 的大小                                      .CmdSet     = P_ID_AMD_STD,                                          </span><br><span class="line">           .NumEraseRegions= 4,       //擦除域，有几种大小的块就有几个擦除域，                                .regions    = &#123;    //查看芯片手册设置擦除块                                                         ERASEINFO(0x10000, 31),             //参照芯片手册里面的块信息                                     ERASEINFO(0x08000, 1),                                                    </span><br><span class="line">	      ERASEINFO(0x02000, 2),                                                    </span><br><span class="line">            ERASEINFO(0x04000, 1),                                                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="代码修改2"><a href="#代码修改2" class="headerlink" title="代码修改2"></a>代码修改2</h4><p> 我们还要修改myff244.h的一个宏   </p>
<p> /#define CONFIG_SYS_MAX_FLASH_SECT    (128)                     </p>
<p> 因为我们的最大快区大于19了</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>重新编译uboot 下载到板子里面，就可以看到成功。</p>
<p>虽然我们看到串口打印出来的信息显示支持Flash，但是我们要测试下是否真的支持了</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/2.png" alt></p>
<ol>
<li><p>进入到uboot的命令行</p>
</li>
<li><p>输入：flinfo</p>
<p><img src="http://p9zz81nyl.bkt.clouddn.com/3.png" alt="img"></p>
<p> 可见扇区地址，扇区数、设备ID和厂商ID都是正确的。接下来进一步确认正确与否</p>
</li>
<li><p>查看命令 </p>
<p>md.b  A0000 10   查看0x50000地址开始的10个字节数据（）</p>
</li>
<li><p>拷贝命令</p>
<p>  cp 30008000  A0000 10  将30008000的10个字节拷贝到A0000（A0000的地址不能低于uboot.bin的size，如果低于u-boot.bin的size ，一旦拷贝就会损坏u-boot）</p>
</li>
<li><p>擦除命令   </p>
<p> erase  A0000  Affff   擦除A0000~Affff之间的内容</p>
<p>以上这几个操作均正常，说明设备已经支持Nor flash </p>
<p><br> <span> <font color="red" size="7 ">NOR FLASH  移植成功</font></span></p>
</li>
</ol>
<p>   ​</p>
<p>   ​</p>
<p>   ​</p>
<p>   ​</p>
]]></content>
      <categories>
        <category>uboot移植</category>
      </categories>
      <tags>
        <tag>移植</tag>
        <tag>arm</tag>
        <tag>linux</tag>
        <tag>Nor Flash</tag>
      </tags>
  </entry>
  <entry>
    <title>JZ2440的uboot-2009-11 移植<1></title>
    <url>/2019/05/12/JZ2440_uboot_2009_11_transplant_1/</url>
    <content><![CDATA[<p>整理下自己之前的移植uboot时记录的笔记！</p>
<a id="more"></a>

<h2 id="移植环境："><a href="#移植环境：" class="headerlink" title="移植环境："></a>移植环境：</h2><p>arm板子：JZ2440</p>
<p>uboot版本：2009-11</p>
<p>交叉编译链：arm-none-linux-gcc-4.4.3</p>
<h2 id="下载："><a href="#下载：" class="headerlink" title="下载："></a>下载：</h2><p>uboot官方下载地址:<a href="ftp://ftp.denx.de/pub/u-boot" target="_blank" rel="noopener">uboot官方下载</a>,  </p>
<p>交叉编译链:<a href>github.com/funful/Tools</a></p>
<h2 id="uboot的启动流程"><a href="#uboot的启动流程" class="headerlink" title="uboot的启动流程"></a>uboot的启动流程</h2><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ol>
<li>硬件设备初始化</li>
<li>加载u-boot第二阶段代码到RAM的空间</li>
<li>设置好栈</li>
<li>跳转到第二阶段的代码入口</li>
</ol>
<h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ol>
<li>初始化本阶段所使用的硬件设备                                                 </li>
<li>检测系统内存映射</li>
<li>将内核从Flash读取到RAM中</li>
<li>为内核设置启动参数</li>
<li>调用内核</li>
</ol>
<h2 id="建立2440的配置"><a href="#建立2440的配置" class="headerlink" title="建立2440的配置"></a>建立2440的配置</h2><p>uboot-2009-11和之前的版本相比，有一点变化，我们在u-boot-2016.09/configs 可以看到各种板级支持配置，由于2440和2410相差不大，所以我们根据2410，来添加2440的配置</p>
<h3 id="修改根目录的Makefile"><a href="#修改根目录的Makefile" class="headerlink" title="修改根目录的Makefile"></a>修改根目录的Makefile</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment">#设置股下面两个变量</span></span><br><span class="line">ARCH = arm</span><br><span class="line">CROSS_COMPILE = arm-none-linux-gnueabi-</span><br></pre></td></tr></table></figure>

<h3 id="添加my2440配置文件"><a href="#添加my2440配置文件" class="headerlink" title="添加my2440配置文件"></a>添加my2440配置文件</h3><h4 id="新建配置文件"><a href="#新建配置文件" class="headerlink" title="新建配置文件"></a>新建配置文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp u-boot-2016.05/configs/smdk2410_defconfig   u-boot-2016.05/configs/my2440_defconfig</span><br></pre></td></tr></table></figure>

<p>上面这条命令新建了my2440的板子配置</p>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gedit u-boot-2016.05/configs/my2440_defconfig</span><br></pre></td></tr></table></figure>

<h4 id="改动前后的内容如下"><a href="#改动前后的内容如下" class="headerlink" title="改动前后的内容如下:"></a>改动前后的内容如下:</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">改动前：</span><br><span class="line">	CONFIG_ARM=y</span><br><span class="line">	CONFIG_TARGET_SMDK2410=y</span><br><span class="line">	CONFIG_HUSH_PARSER=y</span><br><span class="line">	CONFIG_SYS_PROMPT="SMDK2410 # "</span><br><span class="line">	CONFIG_CMD_USB=y</span><br><span class="line"><span class="meta">	#</span> CONFIG_CMD_SETEXPR is not set</span><br><span class="line">	CONFIG_CMD_DHCP=y</span><br><span class="line">	CONFIG_CMD_PING=y</span><br><span class="line">	CONFIG_CMD_CACHE=y</span><br><span class="line">	CONFIG_CMD_EXT2=y</span><br><span class="line">	CONFIG_CMD_FAT=y</span><br><span class="line">改动后：</span><br><span class="line">    CONFIG_ARM=y</span><br><span class="line">    CONFIG_TARGET_MY2440=y      </span><br><span class="line">    CONFIG_HUSH_PARSER=y</span><br><span class="line">    CONFIG_SYS_PROMPT="MY2440 # "  #修改成我们自己板子名称</span><br><span class="line">    CONFIG_CMD_USB=y</span><br><span class="line">    # CONFIG_CMD_SETEXPR is not set</span><br><span class="line">    CONFIG_CMD_DHCP=y</span><br><span class="line">    CONFIG_CMD_PING=y</span><br><span class="line">    CONFIG_CMD_CACHE=y</span><br><span class="line">    CONFIG_CMD_EXT2=y</span><br><span class="line">    CONFIG_CMD_FAT=y</span><br></pre></td></tr></table></figure>

<h3 id="添加my2440板级支持文件"><a href="#添加my2440板级支持文件" class="headerlink" title="添加my2440板级支持文件"></a>添加my2440板级支持文件</h3><p>上一个步骤我们已经添加了配置文件，下面我们来添加支持文件，让编译器通过.UBoot源码中大部分和板子相关的代码在board目录下</p>
<h4 id="新建板级支持-c文件"><a href="#新建板级支持-c文件" class="headerlink" title="新建板级支持.c文件"></a>新建板级支持.c文件</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp -rf u-boot-2016.05/board/samsung/smdk2410/     u-boot-2016.05/board/samsung/my2440/</span><br></pre></td></tr></table></figure>

<h4 id="将板级支持文件和板级配置文件关联"><a href="#将板级支持文件和板级配置文件关联" class="headerlink" title="将板级支持文件和板级配置文件关联"></a>将板级支持文件和板级配置文件关联</h4><ol>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gedit u-boot-2016.05/arch/arm/Kconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到2410的配置，来在下面添加2440配置</p>
   <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">在：</span><br><span class="line">config TARGET_SMDK2410</span><br><span class="line">	bool <span class="string">"Support smdk2410"</span></span><br><span class="line">	select CPU_ARM920T</span><br><span class="line">添加：  <span class="comment">#注意Kconfig的语法，需要使用[Tab]键，缩进</span></span><br><span class="line">config TARGET_MY2440</span><br><span class="line">	bool <span class="string">"Support my2440"</span></span><br><span class="line">	select CPU_ARM920T</span><br><span class="line">在：</span><br><span class="line">source <span class="string">"board/samsung/smdk2410/Kconfig"</span></span><br><span class="line">添加：</span><br><span class="line">source <span class="string">"board/samsung/myff2440/Kconfig"</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="修改板级支持文件夹里的Kconfig"><a href="#修改板级支持文件夹里的Kconfig" class="headerlink" title="修改板级支持文件夹里的Kconfig"></a>修改板级支持文件夹里的Kconfig</h4><ol>
<li><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gedit u-boot-<span class="number">2016.05</span>/board/samsung/my2440/Kconfig</span><br><span class="line">配置文件打开后，可以看到很多配置还都是smdk2410的配置:</span><br><span class="line"><span class="keyword">if</span> TARGET_SMDK2410</span><br><span class="line">config SYS_BOARD</span><br><span class="line">	default <span class="string">"smdk2410"</span></span><br><span class="line"></span><br><span class="line">config SYS_VENDOR</span><br><span class="line">	default <span class="string">"samsung"</span></span><br><span class="line">config SYS_SOC</span><br><span class="line">	default <span class="string">"s3c24x0"</span></span><br><span class="line">config SYS_CONFIG_NAME</span><br><span class="line">	default <span class="string">"smdk2410"</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line">修改为：</span><br><span class="line"><span class="keyword">if</span> TARGET_MYFF2440</span><br><span class="line"></span><br><span class="line">config SYS_BOARD</span><br><span class="line">	default <span class="string">"myff2440"</span></span><br><span class="line">config SYS_VENDOR</span><br><span class="line"> 	default <span class="string">"samsung"</span></span><br><span class="line">config SYS_SOC</span><br><span class="line">	default <span class="string">"s3c24x0"</span></span><br><span class="line">config SYS_CONFIG_NAME</span><br><span class="line">	default <span class="string">"myff2440"</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="修改板级支持文件名字"><a href="#修改板级支持文件名字" class="headerlink" title="修改板级支持文件名字"></a>修改板级支持文件名字</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv u-boot-2016.05/board/samsung/my2440/smdk2410.c   u-boot-2016.05/board/samsung/my2440/my2440.c</span><br></pre></td></tr></table></figure>

<h4 id="修改板级支持文件夹里的my2440-c"><a href="#修改板级支持文件夹里的my2440-c" class="headerlink" title="修改板级支持文件夹里的my2440.c"></a>修改板级支持文件夹里的my2440.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gedit u-boot<span class="number">-2016.05</span>/board/samsung/my2440/my2440.c</span><br><span class="line">打开后搜索: SMDK2410</span><br><span class="line">将</span><br><span class="line"> gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2410;</span><br><span class="line"> 该为：</span><br><span class="line"> gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_MINI2440;</span><br></pre></td></tr></table></figure>

<p>  这里板子底层初始化部分先暂时使用MINI2440板子的参数配置，目的先是为了编译能通过。</p>
<h4 id="修改板级支持文件夹里的Makefile"><a href="#修改板级支持文件夹里的Makefile" class="headerlink" title="修改板级支持文件夹里的Makefile"></a>修改板级支持文件夹里的Makefile</h4><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">gedit u-boot-<span class="number">2016.05</span>/board/samsung/my2440/Makefile</span><br><span class="line">修改前：</span><br><span class="line">       obj-y := smdk2410.o</span><br><span class="line">       obj-y += lowlevel_init.o</span><br><span class="line">修改后：</span><br><span class="line">       obj-y:= my2440.o</span><br><span class="line">       obj-y += lowlevel_init.o</span><br></pre></td></tr></table></figure>

<h4 id="修改my2440-c的头文件"><a href="#修改my2440-c的头文件" class="headerlink" title="修改my2440.c的头文件"></a>修改my2440.c的头文件</h4><ol>
<li><p>添加my2440的头文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp u-boot-2016.05/include/configs/smdk2410.h</span><br><span class="line">u-boot-2016.05/include/configs/my2440.h</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gedit   u-boot-2016.05/include/configs/my2440.h</span><br><span class="line">修改前：</span><br><span class="line">       #define CONFIG_S3C24X0 /* This is a SAMSUNG S3C24x0-type SoC */</span><br><span class="line">       #define CONFIG_S3C2410 /* specifically a SAMSUNG S3C2410 SoC */</span><br><span class="line">       #define CONFIG_SMDK2410 /* on a SAMSUNG SMDK2410 Board */</span><br><span class="line">修改后：</span><br><span class="line">       #define CONFIG_S3C24X0 /* This is a SAMSUNG S3C24x0-type SoC */</span><br><span class="line">       #define CONFIG_S3C2440/* specifically a SAMSUNG S3C2440 SoC */</span><br><span class="line">       #define CONFIG_MY2440/* on custom my2440 Board */</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="编译调试"><a href="#编译调试" class="headerlink" title="编译调试"></a>编译调试</h2><ol>
<li><p>进入源码目录,cd u-boot-2016.09-11</p>
</li>
<li><p>在编译前先清空一次目录,sudo make distclean</p>
</li>
<li><p>修改编译配置,make my2440_config</p>
</li>
<li><p>make</p>
</li>
<li><p>sudo make</p>
</li>
<li><p>不出意外的话，就能顺利通过，如果没有通过的话，我们可以看看根目录下的.config文件的配置是够正确</p>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>uboot移植</category>
      </categories>
      <tags>
        <tag>移植</tag>
        <tag>arm</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH基本原理及使用<一></title>
    <url>/2019/03/30/2019-3-30_SSH/</url>
    <content><![CDATA[<p>SSH（Secure  shell）是一种安全远程登录的协议，ssh与telnet、ftp等的区别就是安全性， SSH采用非对称加密保证数据安全性。ssh有商用的，开源的，这里使用的是OpenSSH，开源软件。</p>
<a id="more"></a>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>虚拟机：VMware</li>
<li>本地系统：Red Hat Enterprise Linux Server release 7.6 (Maipo)</li>
<li>云服务器：CentOS Linux release 7.2.1511(阿里云)</li>
</ul>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h2><p>SSH是一种网络传输协议，在传输之前，需要建立一个安全的传输通道，这个过程就会使用到对称加密算法和非对称加密算法，下面将对这两种算法进行分析。</p>
<h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>对称加密顾名思义就是加加密过程和解密过程使用同一个秘钥，任何拥有该秘钥的人可以加密和解密数据，对称加密的加密强度高，几乎很难破解，但是在使用过程中会面临如何保存秘钥的问题，基本上一个服务器会有很多客户端进行登录，如果有一个人泄露，那么数据也会被泄露，非对称加密就出现了。</p>
<h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>非对称加密是需要公钥和私钥配合工作，也就是公钥加密，私钥解密。常见的非对称加密算法有rsa和dsa。非对称加密流程如下：</p>
<ol>
<li>初次远程Server收到Client的登录请求之后，Server发送公钥到Client。</li>
<li>Client收到公钥之后，验证其公钥是否为Server公钥。</li>
<li>继续，Client会将密码通过公钥加密，然后发送到Server</li>
<li>Server使用私钥解密后，验证密码的合法性，然后告知Client是否登录成功。</li>
</ol>
<p>公钥是公开的，我们可以使用公钥加密私钥解密，也可以公钥解密私钥加密，会发现这两个过程很相似。你私钥加密后发出数据，所有知道公钥的人都可以解密，并且公钥是公开的，所以这个过程是有风险的，这也就出现数字签名。</p>
<h2 id="RSA数字签名"><a href="#RSA数字签名" class="headerlink" title="RSA数字签名"></a>RSA数字签名</h2><p>数字签名主要是为了证明传输数据的真实性和完整性，通过这个数字签名的验证，可以保障数据真是完整。其实就是对一份数据打个标记，证明发送方本人发送出去的数据，而且数据完整真实。非对称加密算法中，如果私钥加密，公钥解密，就不能保证数据真实完整，这就需要用到数字签名，具体过程如下：</p>
<p>假设A拥有私钥，B有公钥，A要给B发送信息。</p>
<ol>
<li>A发送信息使用到数字签名，A把要发送的数据使用Hash函数生成摘要，然后使用私钥将这个摘要生成数字签名。</li>
<li>A将数据和数字签名一起发送给B。</li>
<li>B收到数据之后，将数字签名取下，通过公钥解密得到摘要。B将数据通过Hash函数得到摘要，B对比这两个摘要就可以知道数据是否完整真实。</li>
</ol>
<p>参考网址<a href="www.youdzone.com/signature.htmll">阮一峰</a></p>
<h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>ssh分为客户端和服务器端，Redhat操作系统默认安装客户端和服务器端。具体的配置文件在/etc/ssh下面，ssh_config是对客户端功能配置，sshd_config是服务器端功能配置 。在这两个配置文件里面加#表示默认配置。</p>
<h2 id="客户端配置文件"><a href="#客户端配置文件" class="headerlink" title="客户端配置文件"></a>客户端配置文件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Host *        #表示对能匹配字符串的计算机有效，*代表所有计算机。</span><br><span class="line">#   ForwardAgent no   #连接是否经过验证代理</span><br><span class="line">#   ForwardX11 no     #设置X11连接是否被自动重定向到安全的通道和显示集</span><br><span class="line">#   RhostsRSAAuthentication no   #设置是否使用RSA算法的rhosts的安全验证</span><br><span class="line">#   RSAAuthentication yes       # 设置是否使用RSA算法安全验证</span><br><span class="line">#   PasswordAuthentication yes  #设置是否使用口令验证</span><br><span class="line">#   HostbasedAuthentication no  #</span><br><span class="line">#   GSSAPIAuthentication no</span><br><span class="line">#   GSSAPIDelegateCredentials no</span><br><span class="line">#   GSSAPIKeyExchange no</span><br><span class="line">#   GSSAPITrustDNS no</span><br><span class="line">#   BatchMode no    #批处理模式 ，交互时输入口令提示将被禁止</span><br><span class="line">#   CheckHostIP yes  #设置ssh是否查看连接到服务器的主机的IP地址，防止DNS欺骗</span><br><span class="line">#   AddressFamily any</span><br><span class="line">#   ConnectTimeout <span class="number">0</span>          </span><br><span class="line">#   StrictHostKeyChecking ask  #询问计算机是否将服务器</span><br><span class="line">#   IdentityFile ~/.ssh/identity</span><br><span class="line">#   IdentityFile ~/.ssh/id_rsa</span><br><span class="line">#   IdentityFile ~/.ssh/id_dsa</span><br><span class="line">#   IdentityFile ~/.ssh/id_ecdsa</span><br><span class="line">#   IdentityFile ~/.ssh/id_ed25519</span><br><span class="line">#    Port <span class="number">22</span>     #连接服务器的端口号，</span><br><span class="line">#   Protocol <span class="number">2</span></span><br><span class="line">#   Cipher <span class="number">3</span>des    #设置加密密码</span><br><span class="line">#   Ciphers aes128-ctr,aes192-ctr,aes256-ctr,arcfour256,arcfour128,aes128-cbc,<span class="number">3</span>des-cbc</span><br><span class="line">#   MACs hmac-md5,hmac-sha1,umac<span class="number">-64</span>@openssh.com,hmac-ripemd160</span><br><span class="line">#   EscapeChar ~    #设置escape字符</span><br><span class="line">#   Tunnel no      </span><br><span class="line">#   TunnelDevice any:any</span><br><span class="line">#   PermitLocalCommand no</span><br><span class="line">#   VisualHostKey no</span><br><span class="line">#   ProxyCommand ssh -q -W %h:%p gateway.example.com</span><br><span class="line">#   RekeyLimit <span class="number">1</span>G <span class="number">1</span>h</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<h2 id="服务器配置文件"><a href="#服务器配置文件" class="headerlink" title="服务器配置文件"></a>服务器配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Port 22   #服务器监听端口号，默认22</span><br><span class="line">#AddressFamily any</span><br><span class="line">#ListenAddress 0.0.0.0  #服务器监听的IP，默认为所有IP</span><br><span class="line">#ListenAddress ::</span><br><span class="line">#Protocol 2 #SSH使用的是SSH2协议</span><br><span class="line">HostKey /etc/ssh/ssh_host_rsa_key  #设置服务器秘钥路径</span><br><span class="line">#HostKey /etc/ssh/ssh_host_dsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ecdsa_key</span><br><span class="line">HostKey /etc/ssh/ssh_host_ed25519_key</span><br><span class="line">#RekeyLimit default none</span><br><span class="line">#SyslogFacility AUTH</span><br><span class="line">SyslogFacility AUTHPRIV </span><br><span class="line">#LogLevel INFO   #SSHD日志消息级别</span><br><span class="line"># Authentication:   #限制用户必须在指定的时限内认证成功，0 表示无限制。默认值是 120 秒。</span><br><span class="line">#LoginGraceTime 2m  #用来设定如果用户登录失败，在切断连接前服务器需要等待的时间，单位为妙</span><br><span class="line">#PermitRootLogin no  #是否允许root远程登录，默认不允许，</span><br><span class="line">#StrictModes yes   #StrictModes用来设置ssh在接收登录请求之前是否检查用户根目录和rhosts文件的权限和所有权</span><br><span class="line">#MaxAuthTries 6    #设置最大失败尝试登录次数</span><br><span class="line">#MaxSessions 10    #设置ssh最大联机个数，就是登录ssh，没有输入密码时。已经登录的不计算在内。</span><br><span class="line"></span><br><span class="line">#PubkeyAuthentication  yes #用来设置是否开启公钥验证，如果使用公钥验证的方式登录时，则设置为yes</span><br><span class="line">AuthorizedKeysFile	.ssh/authorized_keys  #设置公钥验证文件地址</span><br><span class="line">#AuthorizedPrincipalsFile none</span><br><span class="line">#AuthorizedKeysCommand none</span><br><span class="line">#AuthorizedKeysCommandUser nobody</span><br><span class="line">#HostbasedAuthentication no  </span><br><span class="line">#IgnoreUserKnownHosts no</span><br><span class="line"># Don&apos;t read the user&apos;s ~/.rhosts and ~/.shosts files</span><br><span class="line">#IgnoreRhosts yes   #验证的时候是否使用这两个文件</span><br><span class="line"># To disable tunneled clear text passwords, change to no here!</span><br><span class="line">#PasswordAuthentication yes  #用来设置是否开启密码验证机制，如果用密码登录系统，则设置yes</span><br><span class="line">#PermitEmptyPasswords no     #是否密码为空的用户可以登录</span><br><span class="line"># Change to no to disable s/key passwords</span><br><span class="line">ChallengeResponseAuthentication no   #是否允许质疑-应答(challenge-response)认证</span><br><span class="line"></span><br><span class="line"># Kerberos options</span><br><span class="line">#KerberosAuthentication no</span><br><span class="line">#KerberosOrLocalPasswd yes</span><br><span class="line">#KerberosTicketCleanup yes</span><br><span class="line">#KerberosGetAFSToken no</span><br><span class="line">#KerberosUseKuserok yes</span><br><span class="line"># GSSAPI options</span><br><span class="line">GSSAPIAuthentication yes</span><br><span class="line">GSSAPICleanupCredentials no</span><br><span class="line">#GSSAPIStrictAcceptorCheck yes</span><br><span class="line">#GSSAPIKeyExchange no</span><br><span class="line">#GSSAPIEnablek5users no</span><br><span class="line">UsePAM yes     #设置是否通过PAM验证</span><br><span class="line"></span><br><span class="line">#AllowAgentForwarding yes</span><br><span class="line">#AllowTcpForwarding yes   #置是否允许允许tcp端口转发，保护其他的tcp连接</span><br><span class="line">#GatewayPorts no       #设置是否允许远程客户端使用本地主机的端口转发功能，出于安全考虑，建议禁止</span><br><span class="line">X11Forwarding yes     #用来设置是否允许X11转发</span><br><span class="line">#X11DisplayOffset 10  #指定X11 转发的第一个可用的显示区(display)数字。默认值是 10</span><br><span class="line">#X11UseLocalhost yes</span><br><span class="line">#PermitTTY yes</span><br><span class="line">#PrintMotd yes      #用来设置sshd是否在用户登录时显示“/etc/motd”中的信息，可以选在在“/etc/motd”中加入警告的信息</span><br><span class="line">#PrintLastLog yes   #是否显示上次登录信息</span><br><span class="line">#TCPKeepAlive yes   #是否持续连接，设置yes可以防止死连接</span><br><span class="line">#UseLogin no       #设置是否在交互式会话的登录过程中使用。默认值是&quot;no&quot;</span><br><span class="line">#UsePrivilegeSeparation sandbox  #设置使用者的权限</span><br><span class="line">#PermitUserEnvironment no</span><br><span class="line">#Compression delayed</span><br><span class="line">#ClientAliveInterval 0</span><br><span class="line">#ClientAliveCountMax 3</span><br><span class="line">#ShowPatchLevel no</span><br><span class="line">#UseDNS yes     #是否使用dns反向解析，验证IP</span><br><span class="line">#PidFile /var/run/sshd.pid</span><br><span class="line">#MaxStartups 10:30:100</span><br><span class="line">#PermitTunnel no</span><br><span class="line">#ChrootDirectory none</span><br><span class="line">#VersionAddendum none</span><br><span class="line"># no default banner path</span><br><span class="line">#Banner none</span><br><span class="line"># Accept locale-related environment variables</span><br><span class="line">AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES</span><br><span class="line">AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT</span><br><span class="line">AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE</span><br><span class="line">AcceptEnv XMODIFIERS</span><br><span class="line"># override default of no subsystems</span><br><span class="line">Subsystem	sftp	/usr/libexec/openssh/sftp-server</span><br></pre></td></tr></table></figure>

<h1 id="客户端登录服务器"><a href="#客户端登录服务器" class="headerlink" title="客户端登录服务器"></a>客户端登录服务器</h1><p>ssh的安装时，如果需要连接远程服务器，那需要安装Client，如果我们需要本机作为服务器，那么需要安装Server。安装完成之后使用如下命令就可以登录远程服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh  user@IP  -p 22  (默认情况下，客户端的ssh_config中端口号，要和我们远程服务器监听的端口号一致，也就是ssh_config里面监听的端口号一致)</span><br></pre></td></tr></table></figure>

<h2 id="口令验证"><a href="#口令验证" class="headerlink" title="口令验证"></a>口令验证</h2><p>初次登录，客户端发送请求之后，服务器端会将公钥发送到客户端，为了防止中间人攻击，可以将接受到的公钥和服务器的公钥对比，一致则是安全的，继续下一步，输入密码，认证成功就可以。这是客户端接受到的公钥会将其通过MD5之后放在~/.ssh/hnown_hosts文件里面，下次登录不用进行公钥验证。</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-31_ssh1.png" alt></p>
<h2 id="密钥验证"><a href="#密钥验证" class="headerlink" title="密钥验证"></a>密钥验证</h2><p>上面步骤可知，通过输入密码进行登录安全性较低，容易受到中间人攻击。密钥登录也称为免密登录。上面口令验证时候，客户端已经获得服务器的公钥，现在我们客户端也生成一组密匙，将客户端的公钥放到服务器的~/.ssh/authorized_keys ，这样就可以实现免密登录。具体过程如下：</p>
<ol>
<li>服务器收到客户端发送的用户名和IP之后，在authorized_keys 需要匹配的公钥，如果匹配就随机生成一个字符串然后通过authorized_keys 里面的公钥加密，发送给客户端。</li>
<li>客户端收到密文之后使用自己的私钥解密，然后将解密的数据使用服务器的公钥加密，发送给服务器。</li>
<li>服务器将接收到的字符串解密然后和之前对比，如果相同，则认证成功。</li>
</ol>
<h3 id="方式一（手动）"><a href="#方式一（手动）" class="headerlink" title="方式一（手动）"></a>方式一（手动）</h3><ol>
<li><p>客户端生成密钥对，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
</li>
<li><p>一路默认执行就可以，然后会在该用户的家目录下生成一个.ssh目录，将里面的id_rsa.pub内容，拷贝到服务器用户家目录~/.ssh/authorized_keys 里面，若不存在，手动创建就可以。(一般root是会禁止直接登录ssh，普通用户又没有authorized_keys(authorized_keys所属用户和组为root)权限，需要sudo，借用root权限)</p>
</li>
<li><p>完成</p>
</li>
</ol>
<h3 id="方拾二（使用命令）"><a href="#方拾二（使用命令）" class="headerlink" title="方拾二（使用命令）"></a>方拾二（使用命令）</h3><ol>
<li><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
</li>
<li><p>家目录会有~/.ssh,会有（id_rsa）私钥和（id_rsa.pub）公钥文件，</p>
</li>
<li><p>使用命令将公钥Copy到服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id 用户名@iP    -p  端口号</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意：由于普通用户没有authorized_keys权限，root禁登录SSH，有可能写入不进去，可以使用密码登录上去，更改其权限，写入完成之后再禁用。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>SSH</tag>
        <tag>Digital Signature</tag>
      </tags>
  </entry>
  <entry>
    <title>独立冗余磁盘阵列（RAID）</title>
    <url>/2019/03/09/2019-3-9_RAID_Description/</url>
    <content><![CDATA[<p>独立冗余磁盘阵列，简称RAID，是通过多个磁盘相互组合提高对硬盘设备IO读取速度和数据安全性的一种技术，目前已有的磁盘阵列方案比较多，标准的RAID有：RAID0、RAID1、RAID2、RAID3、RAID4、RAID5、RAID6。本文主要讲解及在VM虚拟机下使用相关命令配置RAID0、RAID1、RAID5、6、10。</p>
<a id="more"></a>

<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul>
<li>系统：RHEL7.6 </li>
<li>虚拟机：VM</li>
</ul>
<h1 id="RAID介绍"><a href="#RAID介绍" class="headerlink" title="RAID介绍"></a>RAID介绍</h1><h2 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h2><p>RAID0是通过硬件或者是软件的方式将其连接在一起，至少需要两块硬盘，数据分段之后依次写入各个物理硬盘上面。RAID的存储速度最快，但是没有备份，空间利用率达到100%，但是硬盘损坏之后，数据无法修复。零容错。</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-9_RAID0.png" alt></p>
<h2 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h2><p>RAID0是对数据分开存放的，任何一个硬盘发生故障，那么整个数据都将不可用。RAID1则提高数据安全性，将数据同时存入多个硬盘当中，相当于镜像存储，磁盘阵列无论挂载多少个硬盘，都相当于容量最小的硬盘，写入速度相对于RAID0慢，但是数据安全性大大提高，但是这种读取速度是一个硬盘读取速度乘于硬盘个数。</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-9_RAID1.png" alt></p>
<h2 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h2><p>RAID1虽然安全性大大提高，但是硬盘空间利用率大大降低。RAID5兼顾RAID0和RAID1的优点提出来的一种技术方案。RAID5与RAID3和RAID4不同的是RAID4是使用固定盘来存储奇偶校验位，而RAID5是将数据和数据对应的校验位在分散存储在各个硬盘上面。RAID5的数据和RAID0数据分布相似，都是把数据以块为单位分布到各个评判上面。上面这两个RAID5技术方案特点，使得RAID至少需要3块磁盘。RAID5没有备份数据，只保存数据的校验位，在硬盘损坏之后通过奇偶校验位进行数据恢复。RAID5受到系统故障之后，重建时间比较长。</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-9_RAID5%EF%BC%88nor%EF%BC%89.png" alt></p>
<h2 id="RAID6"><a href="#RAID6" class="headerlink" title="RAID6"></a>RAID6</h2><p>RAID5可以知道，如果某一个盘故障之后，可以通过其他盘的校验位和其余的数据记性数据恢复，但是如果同时有两个盘故障的话，则不能完全进行数据恢复（假如上图的Disk1和Disk2同时损坏，A的数据可以通过A1和ParityA恢复，D的数据可以通过D3和ParityD恢复，而B,C的数据由于校验位数据丢失不能恢复）。所以这是出现RAID6，RAID6是在RAID5增加一个安全等级，就是RIAD6在RAID5的基础上，在其他盘又增加XOR校验区，这两个XOR校验使用不同的算法，这个阵列需要至少4块硬盘。这样磁盘阵列允许同时两个硬盘故障，容错功能提高。但是在写入数据的时候需要计算两个XOR区，速度大大降低，空间利用率也降低。</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-9_RAID6.png" alt></p>
<h2 id="RAID10"><a href="#RAID10" class="headerlink" title="RAID10"></a>RAID10</h2><p>由于RAID磁盘阵列的读写速度和数据安全性是相互制约，RAID10通过将RAID0和RAID1进行组合，他利用RAID0的快速读写和RAID1的安全性。性能超过RAID6和RAID5.只要同一组的硬盘不全部损坏，那么数据就不会丢失。RAID10至少需要4块硬盘。如图 ：</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-9_RAID10.png" alt></p>
<h2 id="热备磁盘"><a href="#热备磁盘" class="headerlink" title="热备磁盘"></a>热备磁盘</h2><p>针对磁盘阵列，不同的方案容错成都也不一样，一般都会有热备磁盘，也就是在磁盘阵列中某个磁盘挂了，热备磁盘可以立刻代替损坏磁盘的位置，这时候，我们的磁盘阵列就会重建，一个磁盘阵列可以包含多个热备磁盘。</p>
<h1 id="mdadm命令"><a href="#mdadm命令" class="headerlink" title="mdadm命令"></a>mdadm命令</h1><p>mdadm命令是Linux下创建和管理磁盘阵列的命令，具体参数如下：</p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-a</td>
<td align="center">检测设备名称</td>
</tr>
<tr>
<td align="center">-n</td>
<td align="center">指定设备数量</td>
</tr>
<tr>
<td align="center">-l</td>
<td align="center">设定RAID级别</td>
</tr>
<tr>
<td align="center">-C</td>
<td align="center">创建磁盘阵列名称</td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">显示创建过程</td>
</tr>
<tr>
<td align="center">-f</td>
<td align="center">模拟设备损坏</td>
</tr>
<tr>
<td align="center">-r</td>
<td align="center">移除设备</td>
</tr>
<tr>
<td align="center">-Q</td>
<td align="center">查看摘要信息</td>
</tr>
<tr>
<td align="center">-D</td>
<td align="center">查看详细信息</td>
</tr>
<tr>
<td align="center">-S</td>
<td align="center">停止磁盘阵列</td>
</tr>
</tbody></table>
<h1 id="虚拟磁盘部署磁盘阵列实验"><a href="#虚拟磁盘部署磁盘阵列实验" class="headerlink" title="虚拟磁盘部署磁盘阵列实验"></a>虚拟磁盘部署磁盘阵列实验</h1><h2 id="RAID0-1"><a href="#RAID0-1" class="headerlink" title="RAID0"></a>RAID0</h2><ul>
<li>步骤一（添加磁盘）</li>
</ul>
<p>在虚拟机系统关机状态下，添加两个SCSI磁盘。（虚拟机-&gt;设置-&gt;添加-&gt;硬盘-&gt;SCSI-&gt;创建新虚拟磁盘-&gt;容量20G，完成），按照这个步骤添加两个硬盘。</p>
<ul>
<li>步骤二（查看磁盘）</li>
</ul>
<p>虚拟机下开机（打开系统），进入终端（桌面版），使用lsblk或者“fdisk  -l”命令，可以看到我们添加的两个硬盘，如图：</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-10_lsblk.png" alt></p>
<ul>
<li>步骤三（分区）</li>
</ul>
<p>分区，上面步骤已经添加两个磁盘，下面使用fdisk对磁盘进行分区。1. “fdisk   /dev/sdb” （关于fdisk分区自行根据提示进行就可以，这里我们只分一个主分区，默认编号是1，大小是上限值就即可，设置完成之后，切记分区表同步到磁盘（w   write table to disk and exit））。重复操作对/dev/sdc进行分区 。（不对磁盘分区，应该也可以直接构建磁盘阵列也就是不需要第三步骤也可以）</p>
<ul>
<li>步骤四（创建磁盘阵列）</li>
</ul>
<p>使用mdadm命令创建磁盘阵列，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mdadm  -C  /dev/md0  -a yes   -l0   -n2   /dev/sdb1  /dev/sdc1</span><br></pre></td></tr></table></figure>

<p>参数说明：  -C  创建阵列  ；  -a  yes  自动创建设备文件；  -l +数字 是阵列模式-l0就是说RAD0；-n2 是指连个磁盘创建磁盘阵列；</p>
<ul>
<li>步骤五（格式化）</li>
</ul>
<p>格式化磁盘阵列 “mkfs.xfs   /dev/md0”;  这个mkfs格式工具很强大，mkfs.ext3、mkfs.ext4.都比较方便。</p>
<ul>
<li>步骤六（查看磁盘阵列信息）</li>
</ul>
<p>查看我们创建的磁盘阵列：终端命令“cat  /proc/mdstat”或者使用“mdadm  -D   /dev/md0”详细查看RAID0 配置，如图：</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-10_mdadm0.png" alt></p>
<ul>
<li>步骤七（挂载）</li>
</ul>
<p>使用mount挂在磁盘阵列只能在本次开机有效，要想开机自动挂载可以将磁盘阵列信息写入到/etc/fstab。这里只使用mount挂载。“sudo mkdir /RAID/raid0”  ; “mount  /dev/md0    /RAID/raid0”。到此为止我们就可以正常使用磁盘阵列。</p>
<ul>
<li>步骤八（读取写入速度测试）</li>
</ul>
<ol>
<li><p>写入测试</p>
<p>先给磁盘阵列写入，使用dd和time命令，dd有复制功能，time可以计时,写入1GB。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">time dd  if=/dev/zero  of=/RAID/raid0/iointest bs=8k count=131072</span><br></pre></td></tr></table></figure>

<p>在直接写入本地:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo time dd  if=/dev/zero  of=/home/funful/iointest bs=8k count=131072</span><br></pre></td></tr></table></figure>

<p>如图可以看出来，虽然是虚拟磁盘模拟出来的，但是写入速度与时间还是有差距的(忽略数值，电脑配置比较低)。</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-10_mdadm0iointest.png" alt></p>
</li>
<li><p>读取测试</p>
<p>先读取磁盘阵列数据，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo time dd  if=/RAID/raid0/iointest   of=/dev/null  bs=8k count=131072</span><br></pre></td></tr></table></figure>

<p>再测试读取本地数据，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo time dd  if=/home/funful/iointest   of=/dev/null  bs=8k count=131072</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>由于各个磁盘阵列的方案实施过程相似，所以就不一一进行实验，下面只对RAID10进行创建</p>
<h2 id="RADI10"><a href="#RADI10" class="headerlink" title="RADI10"></a>RADI10</h2><ul>
<li><p>步骤一（添加磁盘）</p>
<p>和RAID0的过程相似，在虚拟机系统关机状态下添加5个虚拟磁盘（每个20GB）,4个数据盘，一个热备份盘。如图：</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-10_raid10.png" alt></p>
</li>
<li><p>步骤二（创建磁盘阵列+备份盘 ）</p>
<p>使用命令创建磁盘阵列：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mdadm -C /dev/md0 -n 4  -l 10 -x 1 /dev/sdb /dev/sdc /dev/sdd  /dev/sde  /dev/sdf</span><br></pre></td></tr></table></figure>

<p>使用命令查看磁盘阵列信息：“mdadm -D    /dev/md0”  如图：</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-10_raid10des.png" alt></p>
<p>从上图可以看出来，总共有5个磁盘，四个活动磁盘，一个备份磁盘。/dev/sdf作为备份盘。</p>
</li>
</ul>
<ul>
<li><p>步骤三（格式化磁盘阵列）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkfs.xfs   /dev/md0</span><br></pre></td></tr></table></figure>
</li>
<li><p>步骤四（主动破坏某个数据盘）</p>
<p>使用mdadm的-f命令主动从磁盘阵列移除一个磁盘，命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mdadm /dev/md0 -f /dev/sdb</span><br></pre></td></tr></table></figure>

<p>可以从图中可以看到，/dev/sdb已经挂了，而之前的备份盘正在顶替sdb的位置，而且正在rebuilding，所以此时活动盘只有3个。过一会再使用这个命令可以看到，rebuilding完毕之后，顶替之前位置。</p>
<p><img src="http://cdn.funful.ink/Blog_2019-3-10_raid10rebui.png" alt></p>
</li>
</ul>
<ul>
<li><p>步骤五（添加热备磁盘）</p>
<p>下面我们将模拟损坏的磁盘，作为热备磁盘加进磁盘阵列，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span>移除损坏磁盘</span><br><span class="line">sudo mdadm  /dev/md0 -r /dev/sdb</span><br><span class="line"><span class="meta">   #</span>添加备份磁盘</span><br><span class="line">   sudo mdadm  /dev/md0 -a /dev/sdb</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.funful.ink/Blog_2019-3-10_raid10add.png" alt></p>
<p>从上图可以看到我们刚才模拟损坏的sdb盘，已经作为热备份盘，添加到磁盘阵列当中。</p>
</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>由于是使用虚拟磁盘来创建磁盘阵列，所以性能对比差距不是那么明显。但是我们可以通过软件的方式使用命令来管理磁盘阵列。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>RAID</tag>
        <tag>独立冗余磁盘阵列</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 文件IO</title>
    <url>/2019/01/15/Linux%E7%9A%84%E6%96%87%E4%BB%B6IO/</url>
    <content><![CDATA[<p>本文介绍了文件IO的操作！</p>
<p>代码例程： <a href="https://github.com/funful/Linux" target="_blank" rel="noopener">例程</a></p>
<p>参考：《UNIX环境高级编程》</p>
<a id="more"></a>

<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p> 根据UNIX的体系结构，从内到外依次是内核、系统调用、shell、库函数、和应用程序。内核的接口成为系统调用。程序运行内存空间可以分为用户空间和内核空间。应用程序工作在用户空间、如果应用程序想要访问内核空间的话，可以使用系统调用安全的访问内核空间。</p>
<p>Linux提供了一系列系统调用函数，常用的有open、write、read、lseek、和close。本文介绍的文件IO也称为不带缓冲的IO。</p>
<h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>在Linux中一切皆文件，所以打开的文件都会返回一个文件描述符引用。文件描述符是一个非负整数。在POSIX应用程序中，0 1 2被替换成了符号常数</p>
<table>
<thead>
<tr>
<th>0</th>
<th>STDERR_FILENO(标准错误输出</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>TDIN_FILENO(标准输入)</td>
</tr>
<tr>
<td>2</td>
<td>STDERR_FILENO(标准错误输出)</td>
</tr>
</tbody></table>
<h2 id="文件IO基本操作"><a href="#文件IO基本操作" class="headerlink" title="文件IO基本操作"></a>文件IO基本操作</h2><h3 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">头文件</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>open函数用来打开或创建文件。</p>
</li>
<li><p>path 是打开文件的名字，oflags 打开文件所要采取的动作，mode 文件访问的格式</p>
</li>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">oflags:(可位与)</span><br><span class="line">      O_RDONLY   只读方式打开文件</span><br><span class="line">      O_WRONLY   只写方式打开文件</span><br><span class="line">      O_RDWR     以读写方式打开文件</span><br><span class="line">	  O_APPEND   把写入数据追加到文件末尾</span><br><span class="line">	  O_TRUNC    把文件长度设置为<span class="number">0</span>，丢弃已有内容</span><br><span class="line">	  O_CREAT     如需要就按参数mode给出的访问模式创建文件</span><br><span class="line">	  O_EXCL      与O_CREAT一起使用，确保调用者创建出文件。open调用是一个原子操作，它只执行一个函		  数调用。使用这个可选模式可以防止两个程序同时创建一同一个文件。如果文件已经存在，open调用失败</span><br></pre></td></tr></table></figure>
</li>
<li><p>mode 是访问权限</p>
</li>
<li><p>返回值的文件描述符取值</p>
<table>

<tr><td>0</td><td>打开或创建成功</td></tr>

<tr><td>-1</td><td>失败</td></tr>

</table>

<h3 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>打开文件成功之后，可以往文件里写数据</p>
</li>
<li><p>fd 文件描述符，buf写入数据在内存空间的起始地址，写入字节数</p>
</li>
<li><p>返回值的文件描述符取值</p>
<table>

<tr><td>非负整数</td><td>写入成功，返回写入字节数</td></tr>

<tr><td>-1</td><td>失败</td></tr>

</table>

</li>
</ol>
<h3 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>打开文件成功之后，可以从文件里读数据</p>
</li>
<li><p>fd 文件描述符，buf读数据在内存空间的起始地址，读出最大字节数</p>
</li>
<li><p>返回值的文件描述符取值</p>
<table>

<tr><td>非负整数</td><td>读成功，返回读出字节数</td></tr>

<tr><td>-1</td><td>失败</td></tr>

</table>

</li>
</ol>
<h3 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>每次打开或新建一个文件，偏移量就从文件开始处，在同一次的打开操作之后，读写就会对其偏移量增加</p>
</li>
<li><p>fd 是文件描述符， offset 是偏移量，whence是模式</p>
</li>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">whence 取值：</span><br><span class="line">   	SEEK_SET  绝对位置</span><br><span class="line">       SEEK_CUR	当前位置</span><br><span class="line">    	SEEK_END  文件尾</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="stat函数"><a href="#stat函数" class="headerlink" title="stat函数"></a>stat函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file_name, struct stat *buf)</span></span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>这个函数是通过文件名，得到存储文件信息的结构体buf</p>
</li>
<li><p>成功返回0 ，失败返回-1</p>
</li>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>         st_dev;       <span class="comment">//文件的设备编号</span></span><br><span class="line">    <span class="keyword">ino_t</span>         st_ino;       <span class="comment">//节点</span></span><br><span class="line">    <span class="keyword">mode_t</span>        st_mode;      <span class="comment">//文件的类型和存取的权限</span></span><br><span class="line">    <span class="keyword">nlink_t</span>       st_nlink;     <span class="comment">//连到该文件的硬连接数目，刚建立的文件值为1</span></span><br><span class="line">    <span class="keyword">uid_t</span>         st_uid;       <span class="comment">//用户ID</span></span><br><span class="line">    <span class="keyword">gid_t</span>         st_gid;       <span class="comment">//组ID</span></span><br><span class="line">    <span class="keyword">dev_t</span>         st_rdev;      <span class="comment">//(设备类型)若此文件为设备文件，则为其设备编号</span></span><br><span class="line">    <span class="keyword">off_t</span>         st_size;      <span class="comment">//文件字节数(文件大小)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blksize;   <span class="comment">//块大小(文件系统的I/O 缓冲区大小)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> st_blocks;    <span class="comment">//块数</span></span><br><span class="line">    <span class="keyword">time_t</span>        st_atime;     <span class="comment">//最后一次访问时间</span></span><br><span class="line">    <span class="keyword">time_t</span>        st_mtime;     <span class="comment">//最后一次修改时间</span></span><br><span class="line">    <span class="keyword">time_t</span>        st_ctime;     <span class="comment">//最后一次改变时间(指属性)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure>

<ol>
<li>操作完一个函数之后应该，显式的关闭一打开文件</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ol>
<li><p>新建文本1，写入一段话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                     Traveling Light</span><br><span class="line">I was doubling over the load on my shoulders</span><br><span class="line">was a weight I carried with me everyday</span><br><span class="line">Crossing miles of  frustrations and rivers of raging</span><br><span class="line">Picking up stones I found  along the  way</span><br><span class="line">I staggered and I stumbled down</span><br><span class="line">pathway of trouble I was</span><br><span class="line">hauling  those  souvernirs  of  misery</span><br><span class="line">And with each step taken my back was breaking</span><br><span class="line">Till I found the One who took it all from me</span><br><span class="line">Down by the riverside(Down by the riverside)</span><br><span class="line">I laid my burdens down,Now I&apos;m traveling light</span><br><span class="line">My spirit lifted high(I found my freedom now)</span><br><span class="line">I found my freedom now,And I&apos;m traveling light</span><br><span class="line">Through the darkest alleys and loneliest valleys</span><br><span class="line">I was dragging those heavy chains of doubt and fear</span><br><span class="line">Then with the one word spoken the locks were broken</span><br><span class="line">Now He&apos;s leading me to places</span><br><span class="line">Where there are no tears</span><br><span class="line">Down by the riverside</span><br><span class="line">(Down by the riverside)</span><br><span class="line">I laid my burdens down,</span><br><span class="line">Now I&apos;m traveling light</span><br><span class="line">My spirit lifted high</span><br><span class="line">(I found my freedom now)</span><br><span class="line">I found my freedom now</span><br><span class="line">And I&apos;m traveling light</span><br><span class="line">Down by the riverside</span><br><span class="line">I laid my burdens down</span><br><span class="line">Now I&apos;m traveling light</span><br><span class="line">My spirit lifted high</span><br><span class="line">I found my freedom now</span><br><span class="line">And I&apos;m traveling light</span><br><span class="line">Down by the riverside</span><br><span class="line">(Down by the riverside)</span><br><span class="line">I laid my burdens down,</span><br><span class="line">Now I&apos;m traveling light</span><br><span class="line">My spirit lifted high</span><br><span class="line">(I found my freedom now)</span><br><span class="line">I found my freedom now</span><br><span class="line">And I&apos;m traveling light</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建文本2</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">歌曲名：Traveling Light</span><br><span class="line">歌手名：Joel Hanson</span><br><span class="line">专辑名：What If It Is</span><br></pre></td></tr></table></figure>
</li>
<li><p>将文本1和文本2合并，并且生成文本3</p>
</li>
</ol>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>​         combine.c 使用了open 、write、 read、lseek、close、和stat 函数，对文件操作</p>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>回调函数及其应用场景分析</title>
    <url>/2018/12/02/2018-12-02-callback-function/</url>
    <content><![CDATA[<blockquote>
<p>日常开发中遇到过使用回调函数的场景，但是对其具体定义和实现方式一直没有清晰的认识，导致平时能不用就不用，这次做一个总结克服它。</p>
</blockquote>
<a id="more"></a>

<h2 id="一-回调函数的定义"><a href="#一-回调函数的定义" class="headerlink" title="一  回调函数的定义"></a>一  回调函数的定义</h2><h3 id="1-1-百度百科定义"><a href="#1-1-百度百科定义" class="headerlink" title="1.1 百度百科定义"></a>1.1 百度百科定义</h3><p>如果你把函数的指针（地址）<strong>作为参数</strong>传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数<strong>不是由该函数的实现方直接调用</strong>，而是在特定的事件或条件发生时由<strong>另外的一方调用的</strong>，用于对该事件或条件进行响应。</p>
<h3 id="1-2其他定义"><a href="#1-2其他定义" class="headerlink" title="1.2其他定义"></a>1.2其他定义</h3><ol>
<li><p>回调函数是指<strong>使用者自己定义一个函数</strong>，实现这个函数的程序内容，然后把这个函数（入口地址）作为参数传入别人（或系统）的函数中，由别人（或系统）的函数在运行时来调用的函数。<strong>函数是你实现的</strong>，但由别人（或系统）的函数在运行时通过参数传递的方式调用，这就是所谓的回调函数。简单来说，就是<strong>由别人的函数运行期间通过函数指针来回调你实现的函数</strong>。 </p>
</li>
<li><p>所谓回调，就是模块A要通过模块B的某个函数b()完成一定的功能，但是函数b()自己无法实现全部功能，需要反过头来调用模块A中的某个函数a()来完成，这个a()就是回调函数。 </p>
</li>
</ol>
<p>   总结来说，<strong>回调函数这一设计允许了底层代码调用在高层定义的子程序。</strong></p>
<h2 id="二-回调函数简单实例"><a href="#二-回调函数简单实例" class="headerlink" title="二  回调函数简单实例"></a>二  回调函数简单实例</h2><h3 id="2-1无参数的回调实例"><a href="#2-1无参数的回调实例" class="headerlink" title="2.1无参数的回调实例"></a>2.1无参数的回调实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//定义带参回调函数</span><br><span class="line">void PrintfText(char* s) </span><br><span class="line">&#123;</span><br><span class="line">    printf(s);</span><br><span class="line">&#125;</span><br><span class="line">//定义实现带参回调函数的&quot;调用函数&quot;</span><br><span class="line">void CallPrintfText(void (*callfuct)(char*),char* s)</span><br><span class="line">&#123;</span><br><span class="line">    callfuct(s);</span><br><span class="line">&#125;</span><br><span class="line">//在main函数中实现带参的函数回调</span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CallPrintfText(PrintfText,&quot;Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2将上述代码修改为带参函数"><a href="#2-2将上述代码修改为带参函数" class="headerlink" title="2.2将上述代码修改为带参函数"></a>2.2将上述代码修改为带参函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//定义带参回调函数</span><br><span class="line">void PrintfText(char* s) </span><br><span class="line">&#123;</span><br><span class="line">    printf(s);</span><br><span class="line">&#125;</span><br><span class="line">//定义实现带参回调函数的&quot;调用函数&quot;</span><br><span class="line">void CallPrintfText(void (*callfuct)(char*),char* s)</span><br><span class="line">&#123;</span><br><span class="line">    callfuct(s);</span><br><span class="line">&#125;</span><br><span class="line">//在main函数中实现带参的函数回调</span><br><span class="line">int main(int argc,char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    CallPrintfText(PrintfText,&quot;Hello World!\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上两个实例对回调函数的定义有了清晰的说明，但是没有指明回调函数的真正用途：<strong>回调函数这一设计允许了底层代码调用在高层定义的子程序。</strong>这也是前文提到的，回调函数主要是为了让其他人已经实现的函数调用，而不是让自己实现的函数调用。第三章将给出回调函数的实用用途。</p>
<h2 id="三-Qt5中引入的消息重定向机制使用的回调函数"><a href="#三-Qt5中引入的消息重定向机制使用的回调函数" class="headerlink" title="三  Qt5中引入的消息重定向机制使用的回调函数"></a>三  Qt5中引入的消息重定向机制使用的回调函数</h2><h3 id="3-1使用场景"><a href="#3-1使用场景" class="headerlink" title="3.1使用场景"></a>3.1使用场景</h3><p>一般在开发Qt程序时，主要由两种调试方式：一种是在debug模式下调试，另一种是在程序中使用qDebug()等函数打印信息帮助调试。一旦程序release投入实际使用，这些打印信息将无法被开发人员看到，qt5使用消息重定向机制使得打印信息可以重定向输出至log文件。这样即使软件在使用过程中发生问题也可以凭借日志文件追溯。</p>
<p>如下是Qt帮助文档对于注册回调函数的描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Installs a Qt message handler which has been defined previously. Returns a pointer to the previous message handler.</span><br><span class="line">The message handler is a function that prints out debug messages, warnings, critical and fatal error messages. The Qt library (debug mode) contains hundreds of warning messages that are printed when internal errors (usually invalid function arguments) occur. Qt built in release mode also contains such warnings unless QT_NO_WARNING_OUTPUT and/or QT_NO_DEBUG_OUTPUT have been set during compilation. If you implement your own message handler, you get total control of these messages.</span><br><span class="line">The default message handler prints the message to the standard output under X11 or to the debugger under Windows. If it is a fatal message, the application aborts immediately.</span><br><span class="line">Only one message handler can be defined, since this is usually done on an application-wide basis to control debug output.</span><br><span class="line">To restore the message handler, call qInstallMessageHandler(0).</span><br></pre></td></tr></table></figure>

<h3 id="3-2Qt回调代码实例"><a href="#3-2Qt回调代码实例" class="headerlink" title="3.2Qt回调代码实例"></a>3.2Qt回调代码实例</h3><p>如下代码是qt提供的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;qapplication.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">void myMessageOutput(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg)</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray localMsg = msg.toLocal8Bit();</span><br><span class="line">    switch (type)</span><br><span class="line">    &#123;</span><br><span class="line">        case QtDebugMsg:</span><br><span class="line">        fprintf(stderr, &quot;Debug: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function);</span><br><span class="line">        break;</span><br><span class="line">        case QtInfoMsg:</span><br><span class="line">        fprintf(stderr, &quot;Info: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function);</span><br><span class="line">        break;</span><br><span class="line">        case QtWarningMsg:</span><br><span class="line">        fprintf(stderr, &quot;Warning: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function);</span><br><span class="line">        break;</span><br><span class="line">        case QtCriticalMsg:</span><br><span class="line">        fprintf(stderr, &quot;Critical: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function);</span><br><span class="line">        break;</span><br><span class="line">        case QtFatalMsg:</span><br><span class="line">        fprintf(stderr, &quot;Fatal: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function);</span><br><span class="line">        abort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    qInstallMessageHandler(myMessageOutput);</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line">    ...</span><br><span class="line">    return app.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，函数void myMessageOutput(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg)可以看做是我们自己实现的回调函数，qInstallMessageHandler(myMessageOutput)是Qt提供的注册回调函数。之后，一旦Qt提供的几种消息类型发生就会调用我们定义的回调函数。</p>
<p>以上代码稍做修改即可实现重定向消息输出至log文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void myMessageOutput(QtMsgType type, const QMessageLogContext &amp;context, const QString &amp;msg)</span><br><span class="line">&#123;</span><br><span class="line">    QByteArray localMsg = msg.toLocal8Bit();</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">    case QtDebugMsg:</span><br><span class="line">        fprintf(stderr, &quot;Debug: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function);</span><br><span class="line">        break;</span><br><span class="line">    case QtInfoMsg:</span><br><span class="line">        fprintf(stderr, &quot;Info: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function);</span><br><span class="line">        break;</span><br><span class="line">    case QtWarningMsg:</span><br><span class="line">        fprintf(stderr, &quot;Warning: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function);</span><br><span class="line">        break;</span><br><span class="line">    case QtCriticalMsg:</span><br><span class="line">        fprintf(stderr, &quot;Critical: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function);</span><br><span class="line">        break;</span><br><span class="line">    case QtFatalMsg:</span><br><span class="line">        fprintf(stderr, &quot;Fatal: %s (%s:%u, %s)\n&quot;, localMsg.constData(), context.file, context.line, context.function);</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    qInstallMessageHandler( myMessageOutput );</span><br><span class="line">    QCoreApplication a(argc, argv);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过修改后的回调函数可以实现将打印信息及其所在的，文件，函数，代码行等输出至log文件。</p>
<p><strong>这个例子可以帮助我们清晰的认识回调函数的具体应用场景。</strong></p>
<h2 id="四-标准回调函数定义方式"><a href="#四-标准回调函数定义方式" class="headerlink" title="四 标准回调函数定义方式"></a>四 标准回调函数定义方式</h2><blockquote>
<p>回调函数的定义及其实现方式并不复杂，如果不清楚其应用场景只是一味的看概念确实容易对其理解有偏差。本小结将给出关于回调函数及注册回调函数一些标准的定义。  </p>
</blockquote>
<h3 id="4-1回调函数定义"><a href="#4-1回调函数定义" class="headerlink" title="4.1回调函数定义"></a>4.1回调函数定义</h3><p>定义时最好符合如下函数原型：typedef void (*SCT_XXX)(LPVOID lp, const CBParamStruct&amp; cbNode);   </p>
<p>其中SCT_XXX是回调函数名称，lp是回调上下文，CBParamStruct是回调参数，一般由于要回调的参数不止一个，所以定义一个结构体比较方便。</p>
<h3 id="4-2注册回调函数"><a href="#4-2注册回调函数" class="headerlink" title="4.2注册回调函数"></a>4.2注册回调函数</h3><p>注册回调函数原型：void RCF_XXX(SCT_XXX pfn, LPVOID lp);</p>
<p>其中，RCF_XXX是注册函数名，pfn是回调函数名称（是指针），lp是回调上下文。 </p>
<blockquote>
<p>后记CSDN论坛一个<a href="https://bbs.csdn.net/topics/390081829" target="_blank" rel="noopener">关于为什么要使用回调函数</a>的帖子可能对深入理解回调函数有帮助，毕竟争论出真知。</p>
</blockquote>
<p><strong>参考：</strong></p>
<ul>
<li><a href="https://www.cnblogs.com/ioleon13/archive/2010/03/02/1676621.html" target="_blank" rel="noopener">ioleon13的博客</a></li>
<li><a href="https://baike.baidu.com/item/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/7545973?fr=aladdin" target="_blank" rel="noopener">百度百科回调函数词条</a></li>
</ul>
<p>修订记录：2018.12.02  22:46  完成初稿</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++相关</tag>
        <tag>回调函数</tag>
        <tag>Qt输出日志</tag>
      </tags>
  </entry>
  <entry>
    <title>return不同类型变量的区别</title>
    <url>/2018/11/30/2018-11-30-keyword-return/</url>
    <content><![CDATA[<p>关于c/c++中return的总结（返回值类型），由return *this引起的思考。</p>
<a id="more"></a>

<blockquote>
<p>近段时间突然想到return *this这个东西，一时间糊涂了，总是在纠结return *this返回的是对象的引用还是对象本身。后来悟过来这应该和返回值类型有关。从这个也查到了c/c++return不同类型是如何实现的，做一个小结以便回顾。  </p>
</blockquote>
<h2 id="一-结论"><a href="#一-结论" class="headerlink" title="一 结论"></a>一 结论</h2><p>  直接抛结论，方便回顾。  </p>
<ul>
<li>主要讨论返回内部变量类型(包含指针)，返回内部变量类型的引用，返回结构体(类)，返回结构体(类)的引用这四种情况。  </li>
<li>主要讨论返回局部变量的情况，也就是在栈内存的变量。</li>
</ul>
<ol>
<li>返回内部变量类型时，直接返回变量本身。但是中间有一个拷贝的过程，会将局部变量拷贝至一个寄存器，再将寄存器的值返回给赋值的变量。也就是常说的会有一个复制的过程。值得注意的是，返回一个指针变量也是一样的，但是请注意指向栈内存的指针在函数调用结束后是无效的，因为栈空间已经释放，可能被其他操作覆盖。  </li>
<li>返回值类型是局部变量的引用时，返回的是局部变量的地址，根据这个地址读出变量的值。此处有一个问题，局部变量所在的栈内存在调用结束时被销毁，按理说不应该能够根据地址读出正确的变量值。但是实际测试发现，返回局部变量的引用依然可以得到正确的变量值。  </li>
<li>返回一个类对象时和情况1是一样的，返回的是对象的一个拷贝（通常是一个被叫做匿名对象的东西）。这也是为什么不推荐直接返回类对象的原因，因为拷贝一个类需要花费更多的时间，而且还需要再次调用类的拷贝构造函数，因为这真的是一个拷贝过程。  </li>
<li>返回一个类对象的引用和情况2是一样的，直接返回地址，也无需调用拷贝构造函数。此处返回的类对象应该是由参数传入的类对象引用而不应该是返回局部类对象的引用！！</li>
</ol>
<h2 id="二-基础编码分析"><a href="#二-基础编码分析" class="headerlink" title="二 基础编码分析"></a>二 基础编码分析</h2><h3 id="1-返回内部变量类型"><a href="#1-返回内部变量类型" class="headerlink" title="1.返回内部变量类型"></a>1.返回内部变量类型</h3><p>源码如下  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int func()</span><br><span class="line">&#123;</span><br><span class="line">    int rst = 0;</span><br><span class="line">    return rst;</span><br><span class="line">&#125;</span><br><span class="line">void* func2()</span><br><span class="line">&#123;</span><br><span class="line">    void * p = NULL;</span><br><span class="line">    return p;</span><br><span class="line">&#125;</span><br><span class="line">char&amp; fun3()</span><br><span class="line">&#123;</span><br><span class="line">    char ch = 0;</span><br><span class="line">    return ch;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int ret = func();</span><br><span class="line">    func2();</span><br><span class="line">    void* p = func2();</span><br><span class="line">    fun3();</span><br><span class="line">    char ch = fun3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试上述代码，查看相应的汇编码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">00FA1880  push        ebp  </span><br><span class="line">00FA1881  mov         ebp,esp  </span><br><span class="line">00FA1883  sub         esp,0E4h  </span><br><span class="line">00FA1889  push        ebx  </span><br><span class="line">00FA188A  push        esi  </span><br><span class="line">00FA188B  push        edi  </span><br><span class="line">00FA188C  lea         edi,[ebp-0E4h]  </span><br><span class="line">00FA1892  mov         ecx,39h  </span><br><span class="line">00FA1897  mov         eax,0CCCCCCCCh  </span><br><span class="line">00FA189C  rep stos    dword ptr es:[edi]  </span><br><span class="line">00FA189E  mov         ecx,offset _A5C8350F_testreturn@cpp (0FAC003h)  </span><br><span class="line">00FA18A3  call        @__CheckForDebuggerJustMyCode@4 (0FA1212h)  </span><br><span class="line"></span><br><span class="line">	int ret = func();</span><br><span class="line">00FA18A8  call        func (0FA138Eh)  </span><br><span class="line">00FA18AD  mov         dword ptr [ret],eax  </span><br><span class="line">	func2();</span><br><span class="line">00FA18B0  call        func2 (0FA1389h)  </span><br><span class="line">	void* p = func2();</span><br><span class="line">00FA18B5  call        func2 (0FA1389h)  </span><br><span class="line">00FA18BA  mov         dword ptr [p],eax  </span><br><span class="line">	fun3();</span><br><span class="line">00FA18BD  call        fun3 (0FA1384h)  </span><br><span class="line">	char ch = fun3();</span><br><span class="line">00FA18C2  call        fun3 (0FA1384h)  </span><br><span class="line">00FA18C7  mov         al,byte ptr [eax]  </span><br><span class="line">00FA18C9  mov         byte ptr [ch],al  </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先看对与局部变量的返回是如何实现的，从上面的代码可以看到调用函数func后又从eax寄存器读出一个值付给了变量ret。也就是说eax保存了对于局部变量的返回。具体的实现可以进入函数func查看相应的汇编码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int func()</span><br><span class="line">&#123;</span><br><span class="line">00FA1810  push        ebp  </span><br><span class="line">00FA1811  mov         ebp,esp  </span><br><span class="line">00FA1813  sub         esp,0CCh  </span><br><span class="line">00FA1819  push        ebx  </span><br><span class="line">00FA181A  push        esi  </span><br><span class="line">00FA181B  push        edi  </span><br><span class="line">00FA181C  lea         edi,[ebp-0CCh]  </span><br><span class="line">00FA1822  mov         ecx,33h  </span><br><span class="line">00FA1827  mov         eax,0CCCCCCCCh  </span><br><span class="line">00FA182C  rep stos    dword ptr es:[edi]  </span><br><span class="line">00FA182E  mov         ecx,offset _A5C8350F_testreturn@cpp (0FAC003h)  </span><br><span class="line">00FA1833  call        @__CheckForDebuggerJustMyCode@4 (0FA1212h)  </span><br><span class="line">	int rst = 0;</span><br><span class="line">00FA1838  mov         dword ptr [rst],0  </span><br><span class="line">	return rst;</span><br><span class="line">00FA183F  mov         eax,dword ptr [rst]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键代码在return rst下面：00FA183F  mov  eax,dword ptr [rst]<br>也就是return时把局部变量存储在了eax寄存器，返回调用函数后从该寄存器读出即为返回值。这也印证了上述的说法。  </p>
<h3 id="2-返回指针变量"><a href="#2-返回指针变量" class="headerlink" title="2.返回指针变量"></a>2.返回指针变量</h3><p>那对于指针变量的返回和普通变量类型有区别吗？继续查看上述的汇编代码：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void* p = func2();</span><br><span class="line">00FA18B5  call        func2 (0FA1389h)  </span><br><span class="line">00FA18BA  mov         dword ptr [p],eax</span><br></pre></td></tr></table></figure>

<p>这两句与int行变量的返回完全一致，进入func2函数继续查看,关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	void * p = NULL;</span><br><span class="line">00FA17D8  mov         dword ptr [p],0  </span><br><span class="line">	return p;</span><br><span class="line">00FA17DF  mov         eax,dword ptr [p]</span><br></pre></td></tr></table></figure>

<p><strong>从这一点可以看出来返回指针变量与其他变量的方式是完全一样的，这也可以理解，毕竟指针也是内部变量类型之一。</strong>    </p>
<h3 id="3-返回局部变量的引用"><a href="#3-返回局部变量的引用" class="headerlink" title="3.返回局部变量的引用"></a>3.返回局部变量的引用</h3><p>直接看调用fun3的汇编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	char ch = fun3();</span><br><span class="line">00FA18C2  call        fun3 (0FA1384h)  </span><br><span class="line">00FA18C7  mov         al,byte ptr [eax]  </span><br><span class="line">00FA18C9  mov         byte ptr [ch],al</span><br></pre></td></tr></table></figure>

<p>直接的区别就是操作步骤增加了一步，之前从eax寄存器读出的就是返回值，而对于引用的返回确时[eax]也就是把eax寄存器保存的是值作为一个地址数据。至于这个地址是什么，需要进入fun3继续查看，关键代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	char ch = 0;</span><br><span class="line">00FA1742  mov         byte ptr [ch],0  </span><br><span class="line">	return ch;</span><br><span class="line">00FA1746  lea         eax,[ch]</span><br></pre></td></tr></table></figure>

<p>最直接的变化就是00FA1746  lea   eax,[ch] <strong>没有将ch变量的值放入eax寄存器而是放入了ch的地址</strong>。这才有了上述函数调用结束后先去eax指向的地址读值再将该值赋予变量ch的两步过程。  </p>
<ul>
<li>总结起来就是直接返回变量时，返回的是变量值的一个拷贝。而返回变量的引用则是返回变量的地址，再根据这个地址读出变量的值。  <h2 id="三-更进一步–-gt-返回值为class-struct"><a href="#三-更进一步–-gt-返回值为class-struct" class="headerlink" title="三 更进一步–&gt;返回值为class/struct"></a>三 更进一步–&gt;返回值为class/struct</h2></li>
</ul>
<h3 id="1-简单描述返回值为类对象的过程。"><a href="#1-简单描述返回值为类对象的过程。" class="headerlink" title="1.简单描述返回值为类对象的过程。"></a>1.简单描述返回值为类对象的过程。</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span></span></span><br><span class="line"><span class="class">&#123;</span>... ...&#125;</span><br><span class="line"><span class="function">classname <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	classname p;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    classname p;</span><br><span class="line">    p = fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有如上示意代码，其大致过程：先在调用函数处创建匿名对象但<strong>不初始化</strong>2.将该匿名对象的<strong>this指针</strong>作为参数传入被调用函数fun3.在return时通过传入的指针调用匿名对象的<strong>拷贝构造函数</strong>4.结束时返回匿名对象的<strong>地址</strong>5.如果调用函数需要将返回的对象赋值给另一个类对象(示意中为p)，就会根据这个指针再进行一次复制（单纯的复制，不会调用其他函数）。所以上述代码调用了两次构造函数(两次classname p过程)和一次拷贝构造函数(在return p的时候将被调用函数的p作为匿名对象拷贝构造函数的参数)。</p>
<h3 id="2-具体源码"><a href="#2-具体源码" class="headerlink" title="2.具体源码"></a>2.具体源码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1) </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">int</span> somethingelse;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">12</span>];</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"age :%X id:%X\n"</span>, age, id);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"age:%X \n"</span>, &amp;age);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"id:%X \n"</span>, &amp;id);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"somethingelse:%X \n"</span>, &amp;somethingelse);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"name:%X \n"</span>, name);</span><br><span class="line">	&#125;</span><br><span class="line">	Person()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Call Person()\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	Person(<span class="keyword">const</span> Person&amp;)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Call Person(const Person&amp;)\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Person <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person* per = <span class="keyword">new</span> Person();</span><br><span class="line">	<span class="keyword">return</span> *per;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Person&amp; <span class="title">func3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person* p = <span class="keyword">new</span> Person();</span><br><span class="line">	<span class="keyword">return</span> *p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Person p;</span><br><span class="line">	func1().display();</span><br><span class="line">	p = func1();</span><br><span class="line">	p.display();</span><br><span class="line">	func2().display();</span><br><span class="line">	func3().display();</span><br><span class="line">	p = func3();</span><br><span class="line">	p.display();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述三个函数func1,func2func3分别分别代表返回局部内对象(栈内存)，返回动态对象(堆内存)，返回动态对象的引用。为了简洁，函数中没有进性delete操作。</p>
<h3 id="3-返回局部对象的过程"><a href="#3-返回局部对象的过程" class="headerlink" title="3.返回局部对象的过程"></a>3.返回局部对象的过程</h3><p>相应反汇编代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	Person p;</span><br><span class="line">01151E12  lea         ecx,[p]  </span><br><span class="line">01151E15  call        Person::Person (0115114Ah)  </span><br><span class="line">	func1().display();</span><br><span class="line">01151E1A  lea         eax,[ebp-100h]  </span><br><span class="line">01151E20  push        eax  </span><br><span class="line">01151E21  call        func1 (0115144Ch)  </span><br><span class="line">01151E26  add         esp,4  </span><br><span class="line">01151E29  mov         ecx,eax  </span><br><span class="line">01151E2B  call        Person::display (01151046h)  </span><br><span class="line">	p = func1();</span><br><span class="line">01151E30  lea         eax,[ebp-120h]  </span><br><span class="line">01151E36  push        eax  </span><br><span class="line">01151E37  call        func1 (0115144Ch)  </span><br><span class="line">01151E3C  add         esp,4  </span><br><span class="line">01151E3F  mov         ecx,dword ptr [eax]  </span><br><span class="line">01151E41  mov         dword ptr [p],ecx  </span><br><span class="line">01151E44  mov         edx,dword ptr [eax+4]  </span><br><span class="line">01151E47  mov         dword ptr [ebp-1Ch],edx  </span><br><span class="line">01151E4A  mov         ecx,dword ptr [eax+8]  </span><br><span class="line">01151E4D  mov         dword ptr [ebp-18h],ecx  </span><br><span class="line">01151E50  mov         edx,dword ptr [eax+0Ch]  </span><br><span class="line">01151E53  mov         dword ptr [ebp-14h],edx  </span><br><span class="line">01151E56  mov         ecx,dword ptr [eax+10h]  </span><br><span class="line">01151E59  mov         dword ptr [ebp-10h],ecx  </span><br><span class="line">01151E5C  mov         edx,dword ptr [eax+14h]  </span><br><span class="line">01151E5F  mov         dword ptr [ebp-0Ch],edx  </span><br><span class="line">	p.display();</span><br><span class="line">01151E62  lea         ecx,[p]  </span><br><span class="line">01151E65  call        Person::display (01151046h)</span><br></pre></td></tr></table></figure>

<p>首先是Person p;直接调用相应的构造函数，过程比较清晰。重点看返回对象的函数func1().display();可以看到在调用函数func1之前有一个入栈的操作，调用函数之前入栈的都是需要传入函数的参数，但是函数func1并没有需要显示传入的参数，那么这个入栈的数据大概率是隐式传输的参数this指针，也就是前面提到的匿名对象的指针，但是该匿名对象的创建过程代码中并没有体现。</p>
<p>进入函数func1()相应的关键汇编码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	Person p;</span><br><span class="line">01151A92  lea         ecx,[p]  </span><br><span class="line">01151A95  call        Person::Person (0115114Ah)  </span><br><span class="line">	return p;</span><br><span class="line">01151A9A  lea         eax,[p]  </span><br><span class="line">01151A9D  push        eax  </span><br><span class="line">01151A9E  mov         ecx,dword ptr [ebp+8]  </span><br><span class="line">01151AA1  call        Person::Person (01151375h)  </span><br><span class="line">01151AA6  mov         eax,dword ptr [ebp+8]</span><br></pre></td></tr></table></figure>

<p>其中语句01151A9E  mov    ecx,dword ptr [ebp+8] 将传入的参数放置ecx寄存器之后调用拷贝构造函数(一般来说，函数调用时ebp+4存放返回地址，ebp+8存放第一个传入的参数)。进入 Person::Person (01151375h)关键 源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">011518AC  push        ecx  </span><br><span class="line">011518AD  lea         edi,[ebp-0CCh]  </span><br><span class="line">011518B3  mov         ecx,33h  </span><br><span class="line">011518B8  mov         eax,0CCCCCCCCh  </span><br><span class="line">011518BD  rep stos    dword ptr es:[edi]  </span><br><span class="line">011518BF  pop         ecx  </span><br><span class="line">011518C0  mov         dword ptr [this],ecx</span><br></pre></td></tr></table></figure>

<p>上述代码很清除的表明ecx寄存器也就是上一步中传入的参数确实是当前构造函数的this指针，也就是匿名对象的地址。在拷贝构造函数完成之后，还有01151AA6  mov         eax,dword ptr [ebp+8] 操作也就是将this指针放入eax寄存器。之后在函数调用处通过该指针调用返回的对象的成员函数display();</p>
<p>至此返回类对象的过程完毕。</p>
<p>从p = func1()的汇编码中可以看到其差别主要是返回之后的一些复制操作，其余完全相同。</p>
<h3 id="4-返回动态动态对象的过程"><a href="#4-返回动态动态对象的过程" class="headerlink" title="4.返回动态动态对象的过程"></a>4.返回动态动态对象的过程</h3><p>相应的反汇编码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	func2().display();</span><br><span class="line">01151E6A  lea         eax,[ebp-140h]  </span><br><span class="line">01151E70  push        eax  </span><br><span class="line">01151E71  call        func2 (01151456h)  </span><br><span class="line">01151E76  add         esp,4  </span><br><span class="line">01151E79  mov         ecx,eax  </span><br><span class="line">01151E7B  call        Person::display (01151046h)</span><br></pre></td></tr></table></figure>

<p>类比可知，该过程与返回局部类对象完全一致。</p>
<h3 id="5-返回动态对象的引用"><a href="#5-返回动态对象的引用" class="headerlink" title="5.返回动态对象的引用"></a>5.返回动态对象的引用</h3><p>返回动态对象的引用不同与上述过程，没有调用前函数入栈的操作。其反汇编码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	func3().display();</span><br><span class="line">01151E80  call        func3 (01151451h)  </span><br><span class="line">01151E85  mov         ecx,eax  </span><br><span class="line">01151E87  call        Person::display (01151046h)  </span><br><span class="line">	p = func3();</span><br><span class="line">01151E8C  call        func3 (01151451h)  </span><br><span class="line">01151E91  mov         ecx,dword ptr [eax]  </span><br><span class="line">01151E93  mov         dword ptr [p],ecx  </span><br><span class="line">01151E96  mov         edx,dword ptr [eax+4]  </span><br><span class="line">01151E99  mov         dword ptr [ebp-1Ch],edx  </span><br><span class="line">01151E9C  mov         ecx,dword ptr [eax+8]  </span><br><span class="line">01151E9F  mov         dword ptr [ebp-18h],ecx  </span><br><span class="line">01151EA2  mov         edx,dword ptr [eax+0Ch]  </span><br><span class="line">01151EA5  mov         dword ptr [ebp-14h],edx  </span><br><span class="line">01151EA8  mov         ecx,dword ptr [eax+10h]  </span><br><span class="line">01151EAB  mov         dword ptr [ebp-10h],ecx  </span><br><span class="line">01151EAE  mov         edx,dword ptr [eax+14h]  </span><br><span class="line">01151EB1  mov         dword ptr [ebp-0Ch],edx  </span><br><span class="line">	p.display();</span><br><span class="line">01151EB4  lea         ecx,[p]  </span><br><span class="line">01151EB7  call        Person::display (01151046h)</span><br></pre></td></tr></table></figure>

<p>进入fun3查看如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	Person* p = new Person();</span><br><span class="line">01151C27  push        18h  </span><br><span class="line">01151C29  call        operator new (01151352h)  </span><br><span class="line">01151C2E  add         esp,4  </span><br><span class="line">01151C31  mov         dword ptr [ebp-0ECh],eax  </span><br><span class="line">01151C37  mov         dword ptr [ebp-4],0  </span><br><span class="line">01151C3E  cmp         dword ptr [ebp-0ECh],0  </span><br><span class="line">01151C45  je          func3+7Ah (01151C5Ah)  </span><br><span class="line">01151C47  mov         ecx,dword ptr [ebp-0ECh]  </span><br><span class="line">01151C4D  call        Person::Person (0115114Ah)  </span><br><span class="line">01151C52  mov         dword ptr [ebp-0F4h],eax  </span><br><span class="line">01151C58  jmp         func3+84h (01151C64h)  </span><br><span class="line">01151C5A  mov         dword ptr [ebp-0F4h],0  </span><br><span class="line">01151C64  mov         eax,dword ptr [ebp-0F4h]  </span><br><span class="line">01151C6A  mov         dword ptr [ebp-0E0h],eax  </span><br><span class="line">01151C70  mov         dword ptr [ebp-4],0FFFFFFFFh  </span><br><span class="line">01151C77  mov         ecx,dword ptr [ebp-0E0h]  </span><br><span class="line">01151C7D  mov         dword ptr [p],ecx  </span><br><span class="line">	return *p;</span><br><span class="line">01151C80  mov         eax,dword ptr [p]</span><br></pre></td></tr></table></figure>

<p>可以看到return *p时只有一步将对象地址放入寄存器的操作，没有拷贝的过程(没有匿名对象产生，也就没有相应的匿名对象this指针，无从调用)</p>
<p>也就是说返回类对象引用其实是返回其地址，这和返回内部变量类型是一致的，同样的禁止返回局部类对象的引用，编译器不会报错误，但这是一个危险操作。</p>
<p>全文完毕。</p>
<p>后记：感谢 Icoding_F2014博主的详尽分析，本文基本上算是对其分析过程的验证。</p>
<ul>
<li>参考： <a href="https://blog.csdn.net/jmh1996/article/details/78384083" target="_blank" rel="noopener">Icoding_F2014对于上述过程的论证</a></li>
</ul>
<p>修订记录：    2018-12-2 01:37       补充返回类对象的有关内容。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++相关</tag>
        <tag>return不同类型</tag>
      </tags>
  </entry>
  <entry>
    <title>this指针小结</title>
    <url>/2018/11/30/2018-11-29-this-pointer/</url>
    <content><![CDATA[<p>关于c++中this指针的小结</p>
<a id="more"></a>

<p>前言：在 C++ 中，每一个对象都能通过 this 指针来访问自己的地址。this 指针是所有成员函数的<strong>隐含参数</strong>。因此，在成员函数内部，它可以用来指向调用对象。 </p>
<h2 id="一-定义"><a href="#一-定义" class="headerlink" title="一 定义"></a>一 定义</h2><p>this是一个指向自身对象的特殊指针，它并不是对象本身的一部分，不会影响sizeof（对象）的结果。</p>
<h2 id="二-应用场景"><a href="#二-应用场景" class="headerlink" title="二 应用场景"></a>二 应用场景</h2><ol>
<li>this作用域是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。它作为非静态成员函数的隐含形参，对各成员的访问均通过this进行。</li>
<li>在类的非静态成员函数中返回类对象本身的时候，直接使用 return *this；</li>
<li>当参数与成员变量名相同时使用this指针指向成员变量，例如this-&gt;n = n （不能写成n = n）。<h2 id="三-注意事项"><a href="#三-注意事项" class="headerlink" title="三 注意事项"></a>三 注意事项</h2></li>
<li>友元函数没有this指针，因为友元不是类的成员。只有成员函数才有 this 指针。    </li>
<li>this指针只能在一个类的成员函数中调用，它表示当前对象的地址。(全局函数，静态函数都不能使用this。)</li>
<li>this在成员函数的开始前构造的，在成员的结束后清除。这个生命周期同任一个函数的参数是一样的，没有任何区别。当调用一个类的成员函数时，编译器将类的指针作为函数的this参数传递进去。</li>
</ol>
<ul>
<li>参考：<a href="https://baike.baidu.com/item/C++this%E6%8C%87%E9%92%88/637012" target="_blank" rel="noopener">百度百科C++this指针词条</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++相关</tag>
        <tag>this指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的环境编程之静态库和动态库</title>
    <url>/2018/11/21/Linux_LinkSharelib/</url>
    <content><![CDATA[<p>静态库和动态库的链接各有优缺点,静态库会在文件编译二进制文件的时候,会直接链接到二进制文件里面,这样子文件体积比较大,而且如果我们更改分享库的时候需要重新编译.动态库只是保存分享库和二进制文件的依赖关系.在运行阶段才会加载动态库</p>
<a id="more"></a>

<p>参考书籍:&lt;Linux的环境编程,从应用到内核&gt;</p>
<p>操作系统:deepin</p>
<p>编译器:gcc</p>
<h1 id="简单动态库与静态库分析"><a href="#简单动态库与静态库分析" class="headerlink" title="简单动态库与静态库分析"></a>简单动态库与静态库分析</h1><p>这里要区分一下静态链接和动态链接的区别以及,静态库和动态库的区别.</p>
<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>静态库在linux下是以”.a”结尾的,静态库将汇编 生成的.o文件进打包成一个.a文件,静态库可以在可执行文件编译的时候直接链接进可执行文件里面,移植方便,在新的操作系统上面运行不用搭建库环境.</p>
<ol>
<li><p>创建静态库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc  -c test1.c test2.c test3.c   ;-c命令是只编译不链接,会自动生成test1.o test2.o test3.o</span><br><span class="line">ar  -crv libtest.a  test1.o test2.o test3.o  ;使用ar工匠打包成静态库</span><br><span class="line">上面我们需要注意一下静态库和动态库的命名上市 lib****.so  lib****.a  ;我们在链接库的时候有时候会指定特定的库时,-l*** 就行,然后系统就自动会解析出来 -l lib***.so ,这个也是为什么这样命名</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><p>动态库是在可执行文件编译的时候将库函数链接加载进去,在可执行文件 运行时依靠这依赖关系加载.这样可以使代码轻便,而且更新库文件的话,可执行文件不要重新编译.</p>
<ol>
<li><p>制作动态库</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gcc -Wall -shared test1.c  -o libtest.so</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="简单小例子"><a href="#简单小例子" class="headerlink" title="简单小例子"></a>简单小例子</h2><ol>
<li><p>编译一个简单的C文件</p>
</li>
<li><figure class="highlight vim"><figcaption><span>test.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">vim</span> test1.<span class="keyword">c</span></span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">内容如下:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Welcome !!\r\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test1.c -o test1  ;这是默认动态链接</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc test1.c -o test1_1 -static ;这是静态链接</span><br></pre></td></tr></table></figure>

<p><img src="http://cdn.funful.ink/2018-11-19.png" alt></p>
</li>
</ol>
<ol start="6">
<li><p>对比上图可以发现静态链接的可执行文件比动态链接的大特别多.</p>
</li>
<li><p>使用ldd(查询动态依赖关系)命令查看</p>
<p><img src="http://cdn.funful.ink/2018-11-20-6.png" alt></p>
<p>可以看出来使用动态库链接的时候 使用ldd命令看到依赖的库,但是静态链接的会提示不是一个动态可执行文件,因为他是动态依赖的,运行过程不要动态依赖,</p>
</li>
</ol>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><h1 id="生成和使用动态库"><a href="#生成和使用动态库" class="headerlink" title="生成和使用动态库"></a>生成和使用动态库</h1><h2 id="编译生成一个动态库"><a href="#编译生成一个动态库" class="headerlink" title="编译生成一个动态库"></a>编译生成一个动态库</h2><ol>
<li><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Funful_call</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Welcome \r\n"</span>);   </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"调用动态库\r\n"</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -Wall -shared lib_funful.c -o  libfunful.so</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="使用动态库"><a href="#使用动态库" class="headerlink" title="使用动态库"></a>使用动态库</h2><ol>
<li><p>创建一个test3.c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">int  main(void) &#123;</span><br><span class="line"></span><br><span class="line"> Funful_call();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> return  0;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -W test3.c  -o test3 -L ./  -lfunful</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行会发现找不到libfunful.so  ,这是因为我们上面只是指定了编译时候的动态库地址,但是我们运行的时候还是在系统默认的库地址(/usr/lib ;/lib)进行链接;可以通过/ect/ld.so.conf,配置文件和环境变量LD_LiBRARY_PATH指示额外的动态库路径.</p>
<p>还可以通过libfunful.so移到/usr/lib或者/lib里面,这样我们的库就可以正常运行.</p>
</li>
</ol>
<h1 id="手动加载动态库"><a href="#手动加载动态库" class="headerlink" title="手动加载动态库"></a>手动加载动态库</h1><p>系统的C库提供了一系列接口,开手动加载动态库功能.</p>
<p>头文件:  #include “dlfcn.h”    ;//可是使用find命令查找</p>
<p>头文件:  /bits/dlfcn.h             里面是对相应的宏定义</p>
<h2 id="相关函数介绍"><a href="#相关函数介绍" class="headerlink" title="相关函数介绍"></a>相关函数介绍</h2><h3 id="dlopen"><a href="#dlopen" class="headerlink" title="dlopen"></a>dlopen</h3><ol>
<li><p>打开接口函数,返回一个句柄,然后通过dlsym得到相应的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> mode)</span> __THROWNL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数:  </p>
<ol>
<li><p>const char *file;找到文件地址指针</p>
</li>
<li><p>int  mode; 打开的模式,在linux按照功能可以分为三类</p>
<ol>
<li><p>解析方式:</p>
<p>​          RTLD_LAZY   在dlopen返回前，对于动态库中的未定义的符号不执行解析</p>
<p>​              RTLD_NOW    在dlopen返回前，解析出所有未定义符号，如果解析不出来，在dlopen会返回NULL</p>
</li>
<li><p>作用范围:</p>
<p>​              RTLD_GLOBAL  动态库中定义的符号可被其后打开的其它库解析</p>
<p>​         RTLD_LOCAL    与RTLD_GLOBAL作用相反，动态库中定义的符号不能被其后打开的其它库重定位。</p>
</li>
<li><p>作用方式</p>
<p>​             RTLD_NODELETE 在dlclose()期间不<a href="https://baike.baidu.com/item/%E5%8D%B8%E8%BD%BD" target="_blank" rel="noopener">卸载</a>库，并且在以后使用dlopen()重新加载库时不初始化库中的静态变量</p>
<p>​             RTLD_NOLOAD  不加载库</p>
<p>​            RTLD_DEEPBIND 在搜索全局符号前先搜索库内的符号，避免同名符号的冲突。</p>
</li>
</ol>
</li>
</ol>
<h3 id="dlclose"><a href="#dlclose" class="headerlink" title="dlclose"></a>dlclose</h3></li>
<li><p>关闭一个分享库,这个句柄在调用dlclose之后就不能在使用.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">1.  int dlclose (void *handle) THROWNL __nonnull ((1));</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数:</p>
<p>这个形参是dlopen返回的句柄.</p>
</li>
</ol>
<h3 id="dlsym"><a href="#dlsym" class="headerlink" title="dlsym"></a>dlsym</h3><ol>
<li><p>这个函数是根据链接库的句柄和符号,返回相应的符号地址.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span> <span class="params">(<span class="keyword">void</span> *__restrict __handle,</span></span></span><br><span class="line">		    const char *__restrict __name) __THROW __nonnull ((2));</span><br></pre></td></tr></table></figure>
</li>
<li><p>参数:</p>
<ol>
<li>void *__restrict __handle; 这个是链接库句柄</li>
<li>const char *__restrict __name ;符号的字符串指针</li>
</ol>
</li>
</ol>
<h2 id="手动加载动态库实例"><a href="#手动加载动态库实例" class="headerlink" title="手动加载动态库实例"></a>手动加载动态库实例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdlib.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dlfcn.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *dlib=dlopen(<span class="string">"./libfunful.so"</span>,RTLD_NOW);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dlib == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"open libfunful.so failed\r\n"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">void</span> (*dfunc)(<span class="keyword">void</span>) =dlsym(dlib,<span class="string">"Funful_call"</span>);</span><br><span class="line">    <span class="keyword">if</span>(dfunc==<span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dlsym failed \r\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   dfunc();</span><br><span class="line">   dlclose(dlib);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编译-1"><a href="#编译-1" class="headerlink" title="编译"></a>编译</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc test3.c -ldl -o test3   ;这里需要我们指定一下依赖的dl库,否则会提示undefined dl的函数</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面讲解的动态库加载分为两中方法,一种是更新环境变量的方法,一种是手动加载各有利弊,</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>静态库</tag>
        <tag>动态库</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt5移植4412时汉字及颜色显示</title>
    <url>/2018/06/08/Qt+ARM_fontsandcolor/</url>
    <content><![CDATA[<p>我们只要将在csdn下载几个中文字库，放到arm板子的lib/fonts/里面就可一完美支持汉字了</p>
<p> 参考文章:<a href="https://blog.csdn.net/u013816798/article/details/51095642" target="_blank" rel="noopener">Qt5在Arm板上中文的显示问题</a></p>
<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="在csdn下载中文字库"><a href="#在csdn下载中文字库" class="headerlink" title="在csdn下载中文字库"></a>在csdn下载中文字库</h3><p><a href="https://download.csdn.net/download/jiang_dlut/9567481" target="_blank" rel="noopener">链接地址</a></p>
<h3 id="移到arm板子的-opt-qt5-7-0-lib-fonts-这是我的板子对应的qt的路径"><a href="#移到arm板子的-opt-qt5-7-0-lib-fonts-这是我的板子对应的qt的路径" class="headerlink" title="移到arm板子的/opt/qt5.7.0/lib/fonts(这是我的板子对应的qt的路径)"></a>移到arm板子的/opt/qt5.7.0/lib/fonts(这是我的板子对应的qt的路径)</h3><h3 id="下面设置库路径"><a href="#下面设置库路径" class="headerlink" title="下面设置库路径"></a>下面设置库路径</h3><p>我们进入到板子系统的/etc/profile下面添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">：export QTDIR=(字体所在路径) </span><br><span class="line">：export QT_QWS_FONTDIR=$QTDIR/lib/fonts。（这个是字体所在的具体路径）</span><br></pre></td></tr></table></figure>

<h3 id="幸运的话-，此时就可以显示汉字了，但是有些qt的控件仍然不支持汉字，则需要下面的转换"><a href="#幸运的话-，此时就可以显示汉字了，但是有些qt的控件仍然不支持汉字，则需要下面的转换" class="headerlink" title="幸运的话 ，此时就可以显示汉字了，但是有些qt的控件仍然不支持汉字，则需要下面的转换"></a>幸运的话 ，此时就可以显示汉字了，但是有些qt的控件仍然不支持汉字，则需要下面的转换</h3><p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ui-&gt;label-&gt;setText(<span class="string">"中文字体"</span>);</span><br><span class="line">改成</span><br><span class="line">ui-&gt;label-&gt;setText(QObject::trUtf8(<span class="string">"中文字体"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="在运行程序时的可选参数"><a href="#在运行程序时的可选参数" class="headerlink" title="在运行程序时的可选参数"></a>在运行程序时的可选参数</h3><p>程序启动命令选项：<br>-fn 定义程序的字体</p>
<p>-bg 设置程序默认背景颜色 例如./myapplication -bg blue，颜色名称必须能被QColor类构造函数识别</p>
<p>-btn 设置默认的按钮颜色，例如./myapplication -btn green 同样颜色必须被认识</p>
<p>-fg 设置foreground颜色，例如./myapplication -fg ‘dark blue’ 同上需被认识</p>
<p>-name 设置应用程序名字 例如./myapplication -name texteditapplication</p>
<p>-title 设置应用程序标题。./myapplication -title ‘Text Edit’</p>
<p>-geometry x++<br>设置窗口大小， ./myapplication -geometry 300x200+50+50</p>
<p>-keyboard 启动键盘</p>
<p>-nokeyboard 关闭键盘</p>
<p>-mouse 启动鼠标</p>
<p>-nomouse 关闭鼠标</p>
<p>-qws 设置为服务程序</p>
<p>-display 设置显示器驱动</p>
<p>-decoration</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>移植</tag>
        <tag>Qt</tag>
        <tag>4412</tag>
      </tags>
  </entry>
  <entry>
    <title>linux + Qt 移植 Mplayer</title>
    <url>/2018/05/25/linux+Qt_c_conplicationMplayer/</url>
    <content><![CDATA[<p>参考文章:<a href="https://blog.csdn.net/navydianzi/article/details/46746187" target="_blank" rel="noopener">Tiny4412开发板Mplayer 移植</a></p>
<p>迅为4412的linux和Qt 移植Mplayer！</p>
<a id="more"></a>

<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="解压MPlayer-1-0rc2-tar-bz2"><a href="#解压MPlayer-1-0rc2-tar-bz2" class="headerlink" title="解压MPlayer-1.0rc2.tar.bz2"></a>解压MPlayer-1.0rc2.tar.bz2</h3><h3 id="进入该目录-执行"><a href="#进入该目录-执行" class="headerlink" title="进入该目录 执行"></a>进入该目录 执行</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">sudo ./configure </span><br><span class="line">      --host-cc=/usr/bin/gcc   \</span><br><span class="line">      --cc=/usr/share/arm/<span class="number">4.3</span>.<span class="number">2</span>/bin/arm-linux-gcc-<span class="number">4.3</span>.<span class="number">2</span>    \</span><br><span class="line">      --target=arm-linux  \</span><br><span class="line">      --enable-static \</span><br><span class="line">      --disable-win32dll\</span><br><span class="line">  	  --disable-dvdread \</span><br><span class="line">      --disable-dvdread-internal \</span><br><span class="line">      --disable-dvdnav\</span><br><span class="line">      --disable-libdvdcss-internal \</span><br><span class="line">  	  --enable-fbdev \</span><br><span class="line">  	  --disable-mencoder \</span><br><span class="line">  	  --disable-live\</span><br><span class="line">      --disable-mp3lib \</span><br><span class="line">      --enable-mad\</span><br><span class="line">      --enable-libavcodec_a \</span><br><span class="line">      --disable-live \</span><br><span class="line">      --disable-ivtv \</span><br><span class="line">      --prefix=/usr/share/arm/Mplayer_Ku/\</span><br></pre></td></tr></table></figure>

<h3 id="成功之后-执行"><a href="#成功之后-执行" class="headerlink" title="成功之后 执行"></a>成功之后 执行</h3><ol>
<li>make</li>
<li>然后 </li>
</ol>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">make <span class="keyword">install</span> --target=arm-linux  \</span><br><span class="line">--enable-static \</span><br><span class="line">--disable-win32dll \</span><br><span class="line">--disable-dvdread \</span><br><span class="line">--disable-dvdread-internal\</span><br><span class="line">--disable-dvdnav \</span><br><span class="line">--disable-libdvdcss-internal \</span><br><span class="line">--enable-fbdev \</span><br><span class="line">--disable-mencoder\</span><br><span class="line">--disable-live \</span><br><span class="line">--disable-mp3lib\ </span><br><span class="line">--enable-mad \</span><br><span class="line">--enable-libavcodec_a \</span><br><span class="line">--disable-live \</span><br><span class="line">--disable-ivtv \</span><br><span class="line">--prefix=/usr/share/arm/Mplayer_Ku  \</span><br><span class="line">--with-extraincdir=/usr/local/lib/mad_arm/<span class="keyword">include</span>   \</span><br><span class="line">--with-extralibdir=/usr/local/lib/mad_arm/lib\</span><br></pre></td></tr></table></figure>

<h3 id="进入前面自己定义的库路径"><a href="#进入前面自己定义的库路径" class="headerlink" title="进入前面自己定义的库路径"></a>进入前面自己定义的库路径</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd  /usr/share/arm/Mplayer_ku/bin</span><br><span class="line"> arm-linux-readelf -h mplayer</span><br></pre></td></tr></table></figure>

<p>可以看到生成的mplayer文件是ARM下的 ELF32</p>
<p> 然后将mplayer移到arm板子上面，并且将相应的动态库移到ARM下的lib</p>
<h2 id="错误及解决"><a href="#错误及解决" class="headerlink" title="错误及解决"></a>错误及解决</h2><ol>
<li>在libmpeg2/motion_comp_arm_s.S文件前面添加</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef HAVE_PLD</span><br><span class="line">.macro pld reg</span><br><span class="line">.endm</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>make失败 提示</li>
</ol>
<figure class="highlight plain"><figcaption><span>find -lmad```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">接下来要把libmad的安装一下 ，参考文章[libmad的移植、交叉编译、安装——基于ubuntu16](https://blog.csdn.net/seven159/article/details/72614293)</span><br><span class="line"></span><br><span class="line">安装完成之后继续make</span><br><span class="line"></span><br><span class="line">3. make install 失败（错误代码）：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">strip: Unable to recognise the format of the input file `/usr/share/arm/Mplayer_Ku/bin/mplayer&apos;</span><br><span class="line">install: strip process terminated abnormally</span><br><span class="line">Makefile:256: recipe for target &apos;install-mplayer&apos; failed</span><br></pre></td></tr></table></figure>

<p>解决方案 :</p>
<p>进入到Makefile 的256行</p>
<p>在256行上面一行添加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSTALLSTRIP :=</span><br></pre></td></tr></table></figure>

<p>因为**INSTALLSTRIP 的默认参数是-s</p>
<p>我们需要将其置为空</p>
<p>​</p>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>移植</tag>
        <tag>Qt</tag>
        <tag>Mplayer</tag>
      </tags>
  </entry>
</search>
